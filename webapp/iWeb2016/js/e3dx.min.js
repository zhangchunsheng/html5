function extend(a, b) {
    var c = function() {};
    c.prototype = b.prototype, a.prototype = new c, a.prototype.constructor = a, a.superclass = b.prototype, b.prototype.constructor == Object.prototype.constructor && (b.prototype.constructor = b)
}

function extendMul(a, b) {
    for (var c in b) {
        var d = b[c];
        for (var e in d.prototype) a.prototype[e] = d.prototype[e]
    }
}

function VComparator(a, b) {
    return a.center.z < b.center.z
}
var CryptoJS = CryptoJS || function(a, b) {
    var c = {},
        d = c.lib = {},
        e = function() {},
        f = d.Base = {
            extend: function(a) {
                e.prototype = this;
                var b = new e;
                return a && b.mixIn(a), b.hasOwnProperty("init") || (b.init = function() {
                    b.$super.init.apply(this, arguments)
                }), b.init.prototype = b, b.$super = this, b
            },
            create: function() {
                var a = this.extend();
                return a.init.apply(a, arguments), a
            },
            init: function() {},
            mixIn: function(a) {
                for (var b in a) a.hasOwnProperty(b) && (this[b] = a[b]);
                a.hasOwnProperty("toString") && (this.toString = a.toString)
            },
            clone: function() {
                return this.init.prototype.extend(this)
            }
        },
        g = d.WordArray = f.extend({
            init: function(a, c) {
                a = this.words = a || [], this.sigBytes = c != b ? c : 4 * a.length
            },
            toString: function(a) {
                return (a || i).stringify(this)
            },
            concat: function(a) {
                var b = this.words,
                    c = a.words,
                    d = this.sigBytes;
                if (a = a.sigBytes, this.clamp(), d % 4)
                    for (var e = 0; a > e; e++) b[d + e >>> 2] |= (c[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((d + e) % 4);
                else if (65535 < c.length)
                    for (e = 0; a > e; e += 4) b[d + e >>> 2] = c[e >>> 2];
                else b.push.apply(b, c);
                return this.sigBytes += a, this
            },
            clamp: function() {
                var b = this.words,
                    c = this.sigBytes;
                b[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4), b.length = a.ceil(c / 4)
            },
            clone: function() {
                var a = f.clone.call(this);
                return a.words = this.words.slice(0), a
            },
            random: function(b) {
                for (var c = [], d = 0; b > d; d += 4) c.push(4294967296 * a.random() | 0);
                return new g.init(c, b)
            }
        }),
        h = c.enc = {},
        i = h.Hex = {
            stringify: function(a) {
                var b = a.words;
                a = a.sigBytes;
                for (var c = [], d = 0; a > d; d++) {
                    var e = b[d >>> 2] >>> 24 - 8 * (d % 4) & 255;
                    c.push((e >>> 4).toString(16)), c.push((15 & e).toString(16))
                }
                return c.join("")
            },
            parse: function(a) {
                for (var b = a.length, c = [], d = 0; b > d; d += 2) c[d >>> 3] |= parseInt(a.substr(d, 2), 16) << 24 - 4 * (d % 8);
                return new g.init(c, b / 2)
            }
        },
        j = h.Latin1 = {
            stringify: function(a) {
                var b = a.words;
                a = a.sigBytes;
                for (var c = [], d = 0; a > d; d++) c.push(String.fromCharCode(b[d >>> 2] >>> 24 - 8 * (d % 4) & 255));
                return c.join("")
            },
            parse: function(a) {
                for (var b = a.length, c = [], d = 0; b > d; d++) c[d >>> 2] |= (255 & a.charCodeAt(d)) << 24 - 8 * (d % 4);
                return new g.init(c, b)
            }
        },
        k = h.Utf8 = {
            stringify: function(a) {
                try {
                    return decodeURIComponent(escape(j.stringify(a)))
                } catch (b) {
                    throw Error("Malformed UTF-8 data")
                }
            },
            parse: function(a) {
                return j.parse(unescape(encodeURIComponent(a)))
            }
        },
        l = d.BufferedBlockAlgorithm = f.extend({
            reset: function() {
                this._data = new g.init, this._nDataBytes = 0
            },
            _append: function(a) {
                "string" == typeof a && (a = k.parse(a)), this._data.concat(a), this._nDataBytes += a.sigBytes
            },
            _process: function(b) {
                var c = this._data,
                    d = c.words,
                    e = c.sigBytes,
                    f = this.blockSize,
                    h = e / (4 * f),
                    h = b ? a.ceil(h) : a.max((0 | h) - this._minBufferSize, 0);
                if (b = h * f, e = a.min(4 * b, e), b) {
                    for (var i = 0; b > i; i += f) this._doProcessBlock(d, i);
                    i = d.splice(0, b), c.sigBytes -= e
                }
                return new g.init(i, e)
            },
            clone: function() {
                var a = f.clone.call(this);
                return a._data = this._data.clone(), a
            },
            _minBufferSize: 0
        });
    d.Hasher = l.extend({
        cfg: f.extend(),
        init: function(a) {
            this.cfg = this.cfg.extend(a), this.reset()
        },
        reset: function() {
            l.reset.call(this), this._doReset()
        },
        update: function(a) {
            return this._append(a), this._process(), this
        },
        finalize: function(a) {
            return a && this._append(a), this._doFinalize()
        },
        blockSize: 16,
        _createHelper: function(a) {
            return function(b, c) {
                return new a.init(c).finalize(b)
            }
        },
        _createHmacHelper: function(a) {
            return function(b, c) {
                return new m.HMAC.init(a, c).finalize(b)
            }
        }
    });
    var m = c.algo = {};
    return c
}(Math);
! function() {
    var a = CryptoJS,
        b = a.lib.WordArray;
    a.enc.Base64 = {
        stringify: function(a) {
            var b = a.words,
                c = a.sigBytes,
                d = this._map;
            a.clamp(), a = [];
            for (var e = 0; c > e; e += 3)
                for (var f = (b[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 16 | (b[e + 1 >>> 2] >>> 24 - 8 * ((e + 1) % 4) & 255) << 8 | b[e + 2 >>> 2] >>> 24 - 8 * ((e + 2) % 4) & 255, g = 0; 4 > g && c > e + .75 * g; g++) a.push(d.charAt(f >>> 6 * (3 - g) & 63));
            if (b = d.charAt(64))
                for (; a.length % 4;) a.push(b);
            return a.join("")
        },
        parse: function(a) {
            var c = a.length,
                d = this._map,
                e = d.charAt(64);
            e && (e = a.indexOf(e), -1 != e && (c = e));
            for (var e = [], f = 0, g = 0; c > g; g++)
                if (g % 4) {
                    var h = d.indexOf(a.charAt(g - 1)) << 2 * (g % 4),
                        i = d.indexOf(a.charAt(g)) >>> 6 - 2 * (g % 4);
                    e[f >>> 2] |= (h | i) << 24 - 8 * (f % 4), f++
                }
            return b.create(e, f)
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    }
}(),
function(a) {
    function b(a, b, c, d, e, f, g) {
        return a = a + (b & c | ~b & d) + e + g, (a << f | a >>> 32 - f) + b
    }

    function c(a, b, c, d, e, f, g) {
        return a = a + (b & d | c & ~d) + e + g, (a << f | a >>> 32 - f) + b
    }

    function d(a, b, c, d, e, f, g) {
        return a = a + (b ^ c ^ d) + e + g, (a << f | a >>> 32 - f) + b
    }

    function e(a, b, c, d, e, f, g) {
        return a = a + (c ^ (b | ~d)) + e + g, (a << f | a >>> 32 - f) + b
    }
    for (var f = CryptoJS, g = f.lib, h = g.WordArray, i = g.Hasher, g = f.algo, j = [], k = 0; 64 > k; k++) j[k] = 4294967296 * a.abs(a.sin(k + 1)) | 0;
    g = g.MD5 = i.extend({
        _doReset: function() {
            this._hash = new h.init([1732584193, 4023233417, 2562383102, 271733878])
        },
        _doProcessBlock: function(a, f) {
            for (var g = 0; 16 > g; g++) {
                var h = f + g,
                    i = a[h];
                a[h] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8)
            }
            var g = this._hash.words,
                h = a[f + 0],
                i = a[f + 1],
                k = a[f + 2],
                l = a[f + 3],
                m = a[f + 4],
                n = a[f + 5],
                o = a[f + 6],
                p = a[f + 7],
                q = a[f + 8],
                r = a[f + 9],
                s = a[f + 10],
                t = a[f + 11],
                u = a[f + 12],
                v = a[f + 13],
                w = a[f + 14],
                x = a[f + 15],
                y = g[0],
                z = g[1],
                A = g[2],
                B = g[3],
                y = b(y, z, A, B, h, 7, j[0]),
                B = b(B, y, z, A, i, 12, j[1]),
                A = b(A, B, y, z, k, 17, j[2]),
                z = b(z, A, B, y, l, 22, j[3]),
                y = b(y, z, A, B, m, 7, j[4]),
                B = b(B, y, z, A, n, 12, j[5]),
                A = b(A, B, y, z, o, 17, j[6]),
                z = b(z, A, B, y, p, 22, j[7]),
                y = b(y, z, A, B, q, 7, j[8]),
                B = b(B, y, z, A, r, 12, j[9]),
                A = b(A, B, y, z, s, 17, j[10]),
                z = b(z, A, B, y, t, 22, j[11]),
                y = b(y, z, A, B, u, 7, j[12]),
                B = b(B, y, z, A, v, 12, j[13]),
                A = b(A, B, y, z, w, 17, j[14]),
                z = b(z, A, B, y, x, 22, j[15]),
                y = c(y, z, A, B, i, 5, j[16]),
                B = c(B, y, z, A, o, 9, j[17]),
                A = c(A, B, y, z, t, 14, j[18]),
                z = c(z, A, B, y, h, 20, j[19]),
                y = c(y, z, A, B, n, 5, j[20]),
                B = c(B, y, z, A, s, 9, j[21]),
                A = c(A, B, y, z, x, 14, j[22]),
                z = c(z, A, B, y, m, 20, j[23]),
                y = c(y, z, A, B, r, 5, j[24]),
                B = c(B, y, z, A, w, 9, j[25]),
                A = c(A, B, y, z, l, 14, j[26]),
                z = c(z, A, B, y, q, 20, j[27]),
                y = c(y, z, A, B, v, 5, j[28]),
                B = c(B, y, z, A, k, 9, j[29]),
                A = c(A, B, y, z, p, 14, j[30]),
                z = c(z, A, B, y, u, 20, j[31]),
                y = d(y, z, A, B, n, 4, j[32]),
                B = d(B, y, z, A, q, 11, j[33]),
                A = d(A, B, y, z, t, 16, j[34]),
                z = d(z, A, B, y, w, 23, j[35]),
                y = d(y, z, A, B, i, 4, j[36]),
                B = d(B, y, z, A, m, 11, j[37]),
                A = d(A, B, y, z, p, 16, j[38]),
                z = d(z, A, B, y, s, 23, j[39]),
                y = d(y, z, A, B, v, 4, j[40]),
                B = d(B, y, z, A, h, 11, j[41]),
                A = d(A, B, y, z, l, 16, j[42]),
                z = d(z, A, B, y, o, 23, j[43]),
                y = d(y, z, A, B, r, 4, j[44]),
                B = d(B, y, z, A, u, 11, j[45]),
                A = d(A, B, y, z, x, 16, j[46]),
                z = d(z, A, B, y, k, 23, j[47]),
                y = e(y, z, A, B, h, 6, j[48]),
                B = e(B, y, z, A, p, 10, j[49]),
                A = e(A, B, y, z, w, 15, j[50]),
                z = e(z, A, B, y, n, 21, j[51]),
                y = e(y, z, A, B, u, 6, j[52]),
                B = e(B, y, z, A, l, 10, j[53]),
                A = e(A, B, y, z, s, 15, j[54]),
                z = e(z, A, B, y, i, 21, j[55]),
                y = e(y, z, A, B, q, 6, j[56]),
                B = e(B, y, z, A, x, 10, j[57]),
                A = e(A, B, y, z, o, 15, j[58]),
                z = e(z, A, B, y, v, 21, j[59]),
                y = e(y, z, A, B, m, 6, j[60]),
                B = e(B, y, z, A, t, 10, j[61]),
                A = e(A, B, y, z, k, 15, j[62]),
                z = e(z, A, B, y, r, 21, j[63]);
            g[0] = g[0] + y | 0, g[1] = g[1] + z | 0, g[2] = g[2] + A | 0, g[3] = g[3] + B | 0
        },
        _doFinalize: function() {
            var b = this._data,
                c = b.words,
                d = 8 * this._nDataBytes,
                e = 8 * b.sigBytes;
            c[e >>> 5] |= 128 << 24 - e % 32;
            var f = a.floor(d / 4294967296);
            for (c[(e + 64 >>> 9 << 4) + 15] = 16711935 & (f << 8 | f >>> 24) | 4278255360 & (f << 24 | f >>> 8), c[(e + 64 >>> 9 << 4) + 14] = 16711935 & (d << 8 | d >>> 24) | 4278255360 & (d << 24 | d >>> 8), b.sigBytes = 4 * (c.length + 1), this._process(), b = this._hash, c = b.words, d = 0; 4 > d; d++) e = c[d], c[d] = 16711935 & (e << 8 | e >>> 24) | 4278255360 & (e << 24 | e >>> 8);
            return b
        },
        clone: function() {
            var a = i.clone.call(this);
            return a._hash = this._hash.clone(), a
        }
    }), f.MD5 = i._createHelper(g), f.HmacMD5 = i._createHmacHelper(g)
}(Math),
function() {
    var a = CryptoJS,
        b = a.lib,
        c = b.Base,
        d = b.WordArray,
        b = a.algo,
        e = b.EvpKDF = c.extend({
            cfg: c.extend({
                keySize: 4,
                hasher: b.MD5,
                iterations: 1
            }),
            init: function(a) {
                this.cfg = this.cfg.extend(a)
            },
            compute: function(a, b) {
                for (var c = this.cfg, e = c.hasher.create(), f = d.create(), g = f.words, h = c.keySize, c = c.iterations; g.length < h;) {
                    i && e.update(i);
                    var i = e.update(a).finalize(b);
                    e.reset();
                    for (var j = 1; c > j; j++) i = e.finalize(i), e.reset();
                    f.concat(i)
                }
                return f.sigBytes = 4 * h, f
            }
        });
    a.EvpKDF = function(a, b, c) {
        return e.create(c).compute(a, b)
    }
}(), CryptoJS.lib.Cipher || function(a) {
        var b = CryptoJS,
            c = b.lib,
            d = c.Base,
            e = c.WordArray,
            f = c.BufferedBlockAlgorithm,
            g = b.enc.Base64,
            h = b.algo.EvpKDF,
            i = c.Cipher = f.extend({
                cfg: d.extend(),
                createEncryptor: function(a, b) {
                    return this.create(this._ENC_XFORM_MODE, a, b)
                },
                createDecryptor: function(a, b) {
                    return this.create(this._DEC_XFORM_MODE, a, b)
                },
                init: function(a, b, c) {
                    this.cfg = this.cfg.extend(c), this._xformMode = a, this._key = b, this.reset()
                },
                reset: function() {
                    f.reset.call(this), this._doReset()
                },
                process: function(a) {
                    return this._append(a), this._process()
                },
                finalize: function(a) {
                    return a && this._append(a), this._doFinalize()
                },
                keySize: 4,
                ivSize: 4,
                _ENC_XFORM_MODE: 1,
                _DEC_XFORM_MODE: 2,
                _createHelper: function(a) {
                    return {
                        encrypt: function(b, c, d) {
                            return ("string" == typeof c ? o : n).encrypt(a, b, c, d)
                        },
                        decrypt: function(b, c, d) {
                            return ("string" == typeof c ? o : n).decrypt(a, b, c, d)
                        }
                    }
                }
            });
        c.StreamCipher = i.extend({
            _doFinalize: function() {
                return this._process(!0)
            },
            blockSize: 1
        });
        var j = b.mode = {},
            k = function(b, c, d) {
                var e = this._iv;
                e ? this._iv = a : e = this._prevBlock;
                for (var f = 0; d > f; f++) b[c + f] ^= e[f]
            },
            l = (c.BlockCipherMode = d.extend({
                createEncryptor: function(a, b) {
                    return this.Encryptor.create(a, b)
                },
                createDecryptor: function(a, b) {
                    return this.Decryptor.create(a, b)
                },
                init: function(a, b) {
                    this._cipher = a, this._iv = b
                }
            })).extend();
        l.Encryptor = l.extend({
            processBlock: function(a, b) {
                var c = this._cipher,
                    d = c.blockSize;
                k.call(this, a, b, d), c.encryptBlock(a, b), this._prevBlock = a.slice(b, b + d)
            }
        }), l.Decryptor = l.extend({
            processBlock: function(a, b) {
                var c = this._cipher,
                    d = c.blockSize,
                    e = a.slice(b, b + d);
                c.decryptBlock(a, b), k.call(this, a, b, d), this._prevBlock = e
            }
        }), j = j.CBC = l, l = (b.pad = {}).Pkcs7 = {
            pad: function(a, b) {
                for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, f = [], g = 0; c > g; g += 4) f.push(d);
                c = e.create(f, c), a.concat(c)
            },
            unpad: function(a) {
                a.sigBytes -= 255 & a.words[a.sigBytes - 1 >>> 2]
            }
        }, c.BlockCipher = i.extend({
            cfg: i.cfg.extend({
                mode: j,
                padding: l
            }),
            reset: function() {
                i.reset.call(this);
                var a = this.cfg,
                    b = a.iv,
                    a = a.mode;
                if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;
                else c = a.createDecryptor, this._minBufferSize = 1;
                this._mode = c.call(a, this, b && b.words)
            },
            _doProcessBlock: function(a, b) {
                this._mode.processBlock(a, b)
            },
            _doFinalize: function() {
                var a = this.cfg.padding;
                if (this._xformMode == this._ENC_XFORM_MODE) {
                    a.pad(this._data, this.blockSize);
                    var b = this._process(!0)
                } else b = this._process(!0), a.unpad(b);
                return b
            },
            blockSize: 4
        });
        var m = c.CipherParams = d.extend({
                init: function(a) {
                    this.mixIn(a)
                },
                toString: function(a) {
                    return (a || this.formatter).stringify(this)
                }
            }),
            j = (b.format = {}).OpenSSL = {
                stringify: function(a) {
                    var b = a.ciphertext;
                    return a = a.salt, (a ? e.create([1398893684, 1701076831]).concat(a).concat(b) : b).toString(g)
                },
                parse: function(a) {
                    a = g.parse(a);
                    var b = a.words;
                    if (1398893684 == b[0] && 1701076831 == b[1]) {
                        var c = e.create(b.slice(2, 4));
                        b.splice(0, 4), a.sigBytes -= 16
                    }
                    return m.create({
                        ciphertext: a,
                        salt: c
                    })
                }
            },
            n = c.SerializableCipher = d.extend({
                cfg: d.extend({
                    format: j
                }),
                encrypt: function(a, b, c, d) {
                    d = this.cfg.extend(d);
                    var e = a.createEncryptor(c, d);
                    return b = e.finalize(b), e = e.cfg, m.create({
                        ciphertext: b,
                        key: c,
                        iv: e.iv,
                        algorithm: a,
                        mode: e.mode,
                        padding: e.padding,
                        blockSize: a.blockSize,
                        formatter: d.format
                    })
                },
                decrypt: function(a, b, c, d) {
                    return d = this.cfg.extend(d), b = this._parse(b, d.format), a.createDecryptor(c, d).finalize(b.ciphertext)
                },
                _parse: function(a, b) {
                    return "string" == typeof a ? b.parse(a, this) : a
                }
            }),
            b = (b.kdf = {}).OpenSSL = {
                execute: function(a, b, c, d) {
                    return d || (d = e.random(8)), a = h.create({
                        keySize: b + c
                    }).compute(a, d), c = e.create(a.words.slice(b), 4 * c), a.sigBytes = 4 * b, m.create({
                        key: a,
                        iv: c,
                        salt: d
                    })
                }
            },
            o = c.PasswordBasedCipher = n.extend({
                cfg: n.cfg.extend({
                    kdf: b
                }),
                encrypt: function(a, b, c, d) {
                    return d = this.cfg.extend(d), c = d.kdf.execute(c, a.keySize, a.ivSize), d.iv = c.iv, a = n.encrypt.call(this, a, b, c.key, d), a.mixIn(c), a
                },
                decrypt: function(a, b, c, d) {
                    return d = this.cfg.extend(d), b = this._parse(b, d.format), c = d.kdf.execute(c, a.keySize, a.ivSize, b.salt), d.iv = c.iv, n.decrypt.call(this, a, b, c.key, d)
                }
            })
    }(),
    function() {
        for (var a = CryptoJS, b = a.lib.BlockCipher, c = a.algo, d = [], e = [], f = [], g = [], h = [], i = [], j = [], k = [], l = [], m = [], n = [], o = 0; 256 > o; o++) n[o] = 128 > o ? o << 1 : o << 1 ^ 283;
        for (var p = 0, q = 0, o = 0; 256 > o; o++) {
            var r = q ^ q << 1 ^ q << 2 ^ q << 3 ^ q << 4,
                r = r >>> 8 ^ 255 & r ^ 99;
            d[p] = r, e[r] = p;
            var s = n[p],
                t = n[s],
                u = n[t],
                v = 257 * n[r] ^ 16843008 * r;
            f[p] = v << 24 | v >>> 8, g[p] = v << 16 | v >>> 16, h[p] = v << 8 | v >>> 24, i[p] = v, v = 16843009 * u ^ 65537 * t ^ 257 * s ^ 16843008 * p, j[r] = v << 24 | v >>> 8, k[r] = v << 16 | v >>> 16, l[r] = v << 8 | v >>> 24, m[r] = v, p ? (p = s ^ n[n[n[u ^ s]]], q ^= n[n[q]]) : p = q = 1
        }
        var w = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
            c = c.AES = b.extend({
                _doReset: function() {
                    for (var a = this._key, b = a.words, c = a.sigBytes / 4, a = 4 * ((this._nRounds = c + 6) + 1), e = this._keySchedule = [], f = 0; a > f; f++)
                        if (c > f) e[f] = b[f];
                        else {
                            var g = e[f - 1];
                            f % c ? c > 6 && 4 == f % c && (g = d[g >>> 24] << 24 | d[g >>> 16 & 255] << 16 | d[g >>> 8 & 255] << 8 | d[255 & g]) : (g = g << 8 | g >>> 24, g = d[g >>> 24] << 24 | d[g >>> 16 & 255] << 16 | d[g >>> 8 & 255] << 8 | d[255 & g], g ^= w[f / c | 0] << 24), e[f] = e[f - c] ^ g
                        }
                    for (b = this._invKeySchedule = [], c = 0; a > c; c++) f = a - c, g = c % 4 ? e[f] : e[f - 4], b[c] = 4 > c || 4 >= f ? g : j[d[g >>> 24]] ^ k[d[g >>> 16 & 255]] ^ l[d[g >>> 8 & 255]] ^ m[d[255 & g]]
                },
                encryptBlock: function(a, b) {
                    this._doCryptBlock(a, b, this._keySchedule, f, g, h, i, d)
                },
                decryptBlock: function(a, b) {
                    var c = a[b + 1];
                    a[b + 1] = a[b + 3], a[b + 3] = c, this._doCryptBlock(a, b, this._invKeySchedule, j, k, l, m, e), c = a[b + 1], a[b + 1] = a[b + 3], a[b + 3] = c
                },
                _doCryptBlock: function(a, b, c, d, e, f, g, h) {
                    for (var i = this._nRounds, j = a[b] ^ c[0], k = a[b + 1] ^ c[1], l = a[b + 2] ^ c[2], m = a[b + 3] ^ c[3], n = 4, o = 1; i > o; o++) var p = d[j >>> 24] ^ e[k >>> 16 & 255] ^ f[l >>> 8 & 255] ^ g[255 & m] ^ c[n++],
                        q = d[k >>> 24] ^ e[l >>> 16 & 255] ^ f[m >>> 8 & 255] ^ g[255 & j] ^ c[n++],
                        r = d[l >>> 24] ^ e[m >>> 16 & 255] ^ f[j >>> 8 & 255] ^ g[255 & k] ^ c[n++],
                        m = d[m >>> 24] ^ e[j >>> 16 & 255] ^ f[k >>> 8 & 255] ^ g[255 & l] ^ c[n++],
                        j = p,
                        k = q,
                        l = r;
                    p = (h[j >>> 24] << 24 | h[k >>> 16 & 255] << 16 | h[l >>> 8 & 255] << 8 | h[255 & m]) ^ c[n++], q = (h[k >>> 24] << 24 | h[l >>> 16 & 255] << 16 | h[m >>> 8 & 255] << 8 | h[255 & j]) ^ c[n++], r = (h[l >>> 24] << 24 | h[m >>> 16 & 255] << 16 | h[j >>> 8 & 255] << 8 | h[255 & k]) ^ c[n++], m = (h[m >>> 24] << 24 | h[j >>> 16 & 255] << 16 | h[k >>> 8 & 255] << 8 | h[255 & l]) ^ c[n++], a[b] = p, a[b + 1] = q, a[b + 2] = r, a[b + 3] = m
                },
                keySize: 8
            });
        a.AES = b._createHelper(c)
    }(), CryptoJS.pad.ZeroPadding = {
        pad: function(a, b) {
            var c = 4 * b;
            a.clamp(), a.sigBytes += c - (a.sigBytes % c || c)
        },
        unpad: function(a) {
            for (var b = a.words, c = a.sigBytes - 1; !(b[c >>> 2] >>> 24 - c % 4 * 8 & 255);) c--;
            a.sigBytes = c + 1
        }
    }, CryptoJS.mode.ECB = function() {
        var a = CryptoJS.lib.BlockCipherMode.extend();
        return a.Encryptor = a.extend({
            processBlock: function(a, b) {
                this._cipher.encryptBlock(a, b)
            }
        }), a.Decryptor = a.extend({
            processBlock: function(a, b) {
                this._cipher.decryptBlock(a, b)
            }
        }), a
    }(),
    function(a) {
        function b(a) {
            var b = document.createElement("a");
            b.href = a;
            var c = b.search.substring(1),
                d = "id".length,
                e = c.indexOf("id");
            if (-1 == e) return "";
            e += d + 1;
            var f = c.indexOf("&", e);
            return -1 == f ? c.substring(e) : c.substring(e, f)
        }

        function c(a, b) {
            switch (a) {
                case d.E3D_EVENT_CLICK:
                    f.send_commant(b);
                    break;
                case d.E3D_CELL_CLOSE:
                    f.send_commant(b);
                    break;
                case d.E3D_PLATEFORM_SEND:
                    f.send_commant(b);
                    break;
                case d.E3D_URL_REQUEST:
                    f.send_commant(b);
                    break;
                case d.E3D_BUTTON_INNER_CLICK:
                    f.send_commant(b);
                    break;
                case d.E3D_APK_OPEN:
                    f.send_commant(b)
            }
        }
        var d = {
                E3D_EVENT_CLICK: 650,
                E3D_CELL_CLOSE: 653,
                E3D_PLATEFORM_SEND: 654,
                E3D_URL_REQUEST: 655,
                E3D_BUTTON_INNER_CLICK: 800,
                E3D_APK_OPEN: 801
            },
            e = function() {
                this.mAssetUrl = "/magic/geturl", this.mShareUrl = "/magic/getshare", this.mCellUrl = "http://h5tu.com/cgi-bin/cell_test?method=h5hit&apk=h5", this.mToken = null
            };
        e.prototype._sentDataToServer = function(a, b) {
            b = b || {};
            var c = new XMLHttpRequest,
                d = b.post || null,
                e = b.callback || null;
            b.timeout || null;
            c.onreadystatechange = function() {
                return 4 == c.readyState ? 200 != c.status && 304 != c.status ? void(e && e(!1)) : void(e && e(c.responseText)) : void 0
            }, d ? (c.open("POST", a, !0), c.setRequestHeader("Content-type", "application/x-www-form-urlencoded")) : c.open("GET", a, !0), c.setRequestHeader("X-Requested-With", "XMLHttpRequest"), c.send(d)
        }, e.prototype.getAssetUrl = function(a, b, c) {
            var d = this,
                e = JSON.stringify({
                    token: d.mToken,
                    platform: "H5_DIY",
                    info: [{
                        id: a,
                        ver: "1.0",
                        type: "dir"
                    }]
                }),
                f = {
                    post: e,
                    callback: function(a) {
                        if (a) {
                            var b = JSON.parse(a)[0];
                            if (b) {
                                var d = (b.id, b.url);
                                c && c(d)
                            } else console.error("....")
                        }
                    },
                    timeout: 60
                };
            this._sentDataToServer(this.mAssetUrl, f)
        }, e.prototype.getShare = function(a, c) {
            var d = JSON.stringify({
                    platform: "H5_DIY",
                    id: b(a)
                }),
                e = {
                    post: d,
                    callback: function(a) {
                        if (a) {
                            var b = JSON.parse(a);
                            if (b) {
                                var d = b.asset.url;
                                c && c(d)
                            } else console.error("....")
                        }
                    },
                    timeout: 60
                };
            this._sentDataToServer(this.mShareUrl, e)
        }, e.prototype.send_commant = function(a) {
            var b = JSON.stringify({
                    cv: 9,
                    dj: a
                }),
                c = {
                    get: b,
                    timeout: 60
                };
            this._sent_data_to_server(this.mCellUrl, c)
        };
        var f = new e;
        a.Service = f, a.onCommand = c
    }(window);
var Service, e3d = e3d || {},
    TVC_NONE = 0,
    TVC_AMBIENT = 1,
    TVC_DIFFUSE = 2,
    TVC_SPECULAR = 4,
    TVC_EMISSIVE = 8,
    SM_DIRECTION = 0,
    SM_DISTANCE = 1,
    FBT_COLOUR = 1,
    FBT_DEPTH = 2,
    FBT_STENCIL = 4,
    CMPF_ALWAYS_FAIL = 0,
    CMPF_ALWAYS_PASS = 1,
    CMPF_LESS = 2,
    CMPF_LESS_EQUAL = 3,
    CMPF_EQUAL = 4,
    CMPF_NOT_EQUAL = 5,
    CMPF_GREATER_EQUAL = 6,
    CMPF_GREATER = 7,
    TFO_NONE = 0,
    TFO_BILINEAR = 1,
    TFO_TRILINEAR = 2,
    TFO_ANISOTROPIC = 3,
    FT_MIN = 0,
    FT_MAG = 1,
    FT_MIP = 2,
    NEAREST = 3,
    LINEAR = 4,
    FO_NONE = 0,
    FO_POINT = 1,
    FO_LINEAR = 2,
    FO_ANISOTROPIC = 3,
    SO_FLAT = 0,
    SO_GOURAUD = 1,
    SO_PHONG = 2,
    FOG_NONE = 0,
    FOG_EXP = 1,
    FOG_EXP2 = 2,
    FOG_LINEAR = 3,
    CULL_NONE = 1,
    CULL_CLOCKWISE = 2,
    CULL_ANTICLOCKWISE = 3,
    MANUAL_CULL_NONE = 1,
    MANUAL_CULL_BACK = 2,
    MANUAL_CULL_FRONT = 3,
    WFT_SINE = 0,
    WFT_TRIANGLE = 1,
    WFT_SQUARE = 2,
    WFT_SAWTOOTH = 3,
    WFT_INVERSE_SAWTOOTH = 4,
    WFT_PWM = 5,
    PM_POINTS = 1,
    PM_WIREFRAME = 2,
    PM_SOLID = 3,
    E3D_MAX_SIMULTANEOUS_LIGHTS = 8,
    E3D_MAX_TEXTURE_COORD_SETS = 6,
    E3D_MAX_TEXTURE_LAYERS = 16,
    E3D_MAX_MULTIPLE_RENDER_TARGETS = 8,
    TYPE_NULL = 0,
    TYPE_DIMENSION = 5,
    TYPE_FRACTION = 6,
    E3D_PACKAGENAME = 100,
    E3D_LOCALE = 150,
    E3D_VERSION = 200,
    E3D_CHANNEL = 250,
    E3D_POWERSAVING = 300,
    E3D_BATTERYLEVEL = 350,
    E3D_SETASSETPACKAGENAME = 400,
    E3D_MUTEALLAUDIOS = 450,
    E3D_DISMUTEALLAUDIOS = 500,
    E3D_SETAPPCACHEDIR = 550,
    TOP_LEFT = 0,
    BOTTOM_LEFT = 1,
    TOP_RIGHT = 2,
    BOTTOM_RIGHT = 3,
    CENTER = 4,
    TOP_CENTER = 5,
    CUSTOMIZE = 6,
    Vector3Radius = function() {
        this.center = new Vector3(0, 0, 0), this.lt = new Vector3(0, 0, 0), this.width = 0, this.height = 0, this.rt = new Vector3, this.lb = new Vector3, this.rb = new Vector3, this.mousex = 0, this.mousey = 0, this.action = -1, this.id = -1, this.p = null
    };
Vector3Radius.prototype.getAsString = function() {};
var MotionEvent = function(a, b) {
    this.x = a || 0, this.y = b || 0, this.action = 0, this.id = 0
};
MotionEvent.prototype = {
    constructor: MotionEvent,
    set: function(a, b, c, d) {
        2 == arguments.length ? (this.x = arguments[0], this.y = arguments[1]) : 4 == arguments.length && (this.action = a, this.id = b, this.x = c, this.y = d)
    }
};
var LayoutMode = {
        NONE: 0,
        SHORTSIDE_OLD: 1,
        STRETCH_OLD: 2,
        LONGSIDE_OLD: 3,
        SHORTSIDE: 4,
        STRETCH: 5,
        LONGSIDE: 6
    },
    EVENT_DRAG = 1,
    EVENT_SCALE = 2,
    EVENT_ROTATE = 4;
e3d.E3D_MAX_SIMULTANEOUS_LIGHTS = 8, e3d.ENGINE_MODE = {}, e3d.ENGINE_MODE.NORMAL = 0, e3d.ENGINE_MODE.EDIT_2D = 1, e3d.TOUCH_DOWN = 0, e3d.TOUCH_UP = 1, e3d.TOUCH_MOVE = 2, e3d.TOUCH_CANCEL = 3, e3d._cp = function(a) {
    e3d._drowssap_sea = CryptoJS.enc.Utf8.stringify(CryptoJS.AES.decrypt(e3d._drowssap_sea, CryptoJS.enc.Utf8.stringify(CryptoJS.AES.decrypt(a.substr(0, 9) + "188mdogn9ybShrFT4dm+jz8+T/2S67hgRgHZn2gHETkJ3GVMcVGN6L/", a.substr(parseInt(a.substr(25, 1)), 16), {
        mode: CryptoJS.mode.ECB
    })).toString())).toString()
}, e3d.trim = function(a) {
    return a.replace(/(^\s*)|(\s*$)/g, "")
}, e3d.trim0 = function(a) {
    if (null == a) return a;
    var b = a.charCodeAt(a.length - 1);
    return 0 === b ? a.substr(0, a.length - 1) : a
}, e3d.isUrl = function(a) {
    var b = /^http(s)?:/gi,
        c = a.match(b);
    return null != c ? !0 : !1
}, e3d.genRandUint = function(a, b) {
    return a > b ? Math.random() * (b - a) + a : Math.random() * (a - b) + b
}, e3d.arrayBufferToBase64 = function(a) {
    for (var b = "", c = new Uint8Array(a), d = c.byteLength, e = 0; d > e; e++) b += String.fromCharCode(c[e]);
    return window.btoa(b)
}, e3d._drowssap_sea = "U2FsdGVkX1+v/dGB5pTShmGd98L+SNpPs0XzY/DU/QH+PxQw3Zv9ned7l+Z3BU0b";
var log = function(a) {
    console.log(a)
};
e3d.searchPaths = [], e3d.addSearchPath = function(a) {
    e3d.searchPaths.push(a)
}, e3d.clearSearchPath = function() {
    e3d.searchPaths = []
};
var require = function(a) {
    e3d.require(a)
};
e3d.requireList = [], e3d.requirePath = "", e3d._requiredCounter = 0, e3d.require = function(a) {
    e3d.requireList.push(a)
}, e3d.resetRequireList = function() {
    e3d._requiredCounter = 0, e3d.requireList = [], e3d.requirePath = ""
}, e3d._runRequiredJS = function(a, b, c) {
    var d = document.getElementsByTagName("head").item(0),
        e = document.createElement("script");
    e.type = "text/javascript", e.onload = e.onreadystatechange = function() {
        e3d._requiredCounter++, e3d._requiredCounter == e3d.requireList.length && (e.onload = e.onreadystatechange = null, e3d.resetRequireList(), c && c(), e.parentNode.removeChild(e))
    }, e.onerror = function() {
        return "number" == typeof a ? a++ : a = 0, a > e3d.searchPaths.length - 1 ? void console.info("Cannot find script", b) : void e3d._runRequiredJS(a, b, c)
    }, "string" == typeof a ? "imageConfig.js" == b && e3d.sharedPath ? e.src = e3d.sharedPath + b : e.src = a + "/" + b : e.src = e3d.searchPaths[a] + "/" + b, d.appendChild(e)
}, e3d.runRequireList = function(a) {
    if (e3d._requiredCounter = 0, e3d.requireList.length > 0)
        for (var b = 0; b < e3d.requireList.length; b++) e3d._runRequiredJS(e3d.requirePath, e3d.requireList[b], a);
    else e3d.resetRequireList(), a && a()
};
var Vector2 = function(a, b) {
    this.x = a || 0, this.y = b || 0
};
Vector2.prototype = {
    constructor: Vector2,
    set: function(a, b) {
        return a instanceof Array ? (this.x = a[0] || this.x, this.y = a[1] || this.y) : (this.x = a || this.x, this.y = b || this.y), this
    },
    setX: function(a) {
        return this.x = a, this
    },
    getX: function() {
        return this.x
    },
    setY: function(a) {
        return this.y = a, this
    },
    getY: function() {
        return this.y
    },
    add: function(a) {
        if (a instanceof Vector2) return new Vector2(this.x + a.x, this.y + a.y);
        if ("number" == typeof a) return new Vector2(this.x + a, this.y + a);
        throw new Error("Type error:" + typeof a)
    },
    add2: function(a, b) {
        return this.set(a.x + b.x, a.y + b.y)
    },
    sub: function(a) {
        if (a instanceof Vector2) return new Vector2(this.x - a.x, this.y - a.y);
        if ("number" == typeof a) return new Vector2(this.x - a, this.y - a);
        throw new Error("Type error:" + typeof a)
    },
    sub2: function(a, b) {
        return this.set(a.x - b.x, a.y - b.y)
    },
    mul: function(a) {
        if (a instanceof Vector2) return new Vector2(this.x * a.x, this.y * a.y);
        if ("number" == typeof a) return new Vector2(this.x * a, this.y * a);
        throw new Error("Type error:" + typeof a)
    },
    mul2: function(a, b) {
        return this.set(a.x * b.x, a.y * b.y)
    },
    div: function(a) {
        if (a instanceof Vector2) return new Vector2(this.x / a.x, this.y / a.y);
        if ("number" == typeof a) return new Vector2(this.x / a, this.y / a);
        throw new Error("Type error:" + typeof a)
    },
    div2: function(a, b) {
        return this.set(a.x / b.x, a.y / b.y)
    },
    copy: function(a) {
        if (a instanceof Vector2) return this.x = a.x, this.y = a.y, this;
        if ("number" == typeof a) return this.x = a, this.y = a, this;
        throw new Error("Type error:" + typeof a)
    },
    clone: function() {
        return new Vector2(this.x, this.y)
    },
    negate: function() {
        return this.x *= -1, this.y *= -1, this
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    },
    distanceSq: function(a) {
        var b = this.x - a.x,
            c = this.y - a.y;
        return b * b + c * c
    },
    distance: function(a) {
        var b = this.x - a.x,
            c = this.y - a.y;
        return Math.sqrt(b * b + c * c)
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y
    },
    midPoint: function(a) {
        return new Vector2(.5 * (this.x + a.x), .5 * (this.y + a.y))
    },
    equals: function(a) {
        return this.x == a.x && this.y == a.y
    },
    smallThan: function(a) {
        return this.x < a.x && this.y < a.y ? !0 : !1
    },
    bigThan: function(a) {
        return this.x > a.x && this.y > a.y ? !0 : !1
    },
    floor: function(a) {
        return a ? (a.x < this.x && (this.x = a.x), a.y < this.y && (this.y = a.y)) : (this.x = Math.floor(this.x), this.y = Math.floor(this.y)), this
    },
    ceil: function(a) {
        return a ? (a.x > this.x && (this.x = a.x), a.y > this.y && (this.y = a.y)) : (this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)), this
    },
    perpendicular: function() {
        return new Vector2(-this.y, this.x)
    },
    cross: function(a) {
        var b = this.x * a.y - this.y * a.x;
        return new Vector3(0, 0, b)
    },
    lengthZero: function() {
        var a = this.lengthSq(),
            b = 1e-6;
        return b * b > a
    },
    normalise: function() {
        var a = Math.sqrt(this.x * this.x + this.y * this.y);
        if (a > 1e-8) {
            var b = 1 / a;
            this.x *= b, this.y *= b, this.z *= b
        }
        return a
    },
    normalisedCopy: function() {
        var a = new Vector2;
        return a.copy(this), a.normalise(), a
    },
    reflect: function(a) {
        var b = this.x * a.x + this.y * a.y;
        return b *= 2, a.x *= b, a.y *= b, new Vector2(this.sub(a))
    }
}, Vector2.ZERO = new Vector2(0, 0), Vector2.UNIT_X = new Vector2(1, 0), Vector2.UNIT_Y = new Vector2(0, 1), Vector2.NEGATIVE_UNIT_X = new Vector2(-1, 0), Vector2.NEGATIVE_UNIT_Y = new Vector2(0, -1), Vector2.UNIT_SCALE = new Vector2(1, 1);
var Vector3 = function(a, b, c) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0
};
Vector3.prototype = {
    constructor: Vector3,
    set: function(a, b, c) {
        return a instanceof Array ? (this.x = a[0] || this.x, this.y = a[1] || this.y, this.z = a[2] || this.z) : (this.x = a, this.y = b, this.z = c), this
    },
    setX: function(a) {
        return this.x = a, this
    },
    getX: function() {
        return this.x
    },
    setY: function(a) {
        return this.y = a, this
    },
    getY: function() {
        return this.y
    },
    setZ: function(a) {
        return this.z = a, this
    },
    getZ: function() {
        return this.z
    },
    add: function(a) {
        var b = void 0 !== a.x ? a.x : a,
            c = void 0 !== a.y ? a.y : a,
            d = void 0 !== a.z ? a.z : a;
        return new Vector3(this.x + b, this.y + c, this.z + d)
    },
    add2: function(a, b) {
        return this.set(a.x + b.x, a.y + b.y, a.z + b.z)
    },
    sub: function(a) {
        var b = void 0 !== a.x ? a.x : a,
            c = void 0 !== a.y ? a.y : a,
            d = void 0 !== a.z ? a.z : a;
        return new Vector3(this.x - b, this.y - c, this.z - d)
    },
    sub2: function(a, b) {
        return this.set(a.x - b.x, a.y - b.y, a.z - b.z)
    },
    multiply: function(a) {
        var b = void 0 !== a.x ? a.x : a,
            c = void 0 !== a.y ? a.y : a,
            d = void 0 !== a.z ? a.z : a;
        return new Vector3(this.x * b, this.y * c, this.z * d)
    },
    mul2: function(a, b) {
        return this.set(a.x * b.x, a.y * b.y, a.z * b.z)
    },
    div: function(a) {
        var b = void 0 !== a.x ? a.x : a,
            c = void 0 !== a.y ? a.y : a,
            d = void 0 !== a.z ? a.z : a;
        return new Vector3(this.x / b, this.y / c, this.z / d)
    },
    div2: function(a, b) {
        return this.set(a.x / b.x, a.y / b.y, a.z / b.z)
    },
    copy: function(a) {
        return this.x = void 0 !== a.x ? a.x : a, this.y = void 0 !== a.y ? a.y : a, this.z = void 0 !== a.z ? a.z : a, this
    },
    clone: function() {
        return new Vector3(this.x, this.y, this.z)
    },
    negate: function() {
        return this.multiply(-1)
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    },
    distanceSq: function(a) {
        var b = this.x - a.x,
            c = this.y - a.y,
            d = this.z - a.z;
        return b * b + c * c + d * d
    },
    distance: function(a) {
        var b = this.x - a.x,
            c = this.y - a.y,
            d = this.z - a.z;
        return Math.sqrt(b * b + c * c + d * d)
    },
    directionEquals: function(a, b) {
        var c = this.dot(a),
            d = Math.acos(c);
        return Math.abs(d) <= b
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z
    },
    midPoint: function(a) {
        return new Vector3(.5 * (this.x + a.x), .5 * (this.y + a.y), .5 * (this.z + a.z))
    },
    equals: function(a) {
        return this.x == a.x && this.y == a.y && this.z == a.z
    },
    notEquals: function(a) {
        return !this.equals(a)
    },
    smallThan: function(a) {
        return this.x < a.x && this.y < a.y && this.z < a.z ? !0 : !1
    },
    bigThan: function(a) {
        return this.x > a.x && this.y > a.y && this.z > a.z ? !0 : !1
    },
    floor: function(a) {
        return a ? (a.x < this.x && (this.x = a.x), a.y < this.y && (this.y = a.y), a.z < this.z && (this.z = a.z)) : (this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z)), this
    },
    ceil: function(a) {
        return a ? (a.x > this.x && (this.x = a.x), a.y > this.y && (this.y = a.y), a.z > this.z && (this.z = a.z)) : (this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z)), this
    },
    perpendicular: function(a) {
        var b = this.cross(new Vector3(1, 0, 0));
        return b.lengthSq() < 1e-6 && (b = this.cross(new Vector3(0, 1, 0))), b.normalise(), b
    },
    cross: function(a) {
        var b = a.x,
            c = a.y,
            d = a.z,
            e = this.x,
            f = this.y,
            g = this.z;
        return new Vector3(f * d - g * c, g * b - e * d, e * c - f * b)
    },
    isZeroLength: function() {
        return this.lengthZero()
    },
    lengthZero: function() {
        var a = this.lengthSq(),
            b = 1e-6;
        return b * b > a
    },
    normalise: function() {
        var a = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        if (a > 1e-8) {
            var b = 1 / a;
            this.x *= b, this.y *= b, this.z *= b
        }
        return a
    },
    normalisedCopy: function() {
        var a = new Vector3;
        return a.copy(this), a.normalise(), a
    },
    reflect: function(a) {
        return new Vector3(this.sub(2 * this.dot(a) * a))
    },
    randomDeviant: function(a, b) {
        var c = new Vector3;
        b = void 0 !== b ? b : new Vector3(0, 0, 0), b.equals(new Vector3(0, 0, 0)) ? c.copy(this.perpendicular()) : c.copy(b);
        var d = new Quaternion;
        return d.setFromAngleAxis(Math.TWO_PI * Math.random(), this), c.copy(d.multiply(c)), d.setFromAngleAxis(a, c), d.multiply(this)
    },
    angleBetween: function(a) {
        var b = this.length() * a.length();
        1e-6 > b && (b = 1e-6);
        var c = this.dot(a) / b;
        return c = Math.clamp(c, -1, 1), Math.acos(c)
    }
}, Vector3.ZERO = new Vector3(0, 0, 0), Vector3.UNIT_X = new Vector3(1, 0, 0), Vector3.UNIT_Y = new Vector3(0, 1, 0), Vector3.UNIT_Z = new Vector3(0, 0, 1), Vector3.NEGATIVE_UNIT_X = new Vector3(-1, 0, 0), Vector3.NEGATIVE_UNIT_Y = new Vector3(0, -1, 0), Vector3.NEGATIVE_UNIT_Z = new Vector3(0, 0, -1), Vector3.UNIT_SCALE = new Vector3(1, 1, 1);
var Vector4 = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = void 0 !== d ? d : 1
};
Vector4.prototype = {
    constructor: Vector4,
    set: function(a, b, c, d) {
        return a instanceof Array ? (this.x = a[0] || this.x, this.y = a[1] || this.y, this.z = a[2] || this.z, this.w = a[3] || this.w) : (this.x = a || this.x, this.y = b || this.y, this.z = c || this.z, this.w = d || this.w), this
    },
    setX: function(a) {
        return this.x = a, this
    },
    getX: function() {
        return this.x
    },
    setY: function(a) {
        return this.y = a, this
    },
    getY: function() {
        return this.y
    },
    setZ: function(a) {
        return this.z = a, this
    },
    getZ: function() {
        return this.z
    },
    setW: function(a) {
        return this.w = a, this
    },
    getW: function() {
        return this.w
    },
    add: function(a) {
        if (a instanceof Vector4) return new Vector4(this.x + a.x, this.y + a.y, this.z + a.z, this.w + a.w);
        if ("number" == typeof a) return new Vector4(this.x + a, this.y + a, this.z + a, this.w + a);
        throw new Error("Type error:" + typeof a)
    },
    sub: function(a) {
        if (a instanceof Vector4) return new Vector4(this.x - a.x, this.y - a.y, this.z - a.z, this.w - a.w);
        if ("number" == typeof a) return new Vector4(this.x - a, this.y - a, this.z - a, this.w - a);
        throw new Error("Type error:" + typeof a)
    },
    multiply: function(a) {
        if (a instanceof Vector4) return new Vector4(this.x * a.x, this.y * a.y, this.z * a.z, this.w * a.w);
        if (a instanceof Matrix4) return new Vector4(this.x * a.m[0] + this.y * a.m[4] + this.z * a.m[8] + this.w * a.m[12], this.x * a.m[1] + this.y * a.m[5] + this.z * a.m[9] + this.w * a.m[13], this.x * a.m[2] + this.y * a.m[6] + this.z * a.m[10] + this.w * a.m[14], this.x * a.m[3] + this.y * a.m[7] + this.z * a.m[11] + this.w * a.m[15]);
        if ("number" == typeof a) return new Vector4(this.x * a, this.y * a, this.z * a, this.w * a);
        throw new Error("Type error:" + typeof a)
    },
    div: function(a) {
        if (a instanceof Vector4) return new Vector4(this.x / a.x, this.y / a.y, this.z / a.z, this.w / a.w);
        if ("number" == typeof a) return new Vector4(this.x / a, this.y / a, this.z / a, this.w / a);
        throw new Error("Type error:" + typeof a)
    },
    copy: function(a) {
        if (a instanceof Vector4) this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w;
        else {
            if ("number" != typeof a) throw new Error("Type error:", typeof a);
            this.x = a, this.y = a, this.z = a, this.w = a
        }
        return this
    },
    clone: function() {
        return new Vector4(this.x, this.y, this.z, this.w)
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
    },
    equals: function(a) {
        return this.x == a.x && this.y == a.y && this.z == a.z && this.w == a.w
    },
    negate: function() {
        return this.mul(-1)
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    },
    distanceSq: function(a) {
        var b = this.x - a.x,
            c = this.y - a.y,
            d = this.z - a.z,
            e = this.w - a.w;
        return b * b + c * c + d * d + e * e
    },
    distance: function(a) {
        var b = this.x - a.x,
            c = this.y - a.y,
            d = this.z - a.z,
            e = this.w - a.w;
        return Math.sqrt(b * b + c * c + d * d + e * e)
    },
    midPoint: function(a) {
        return new Vector4(.5 * (this.x + a.x), .5 * (this.y + a.y), .5 * (this.z + a.z), .5 * (this.w + a.w))
    },
    smallThan: function(a) {
        return this.x < a.x && this.y < a.y && this.z < a.z && this.w < a.w ? !0 : !1
    },
    bigThan: function(a) {
        return this.x > a.x && this.y > a.y && this.z > a.z && this.w > a.w ? !0 : !1
    },
    floor: function(a) {
        return a ? (a.x < this.x && (this.x = a.x), a.y < this.y && (this.y = a.y), a.z < this.z && (this.z = a.z), a.w < this.w && (this.w = a.w)) : (this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w)), this
    },
    ceil: function(a) {
        return a ? (a.x > this.x && (this.x = a.x), a.y > this.y && (this.y = a.y), a.z > this.z && (this.z = a.z), a.w > this.w && (this.w = a.w)) : (this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w)), this
    },
    lengthZero: function() {
        var a = this.lengthSq(),
            b = 1e-6;
        return b * b > a
    },
    normalise: function() {
        var a = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        return this.div(a)
    },
    reflect: function(a) {
        return new Vector4(this.sub(2 * this.dot(a) * a))
    }
}, Vector4.ZERO = new Vector4(0, 0, 0, 0);
var Matrix3 = function(a, b, c, d, e, f, g, h, i) {
    this.m = new Float32Array(9);
    var j = this.m;
    j[0] = void 0 !== a ? a : 1, j[1] = b || 0, j[2] = c || 0, j[3] = d || 0, j[4] = void 0 !== e ? e : 1, j[5] = f || 0, j[6] = g || 0, j[7] = h || 0, j[8] = void 0 !== i ? i : 1
};
Matrix3.prototype = {
    constructor: Matrix3,
    add: function(a) {
        for (var b = new Matrix3, c = 0; 9 > c; c++) b.m[c] = this.m[c] + a.m[c];
        return b
    },
    sub: function(a) {
        for (var b = new Matrix3, c = 0; 9 > c; c++) b.m[c] = this.m[c] - a.m[c];
        return b
    },
    multiply: function(a) {
        var b = this.m,
            c = a.m,
            d = a.x,
            e = a.y,
            f = a.z;
        if (void 0 !== a.m) {
            var g = new Matrix3,
                h = g.m;
            return h[0] = c[0] * b[0] + c[3] * b[1] + c[6] * b[2], h[1] = c[1] * b[0] + c[4] * b[1] + c[7] * b[2], h[2] = c[2] * b[0] + c[5] * b[1] + c[8] * b[2], h[3] = c[0] * b[3] + c[3] * b[4] + c[6] * b[5], h[4] = c[1] * b[3] + c[4] * b[4] + c[7] * b[5], h[5] = c[2] * b[3] + c[5] * b[4] + c[8] * b[5], h[6] = c[0] * b[6] + c[3] * b[7] + c[6] * b[8], h[7] = c[1] * b[6] + c[4] * b[7] + c[7] * b[8], h[8] = c[2] * b[6] + c[5] * b[7] + c[8] * b[8], g
        }
        if (void 0 !== d) {
            var i = new Vector3;
            return i.x = b[0] * d + b[1] * e + b[2] * f, i.y = b[3] * d + b[4] * e + b[5] * f,
                i.z = b[6] * d + b[7] * e + b[8] * f, i
        }
        if ("number" == typeof a) {
            for (var g = new Matrix3, j = 8; j >= 0; j--) g.m[j] = b[j] * a;
            return g
        }
        throw new Error("Type error:" + typeof a)
    },
    setFromMatrix: function(a) {
        var b = a.m,
            c = this.m;
        return c[0] = b[0], c[1] = b[1], c[2] = b[2], c[3] = b[4], c[4] = b[5], c[5] = b[6], c[6] = b[8], c[7] = b[9], c[8] = b[10], this
    },
    setFromEuler: function(a) {
        if (a instanceof Euler == !1) throw new Error("Type error:" + typeof a);
        var b = this.m,
            c = a.x,
            d = a.y,
            e = a.z,
            f = Math.cos(c),
            g = Math.sin(c),
            h = Math.cos(d),
            i = Math.sin(d),
            j = Math.cos(e),
            k = Math.sin(e);
        if ("XYZ" === a.order) {
            var l = f * j,
                m = f * k,
                n = g * j,
                o = g * k;
            b[0] = h * j, b[4] = -h * k, b[8] = i, b[1] = m + n * i, b[5] = l - o * i, b[9] = -g * h, b[2] = o - l * i, b[6] = n + m * i, b[10] = f * h
        } else if ("YXZ" === a.order) {
            var p = h * j,
                q = h * k,
                r = i * j,
                s = i * k;
            b[0] = p + s * g, b[3] = r * g - q, b[6] = f * i, b[1] = f * k, b[4] = f * j, b[7] = -g, b[2] = q * g - r, b[5] = s + p * g, b[8] = f * h
        } else if ("ZXY" === a.order) {
            var p = h * j,
                q = h * k,
                r = i * j,
                s = i * k;
            b[0] = p - s * g, b[3] = -f * k, b[6] = r + q * g, b[1] = q + r * g, b[4] = f * j, b[7] = s - p * g, b[2] = -f * i, b[5] = g, b[8] = f * h
        } else if ("ZYX" === a.order) {
            var l = f * j,
                m = f * k,
                n = g * j,
                o = g * k;
            b[0] = h * j, b[3] = n * i - m, b[6] = l * i + o, b[1] = h * k, b[4] = o * i + l, b[7] = m * i - n, b[2] = -i, b[5] = g * h, b[8] = f * h
        } else if ("YZX" === a.order) {
            var t = f * h,
                u = f * i,
                v = g * h,
                w = g * i;
            b[0] = h * j, b[3] = w - t * k, b[6] = v * k + u, b[1] = k, b[4] = f * j, b[7] = -g * j, b[2] = -i * j, b[5] = u * k + v, b[8] = t - w * k
        } else if ("XZY" === a.order) {
            var t = f * h,
                u = f * i,
                v = g * h,
                w = g * i;
            b[0] = h * j, b[3] = -k, b[6] = i * j, b[1] = t * k + w, b[4] = f * j, b[7] = u * k - v, b[2] = v * k - u, b[5] = g * j, b[8] = w * k + t
        }
        return this
    },
    setFromQuaternion: function(a) {
        var b = this.m,
            c = a.x + a.x,
            d = a.y + a.y,
            e = a.z + a.z,
            f = c * a.w,
            g = d * a.w,
            h = e * a.w,
            i = c * a.x,
            j = d * a.x,
            k = e * a.x,
            l = d * a.y,
            m = e * a.y,
            n = e * a.z;
        return b[0] = 1 - (l + n), b[1] = j - h, b[2] = k + g, b[3] = j + h, b[4] = 1 - (i + n), b[5] = m - f, b[6] = k - g, b[7] = m + f, b[8] = 1 - (i + l), this
    },
    copy: function(a) {
        var b = a.m,
            c = this.m;
        return c[0] = b[0], c[1] = b[1], c[2] = b[2], c[3] = b[3], c[4] = b[4], c[5] = b[5], c[6] = b[6], c[7] = b[7], c[8] = b[8], this
    },
    FromAxisAngle: function(a, b) {
        var c = Math.cos(b),
            d = Math.sin(b),
            e = 1 - c,
            f = a.x * a.x,
            g = a.y * a.y,
            h = a.z * a.z,
            i = a.x * a.y * e,
            j = a.x * a.z * e,
            k = a.y * a.z * e,
            l = a.x * d,
            m = a.y * d,
            n = a.z * d,
            o = this.m;
        return o[0] = f * e + c, o[1] = i - n, o[2] = j + m, o[3] = i + n, o[4] = g * e + c, o[5] = k - l, o[6] = j - m, o[7] = k + l, o[8] = h * e + c, this
    },
    transpose: function() {
        var a, b = this.m;
        return a = b[1], b[1] = b[3], b[3] = a, a = b[2], b[2] = b[6], b[6] = a, a = b[5], b[5] = b[7], b[7] = a, this
    },
    determinant: function() {
        var a = this.m,
            b = a[4] * a[8] - a[5] * a[7],
            c = a[5] * a[6] - a[3] * a[8],
            d = a[3] * a[7] - a[4] * a[6],
            e = a[0] * b + a[1] * c + a[2] * d;
        return e
    },
    inverse: function(a) {
        a = void 0 !== a ? a : new Matrix3;
        var b = this.m,
            c = a.m;
        c[0] = b[4] * b[8] - b[5] * b[7], c[1] = b[2] * b[7] - b[1] * b[8], c[2] = b[1] * b[5] - b[2] * b[4], c[3] = b[5] * b[6] - b[3] * b[8], c[4] = b[0] * b[8] - b[2] * b[6], c[5] = b[2] * b[3] - b[0] * b[5], c[6] = b[3] * b[7] - b[4] * b[6], c[7] = b[1] * b[6] - b[0] * b[7], c[8] = b[0] * b[4] - b[1] * b[3];
        for (var d = b[0] * c[0] + b[1] * c[3] + b[2] * c[6], e = 1 / d, f = 0; 9 > f; f++) c[f] *= e;
        return a
    }
}, Matrix3.ZERO = new Matrix3(0, 0, 0, 0, 0, 0, 0, 0, 0), Matrix3.IDENTITY = new Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);
var Matrix4 = function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
    this.m = new Float32Array(16);
    var q = this.m;
    q[0] = void 0 !== a ? a : 1, q[1] = b || 0, q[2] = c || 0, q[3] = d || 0, q[4] = e || 0, q[5] = void 0 !== f ? f : 1, q[6] = g || 0, q[7] = h || 0, q[8] = i || 0, q[9] = j || 0, q[10] = void 0 !== k ? k : 1, q[11] = l || 0, q[12] = m || 0, q[13] = n || 0, q[14] = o || 0, q[15] = void 0 !== p ? p : 1
};
Matrix4.prototype = {
    constructor: Matrix4,
    add: function(a) {
        var b = new Matrix4,
            c = this.m,
            d = a.m,
            e = b.m;
        return e[0] = c[0] + d[0], e[1] = c[1] + d[1], e[2] = c[2] + d[2], e[3] = c[3] + d[3], e[4] = c[4] + d[4], e[5] = c[5] + d[5], e[6] = c[6] + d[6], e[7] = c[7] + d[7], e[8] = c[8] + d[8], e[9] = c[9] + d[9], e[10] = c[10] + d[10], e[11] = c[11] + d[11], e[12] = c[12] + d[12], e[13] = c[13] + d[13], e[14] = c[14] + d[14], e[15] = c[15] + d[15], b
    },
    sub: function(a) {
        var b = new Matrix4,
            c = b.m,
            d = this.m,
            e = a.m;
        return c[0] = d[0] - e[0], c[1] = d[1] - e[1], c[2] = d[2] - e[2], c[3] = d[3] - e[3], c[4] = d[4] - e[4], c[5] = d[5] - e[5], c[6] = d[6] - e[6], c[7] = d[7] - e[7], c[8] = d[8] - e[8], c[9] = d[9] - e[9], c[10] = d[10] - e[10], c[11] = d[11] - e[11], c[12] = d[12] - e[12], c[13] = d[13] - e[13], c[14] = d[14] - e[14], c[15] = d[15] - e[15], b
    },
    multiply: function(a) {
        var b = this.m;
        if (a instanceof Matrix4) return this.concatenate(a);
        if (a instanceof Vector3) {
            var c = new Vector3,
                d = 1 / (b[12] * a.x + b[13] * a.y + b[14] * a.z + b[15]);
            return c.x = (b[0] * a.x + b[1] * a.y + b[2] * a.z + b[3]) * d, c.y = (b[4] * a.x + b[5] * a.y + b[6] * a.z + b[7]) * d, c.z = (b[8] * a.x + b[9] * a.y + b[10] * a.z + b[11]) * d, c
        }
        if (a instanceof Vector4) return new Vector4(b[0] * a.x + b[1] * a.y + b[2] * a.z + b[3] * a.w, b[4] * a.x + b[5] * a.y + b[6] * a.z + b[7] * a.w, b[8] * a.x + b[9] * a.y + b[10] * a.z + b[11] * a.w, b[12] * a.x + b[13] * a.y + b[14] * a.z + b[15] * a.w);
        if ("number" == typeof a) return new Matrix4(b[0] * a, b[1] * a, b[2] * a, b[3] * a, b[4] * a, b[5] * a, b[6] * a, b[7] * a, b[8] * a, b[9] * a, b[10] * a, b[11] * a, b[12] * a, b[13] * a, b[14] * a, b[15] * a);
        throw new Error("Type Error:" + typeof a)
    },
    set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        var q = this.m;
        q[0] = void 0 !== a ? a : 1, q[4] = b || 0, q[8] = c || 0, q[12] = d || 0, q[1] = e || 0, q[5] = void 0 !== f ? f : 1, q[9] = g || 0, q[13] = h || 0, q[2] = i || 0, q[6] = j || 0, q[10] = void 0 !== k ? k : 1, q[14] = l || 0, q[3] = m || 0, q[7] = n || 0, q[11] = o || 0, q[15] = void 0 !== p ? p : 1
    },
    setFromMatrix: function(a) {
        if (this.copy(Matrix4.IDENTITY), a instanceof Matrix4) this.copy(a);
        else if (a instanceof Matrix3) {
            var b = this.m;
            b[0] = a.m[0], b[1] = a.m[1], b[2] = a.m[2], b[4] = a.m[3], b[5] = a.m[4], b[6] = a.m[5], b[8] = a.m[6], b[9] = a.m[7], b[10] = a.m[8]
        }
        return this
    },
    setFromQuaternion: function(a) {
        var b = this.m,
            c = a.x,
            d = a.y,
            e = a.z,
            f = a.w,
            g = c + c,
            h = d + d,
            i = e + e,
            j = c * g,
            k = c * h,
            l = c * i,
            m = d * h,
            n = d * i,
            o = e * i,
            p = f * g,
            q = f * h,
            r = f * i;
        return b[0] = 1 - (m + o), b[4] = k - r, b[8] = l + q, b[1] = k + r, b[5] = 1 - (j + o), b[9] = n - p, b[2] = l - q, b[6] = n + p, b[10] = 1 - (j + m), b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
    },
    copy: function(a) {
        var b = this.m,
            c = a.m;
        return b[0] = c[0], b[1] = c[1], b[2] = c[2], b[3] = c[3], b[4] = c[4], b[5] = c[5], b[6] = c[6], b[7] = c[7], b[8] = c[8], b[9] = c[9], b[10] = c[10], b[11] = c[11], this
    },
    extract3x3Matrix: function() {
        var a = this.m,
            b = new Matrix3,
            c = b.m;
        return c[0] = a[0], c[1] = a[1], c[2] = a[2], c[3] = a[4], c[4] = a[5], c[5] = a[6], c[6] = a[8], c[7] = a[9], c[8] = a[10], b
    },
    ToRotationMatrix: function(a) {
        return a = this.extract3x3Matrix()
    },
    clone: function() {
        var a = new Matrix4;
        return a.m.set(this.m), a
    },
    transpose: function() {
        var a = this.m;
        return new Matrix4(a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15])
    },
    concatenate: function(a) {
        var b = new Matrix4,
            c = b.m,
            d = this.m,
            e = a.m;
        return c[0] = d[0] * e[0] + d[1] * e[4] + d[2] * e[8] + d[3] * e[12], c[1] = d[0] * e[1] + d[1] * e[5] + d[2] * e[9] + d[3] * e[13], c[2] = d[0] * e[2] + d[1] * e[6] + d[2] * e[10] + d[3] * e[14], c[3] = d[0] * e[3] + d[1] * e[7] + d[2] * e[11] + d[3] * e[15], c[4] = d[4] * e[0] + d[5] * e[4] + d[6] * e[8] + d[7] * e[12], c[5] = d[4] * e[1] + d[5] * e[5] + d[6] * e[9] + d[7] * e[13], c[6] = d[4] * e[2] + d[5] * e[6] + d[6] * e[10] + d[7] * e[14], c[7] = d[4] * e[3] + d[5] * e[7] + d[6] * e[11] + d[7] * e[15], c[8] = d[8] * e[0] + d[9] * e[4] + d[10] * e[8] + d[11] * e[12], c[9] = d[8] * e[1] + d[9] * e[5] + d[10] * e[9] + d[11] * e[13], c[10] = d[8] * e[2] + d[9] * e[6] + d[10] * e[10] + d[11] * e[14], c[11] = d[8] * e[3] + d[9] * e[7] + d[10] * e[11] + d[11] * e[15], c[12] = d[12] * e[0] + d[13] * e[4] + d[14] * e[8] + d[15] * e[12], c[13] = d[12] * e[1] + d[13] * e[5] + d[14] * e[9] + d[15] * e[13], c[14] = d[12] * e[2] + d[13] * e[6] + d[14] * e[10] + d[15] * e[14], c[15] = d[12] * e[3] + d[13] * e[7] + d[14] * e[11] + d[15] * e[15], b
    },
    isAffine: function() {
        var a = this.m;
        return 0 == a[12] && 0 == a[13] && 0 == a[14] && 1 == a[15]
    },
    concatenateAffine: function(a) {
        if (!this.isAffine()) throw new Error("concatenateAffine error");
        var b = a.m,
            c = this.m;
        return new Matrix4(c[0] * b[0] + c[1] * b[4] + c[2] * b[8] + c[3] * b[12], c[0] * b[1] + c[1] * b[5] + c[2] * b[9] + c[3] * b[13], c[0] * b[2] + c[1] * b[6] + c[2] * b[10] + c[3] * b[14], c[0] * b[3] + c[1] * b[7] + c[2] * b[11] + c[3] * b[15], c[4] * b[0] + c[5] * b[4] + c[6] * b[8] + c[7] * b[12], c[4] * b[1] + c[5] * b[5] + c[6] * b[9] + c[7] * b[13], c[4] * b[2] + c[5] * b[6] + c[6] * b[10] + c[7] * b[14], c[4] * b[3] + c[5] * b[7] + c[6] * b[11] + c[7] * b[15], c[8] * b[0] + c[9] * b[4] + c[10] * b[8] + c[11] * b[12], c[8] * b[0] + c[9] * b[4] + c[10] * b[8] + c[11] * b[12], c[8] * b[0] + c[9] * b[4] + c[10] * b[8] + c[11] * b[12], c[8] * b[0] + c[9] * b[4] + c[10] * b[8] + c[11] * b[12], 0, 0, 0, 1)
    },
    transformAffine: function(a) {
        if (!this.isAffine()) throw new Error("transformAffine error");
        return this.multiply(a)
    },
    inverseAffine: function() {
        var a = this.m[4],
            b = this.m[5],
            c = this.m[6],
            d = this.m[8],
            e = this.m[9],
            f = this.m[10],
            g = f * b - e * c,
            h = d * c - f * a,
            i = e * a - d * b,
            j = this.m[0],
            k = this.m[1],
            l = this.m[2],
            m = 1 / (j * g + k * h + l * i);
        g *= m, h *= m, i *= m, j *= m, k *= m, l *= m;
        var n = g,
            o = l * e - k * f,
            p = k * c - l * b,
            q = h,
            r = j * f - l * d,
            s = l * a - j * c,
            t = i,
            u = k * d - j * e,
            v = j * b - k * a,
            w = this.m[3],
            x = this.m[7],
            y = this.m[11],
            z = -(n * w + o * x + p * y),
            A = -(q * w + r * x + s * y),
            B = -(t * w + u * x + v * y);
        return new Matrix4(n, o, p, z, q, r, s, A, t, u, v, B, 0, 0, 0, 1)
    },
    adjoint: function() {
        return new Matrix4(Matrix4.MINOR(1, 2, 3, 1, 2, 3), -Matrix4.MINOR(0, 2, 3, 1, 2, 3), Matrix4.MINOR(0, 1, 3, 1, 2, 3), -Matrix4.MINOR(0, 1, 2, 1, 2, 3), -Matrix4.MINOR(1, 2, 3, 0, 2, 3), Matrix4.MINOR(0, 2, 3, 0, 2, 3), -Matrix4.MINOR(0, 1, 3, 0, 2, 3), Matrix4.MINOR(0, 1, 2, 0, 2, 3), Matrix4.MINOR(1, 2, 3, 0, 1, 3), -Matrix4.MINOR(0, 2, 3, 0, 1, 3), Matrix4.MINOR(0, 1, 3, 0, 1, 3), -Matrix4.MINOR(0, 1, 2, 0, 1, 3), -Matrix4.MINOR(1, 2, 3, 0, 1, 2), Matrix4.MINOR(0, 2, 3, 0, 1, 2), -Matrix4.MINOR(0, 1, 3, 0, 1, 2), Matrix4.MINOR(0, 1, 2, 0, 1, 2))
    },
    determinant: function() {
        return this.m[0] * Matrix4.MINOR(1, 2, 3, 1, 2, 3) - this.m[1] * Matrix4.MINOR(1, 2, 3, 0, 2, 3) + this.m[2] * Matrix4.MINOR(1, 2, 3, 0, 1, 3) - this.m[3] * Matrix4.MINOR(1, 2, 3, 0, 1, 2)
    },
    inverse: function() {
        var a = this.m,
            b = a[0],
            c = a[1],
            d = a[2],
            e = a[3],
            f = a[4],
            g = a[5],
            h = a[6],
            i = a[7],
            j = a[8],
            k = a[9],
            l = a[10],
            m = a[11],
            n = a[12],
            o = a[13],
            p = a[14],
            q = a[15],
            r = j * o - k * n,
            s = j * p - l * n,
            t = j * q - m * n,
            u = k * p - l * o,
            v = k * q - m * o,
            w = l * q - m * p,
            x = +(w * g - v * h + u * i),
            y = -(w * f - t * h + s * i),
            z = +(v * f - t * g + r * i),
            A = -(u * f - s * g + r * h),
            B = 1 / (x * b + y * c + z * d + A * e),
            C = x * B,
            D = y * B,
            E = z * B,
            F = A * B,
            G = -(w * c - v * d + u * e) * B,
            H = +(w * b - t * d + s * e) * B,
            I = -(v * b - t * c + r * e) * B,
            J = +(u * b - s * c + r * d) * B;
        r = f * o - g * n, s = f * p - h * n, t = f * q - i * n, u = g * p - h * o, v = g * q - i * o, w = h * q - i * p;
        var K = +(w * c - v * d + u * e) * B,
            L = -(w * b - t * d + s * e) * B,
            M = +(v * b - t * c + r * e) * B,
            N = -(u * b - s * c + r * d) * B;
        r = k * f - j * g, s = l * f - j * h, t = m * f - j * i, u = l * g - k * h, v = m * g - k * i, w = m * h - l * i;
        var O = -(w * c - v * d + u * e) * B,
            P = +(w * b - t * d + s * e) * B,
            Q = -(v * b - t * c + r * e) * B,
            R = +(u * b - s * c + r * d) * B;
        return new Matrix4(C, G, K, O, D, H, L, P, E, I, M, Q, F, J, N, R)
    },
    getPosition: function() {
        var a = new Vector3;
        return function() {
            var b = this.m;
            return a.set(b[12], b[13], b[14])
        }
    }(),
    setPosition: function(a) {
        this.m[3] = a.x, this.m[7] = a.y, this.m[11] = a.z
    },
    setTrans: function(a, b, c) {
        3 === arguments.length ? (this.m[3] = a, this.m[7] = b, this.m[11] = c) : (this.m[3] = a.x, this.m[7] = a.y, this.m[11] = a.z)
    },
    getTrans: function() {
        return new Vector3(this.m[3], this.m[7], this.m[11])
    },
    getScale: function() {
        var a = new Vector3;
        return a.x = this.m[0], a.y = this.m[5], a.z = this.m[10], a
    },
    setScale: function(a) {
        var b = this.m,
            c = a.x,
            d = a.y,
            e = a.z;
        return b[0] *= c, b[1] *= d, b[2] *= e, b[4] *= c, b[5] *= d, b[6] *= e, b[8] *= c, b[9] *= d, b[10] *= e, b[12] *= c, b[13] *= d, b[14] *= e, this
    },
    makeTransform: function(a, b, c) {
        var d = b.toMatrix3(),
            e = this.m,
            f = d.m;
        return e[0] = c.x * f[0], e[1] = c.y * f[1], e[2] = c.z * f[2], e[3] = a.x, e[4] = c.x * f[3], e[5] = c.y * f[4], e[6] = c.z * f[5], e[7] = a.y, e[8] = c.x * f[6], e[9] = c.y * f[7], e[10] = c.z * f[8], e[11] = a.z, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    },
    makeInverseTransform: function(a, b, c) {
        var d = -a,
            e = new Vector3(1 / c.x, 1 / c.y, 1 / c.z),
            f = b.inverse();
        d = f.multiply(d), d = d.multiply(e);
        var g = f.toMatrix3();
        return this.m[0] = e.x * g[0], this.m[1] = e.x * g[1], this.m[2] = e.x * g[2], this.m[3] = d.x, this.m[4] = e.y * g[3], this.m[5] = e.y * g[4], this.m[6] = e.y * g[5], this.m[7] = d.y, this.m[8] = e.z * g[6], this.m[9] = e.z * g[7], this.m[10] = e.z * g[8], this.m[11] = d.z, this.m[12] = 0, this.m[13] = 0, this.m[14] = 0, this.m[15] = 1, this
    }
}, Matrix4.MINOR = function(a, b, c, d, e, f) {
    var g = new Matrix4,
        h = g.m;
    return h[4 * a + d] * (h[4 * b + e] * h[4 * c + f] - h[4 * c + e] * h[4 * b + f]) - h[4 * a + e] * (h[4 * b + d] * h[4 * c + f] - h[4 * c + d] * h[4 * b + f]) + h[4 * a + f] * (h[4 * b + d] * h[4 * c + e] - h[4 * c + d] * h[4 * b + e])
}, Matrix4.ZERO = new Matrix4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), Matrix4.IDENTITY = new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), Matrix4.CLIPSPACE2DTOIMAGESPACE = new Matrix4(.5, 0, 0, .5, 0, -.5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1);
var Quaternion = function(a, b, c, d) {
    this.w = void 0 !== a ? a : 1, this.x = b || 0, this.y = c || 0, this.z = d || 0
};
Quaternion.prototype = {
    constructor: Quaternion,
    add: function(a) {
        return new Quaternion(this.w + a.w, this.x + a.x, this.y + a.x, this.z + a.z)
    },
    sub: function(a) {
        return new Quaternion(this.w - a.w, this.x - a.x, this.y - a.x, this.z - a.z)
    },
    multiply: function(a) {
        var b = void 0 !== a.x ? a.x : a,
            c = void 0 !== a.y ? a.y : a,
            d = void 0 !== a.z ? a.z : a,
            e = void 0 !== a.w ? a.w : a,
            f = this.x,
            g = this.y,
            h = this.z,
            i = this.w;
        if (void 0 !== a.w) return new Quaternion(i * e - f * b - g * c - h * d, i * b + f * e + g * d - h * c, i * c + g * e + h * b - f * d, i * d + h * e + f * c - g * b);
        if (void 0 !== a.z) {
            var j = new Vector3(f, g, h),
                k = j.cross(a),
                l = j.cross(k);
            return k = k.multiply(2 * i), l = l.multiply(2), a.add(k).add(l)
        }
        return new Quaternion(i * a, f * a, g * a, h * a)
    },
    negtive: function() {
        return new Quaternion(-this.w, -1 * this.x, -this.y, -this.z)
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
    },
    cross: function(a) {
        return new Vector3(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x)
    },
    norm: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    },
    UnitInverse: function() {
        return new Quaternion(this.w, -this.x, -this.y, -this.z)
    },
    inverse: function() {
        var a = this.x,
            b = this.y,
            c = this.z,
            d = this.w,
            e = a * a + b * b + c * c + d * d;
        if (e > 0) {
            var f = 1 / e;
            return new Quaternion(d * f, -a * f, -b * f, -c * f)
        }
        return new Quaternion(0, 0, 0, 0)
    },
    unitInverse: function() {
        return new Quaternion(this.w, -this.x, -this.y, -this.z)
    },
    exp: function() {
        var a = this.x,
            b = this.y,
            c = this.z,
            d = (this.w, Math.radians(Math.sqrt(a * a + b * b + c * c))),
            e = Math.sin(d),
            f = new Quaternion;
        if (f.w = Math.cos(d), Math.abs(e) >= .001) {
            var g = e / d;
            f.x = g * a, f.y = g * b, f.z = g * c
        } else f.x = a, f.y = b, f.z = c;
        return f
    },
    log: function() {
        var a = this.x,
            b = this.y,
            c = this.z,
            d = this.w,
            e = new Quaternion;
        if (e.w = 0, Math.abs(d) < 1) {
            var f = Math.radians(Math.cos(d)),
                g = Math.sin(f);
            if (Math.abs(g) >= .001) {
                var h = f / g;
                return e.x = h * a, e.y = h * b, e.z = h * c, e
            }
        }
        return e.x = a, e.y = b, e.z = c, e
    },
    copy: function(a) {
        return this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w, this
    },
    getRoll: function(a) {
        var b = this.x,
            c = this.y,
            d = this.z,
            e = this.w;
        if (null == a && (a = !0), a) {
            var f = 2 * c,
                g = 2 * d,
                h = g * e,
                i = f * b,
                j = f * c,
                k = g * d;
            return new Radian(Math.atan2(i + h, 1 - (j + k)))
        }
        return new Radian(Math.atan2(2 * (b * c + e * d), e * e + b * b - c * c - d * d))
    },
    getPitch: function(a) {
        if (null == a && (a = !0), a) {
            var b = 2 * this.x,
                c = 2 * this.z,
                d = b * this.w,
                e = b * this.x,
                f = c * this.y,
                g = c * this.z;
            return new Radian(Math.atan2(f + d, 1 - (e + g)))
        }
        return new Radian(Math.atan2(2 * (this.y * this.z + this.w * this.x), this.w * this.w - this.x * this.x - this.y * this.y + this.z * this.z))
    },
    getYaw: function(a) {
        if (null == a && (a = !0), a) {
            var b = 2 * this.x,
                c = 2 * this.y,
                d = 2 * this.z,
                e = c * this.w,
                f = b * this.x,
                g = d * this.x,
                h = c * this.y;
            return Radian(Math.atan2(g + e, 1 - (f + h)))
        }
        return Radian(Math.asin(-2 * (this.x * this.z - this.w * this.y)))
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
    },
    notEquals: function(a) {
        return !this.equals(a)
    },
    normalize: function() {
        var a = this.length();
        return 0 === a ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a), this
    },
    normalise: function() {
        return this.normalize()
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    },
    set: function(a, b, c, d) {
        return this.x = b || 0, this.y = c || 0, this.z = d || 0, this.w = void 0 !== a ? a : 1, this
    },
    setFromAxisAngle: function(a, b) {
        var c = a / 2,
            d = Math.sin(c);
        return this.x = b.x * d, this.y = b.y * d, this.z = b.z * d, this.w = Math.cos(c), this
    },
    setFromAngleAxis: function(a, b) {
        this.setFromAxisAngle(a, b)
    },
    setFromVector3: function(a, b, c) {
        var d = new Matrix3;
        return d.m[0] = a.x, d.m[3] = a.y, d.m[6] = a.z, d.m[1] = b.x, d.m[4] = b.y, d.m[7] = b.z, d.m[2] = c.x, d.m[5] = c.y, d.m[8] = c.z, this.fromRotationMatrix(d), this
    },
    setFromMatrix: function(a) {
        var b, c, d, e, f, g, h, i, j, k;
        b = a.m, a instanceof Matrix4 ? (c = b[0], d = b[1], e = b[2], f = b[4], g = b[5], h = b[6], i = b[8], j = b[9], k = b[10]) : a instanceof Matrix3 && (c = b[0], d = b[1], e = b[2], f = b[3], g = b[4], h = b[5], i = b[6], j = b[7], k = b[8]);
        var l, m = c + g + k;
        return m > 0 ? (l = .5 / Math.sqrt(m + 1), this.w = .25 / l, this.x = (j - h) * l, this.y = (e - i) * l, this.z = (f - d) * l) : c > g && c > k ? (l = 2 * Math.sqrt(1 + c - g - k), this.w = (j - h) / l, this.x = .25 * l, this.y = (d + f) / l, this.z = (e + i) / l) : g > k ? (l = 2 * Math.sqrt(1 + g - c - k), this.w = (e - i) / l, this.x = (d + f) / l, this.y = .25 * l, this.z = (h + j) / l) : (l = 2 * Math.sqrt(1 + k - c - g), this.w = (f - d) / l, this.x = (e + i) / l, this.y = (h + j) / l, this.z = .25 * l), this
    },
    fromRotationMatrix: function(a) {
        var b, c = a.m,
            d = c[0] + c[4] + c[8];
        if (d > 0) b = Math.sqrt(d + 1), this.w = .5 * b, b = .5 / b, this.x = (c[7] - c[5]) * b, this.y = (c[2] - c[6]) * b, this.z = (c[3] - c[1]) * b;
        else {
            var e = [1, 2, 0],
                f = 0;
            c[4] > c[0] && (f = 1), c[8] > c[3 * f + f] && (f = 2);
            var g = e[f],
                h = e[g];
            b = Math.sqrt(c[3 * f + f] - c[3 * g + g] - c[3 * h + h] + 1), 0 == f ? this.x = .5 * b : 1 == f ? this.y = .5 * b : 2 == f && (this.z = .5 * b), b = .5 / b, this.w = (c[3 * h + g] - c[3 * g + h]) * b, 0 == g ? this.x = (c[3 * g + f] - c[3 * f + g]) * b : 1 == g ? this.y = (c[3 * g + f] - c[3 * f + g]) * b : 2 == g && (this.z = (c[3 * g + f] - c[3 * f + g]) * b), 0 == h ? this.x = (c[3 * h + f] - c[3 * f + h]) * b : 1 == h ? this.y = (c[3 * h + f] - c[3 * f + h]) * b : 2 == h && (this.z = (c[3 * h + f] - c[3 * f + h]) * b)
        }
    },
    setFromEuler: function(a) {
        if (a instanceof Euler == !1) throw new Error("ERROR: Quaternionnion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
        var b = Math.cos(a._x / 2),
            c = Math.cos(a._y / 2),
            d = Math.cos(a._z / 2),
            e = Math.sin(a._x / 2),
            f = Math.sin(a._y / 2),
            g = Math.sin(a._z / 2);
        return "XYZ" === a.order ? (this._x = e * c * d + b * f * g, this._y = b * f * d - e * c * g, this._z = b * c * g + e * f * d, this._w = b * c * d - e * f * g) : "YXZ" === a.order ? (this._x = e * c * d + b * f * g, this._y = b * f * d - e * c * g, this._z = b * c * g - e * f * d, this._w = b * c * d + e * f * g) : "ZXY" === a.order ? (this._x = e * c * d - b * f * g, this._y = b * f * d + e * c * g, this._z = b * c * g + e * f * d, this._w = b * c * d - e * f * g) : "ZYX" === a.order ? (this._x = e * c * d - b * f * g, this._y = b * f * d + e * c * g, this._z = b * c * g - e * f * d, this._w = b * c * d + e * f * g) : "YZX" === a.order ? (this._x = e * c * d + b * f * g, this._y = b * f * d + e * c * g, this._z = b * c * g - e * f * d, this._w = b * c * d - e * f * g) : "XZY" === a.order && (this._x = e * c * d - b * f * g, this._y = b * f * d - e * c * g, this._z = b * c * g + e * f * d, this._w = b * c * d + e * f * g), this
    },
    toMatrix3: function() {
        var a = new Matrix3,
            b = a.m,
            c = this.x,
            d = this.y,
            e = this.z,
            f = this.w,
            g = c + c,
            h = d + d,
            i = e + e,
            j = g * f,
            k = h * f,
            l = i * f,
            m = g * c,
            n = h * c,
            o = i * c,
            p = h * d,
            q = i * d,
            r = i * e;
        return b[0] = 1 - (p + r), b[1] = n - l, b[2] = o + k, b[3] = n + l, b[4] = 1 - (m + r), b[5] = q - j, b[6] = o - k, b[7] = q + j, b[8] = 1 - (m + p), a
    },
    toMatrix4: function() {
        var a = new Matrix4,
            b = a.m,
            c = this.x,
            d = this.y,
            e = this.z,
            f = this.w,
            g = c + c,
            h = d + d,
            i = e + e,
            j = g * f,
            k = h * f,
            l = i * f,
            m = g * c,
            n = h * c,
            o = i * c,
            p = h * d,
            q = i * d,
            r = i * e;
        return b[0] = 1 - (p + r), b[1] = n - l, b[2] = o + k, b[3] = 0, b[4] = n + l, b[5] = 1 - (m + r), b[6] = q - j, b[7] = 0, b[8] = o - k, b[9] = q + j, b[10] = 1 - (m + p), b[11] = b[12] = b[13] = b[14] = 0, b[15] = 1, a
    },
    toAxes: function() {
        var a = this.toMatrix3(),
            b = new Vector3;
        b.x = a.m[0], b.y = a.m[3], b.z = a.m[6];
        var c = new Vector3;
        c.x = a.m[1], c.y = a.m[4], c.z = a.m[7];
        var d = new Vector3;
        return d.x = a.m[2], d.y = a.m[5], d.z = a.m[8], [b, c, d]
    },
    toXAxis: function() {
        var a = 2 * this.y,
            b = 2 * this.z,
            c = a * this.w,
            d = b * this.w,
            e = a * this.x,
            f = b * this.x,
            g = a * this.y,
            h = b * this.z;
        return new Vector3(1 - (g + h), e + d, f - c)
    },
    toYAxis: function() {
        var a = 2 * this.x,
            b = 2 * this.y,
            c = 2 * this.z,
            d = a * this.w,
            e = c * this.w,
            f = a * this.x,
            g = b * this.x,
            h = c * this.y,
            i = c * this.z;
        return new Vector3(g - e, 1 - (f + i), h + d)
    },
    toZAxis: function() {
        var a = 2 * this.x,
            b = 2 * this.y,
            c = 2 * this.z,
            d = a * this.w,
            e = b * this.w,
            f = a * this.x,
            g = c * this.x,
            h = b * this.y,
            i = c * this.y;
        return new Vector3(g + e, i - d, 1 - (f + h))
    },
    ToRotationMatrix: function() {
        var a = new Matrix3,
            b = a.m,
            c = this.x + this.x,
            d = this.y + this.y,
            e = this.z + this.z,
            f = c * this.w,
            g = d * this.w,
            h = e * this.w,
            i = c * this.x,
            j = d * this.x,
            k = e * this.x,
            l = d * this.y,
            m = e * this.y,
            n = e * this.z;
        return b[0] = 1 - (l + n), b[1] = j - h, b[2] = k + g, b[3] = j + h, b[4] = 1 - (i + n), b[5] = m - f, b[6] = k - g, b[7] = m + f, b[8] = 1 - (i + l), a
    }
}, Quaternion.ZERO = new Quaternion(0, 0, 0, 0), Quaternion.IDENTITY = new Quaternion(1, 0, 0, 0);
var ColourValue = function(a, b, c, d) {
    this.r = void 0 !== a ? a : 1, this.g = void 0 !== b ? b : 1, this.b = void 0 !== c ? c : 1, this.a = void 0 !== d ? d : 1
};
ColourValue.prototype = {
    constructor: ColourValue,
    copy: function(a) {
        return this.r = a.r, this.g = a.g, this.b = a.b, this.a = a.a, this
    },
    add: function(a) {
        var b = new ColourValue;
        return b.r = this.r + a.r, b.g = this.g + a.g, b.b = this.b + a.b, b.a = this.a + a.a, b
    },
    sub: function(a) {
        var b = new ColourValue;
        return b.r = this.r - a.r, b.g = this.g - a.g, b.b = this.b - a.b, b.a = this.a - a.a, b
    },
    multiply: function(a) {
        var b = new ColourValue;
        return b.r = a.r * this.r, b.g = a.g * this.g, b.b = a.b * this.b, b.a = a.a * this.a, b
    },
    multiplyScalar: function(a) {
        var b = new ColourValue;
        return b.r = a * this.r, b.g = a * this.g, b.b = a * this.b, b.a = a * this.a, b
    },
    divide: function(a) {
        var b = new ColourValue;
        return b.r = a.r / this.r, b.g = a.g / this.g, b.b = a.b / this.b, b.a = a.a / this.a, b
    },
    equals: function(a) {
        return this.r == a.r && this.g == a.g && this.b == a.b && this.a == a.a
    },
    divideScalar: function(a) {
        var b = new ColourValue;
        if (0 != a) {
            var c = 1 / a;
            return b.r = c * this.r, b.g = c * this.g, b.b = c * this.b, b.a = c * this.a, b
        }
    },
    getAsRGBA: function() {
        var a = 255 * this.r,
            b = a << 24;
        return a = 255 * this.g, b += a << 16, a = 255 * this.b, b += a << 8, a = 255 * this.a, b += a
    },
    getAsARGB: function() {
        var a = 255 * this.a,
            b = a << 24;
        return a = 255 * this.r, b += a << 16, a = 255 * this.g, b += a << 8, a = 255 * this.b, b += a
    },
    getAsBGRA: function() {
        var a = 255 * this.b,
            b = a << 24;
        return a = 255 * this.g, b += a << 16, a = 255 * this.r, b += a << 8, a = 255 * this.a, b += a
    },
    getAsABGR: function() {
        var a = 255 * this.a,
            b = a << 24;
        return a = 255 * this.b, b += a << 16, a = 255 * this.g, b += a << 8, a = 255 * this.r, b += a
    },
    setAsRGBA: function(a) {
        var b = a;
        this.r = (b >> 24 & 255) / 255, this.g = (b >> 16 & 255) / 255, this.b = (b >> 8 & 255) / 255, this.a = (255 & b) / 255
    },
    setAsARGB: function(a) {
        var b = a;
        this.a = (b >> 24 & 255) / 255, this.r = (b >> 16 & 255) / 255, this.g = (b >> 8 & 255) / 255, this.b = (255 & b) / 255
    },
    setAsBGRA: function(a) {
        var b = a;
        this.b = (b >> 24 & 255) / 255, this.g = (b >> 16 & 255) / 255, this.r = (b >> 8 & 255) / 255, this.a = (255 & b) / 255
    },
    setAsABGR: function(a) {
        var b = a;
        this.a = (b >> 24 & 255) / 255, this.b = (b >> 16 & 255) / 255, this.g = (b >> 8 & 255) / 255, this.r = (255 & b) / 255
    },
    isEquals: function(a) {
        return this.r == a.r && this.g == a.g && this.b == a.b && this.a == a.a
    },
    isNotEquals: function(a) {
        return !this.isEquals(a)
    },
    setHSB: function(a, b, c) {
        if (a > 1 ? a -= parseInt(a) : 0 > a && (a += parseInt(a) + 1), b = Math.min(b, 1), b = Math.max(b, 0), c = Math.min(c, 1), c = Math.max(c, 0), 0 == c) return this.r = 0, this.g = 0, void(this.b = 0);
        if (0 == b) return this.r = c, this.g = c, void(this.b = c);
        var d = 6 * a;
        d >= 6 && (d = 0);
        var e = d,
            f = c * (1 - b),
            g = c * (1 - b * (d - e)),
            h = c * (1 - b * (1 - (d - e)));
        switch (e) {
            case 0:
                this.r = c, this.g = h, this.b = f;
                break;
            case 1:
                this.r = g, this.g = c, this.b = f;
                break;
            case 2:
                this.r = f, this.g = c, this.b = h;
                break;
            case 3:
                this.r = f, this.g = g, this.b = c;
                break;
            case 4:
                this.r = h, this.g = f, this.b = c;
                break;
            case 5:
                this.r = c, this.g = f, this.b = g
        }
    },
    getHSB: function(a, b, c) {
        var d = Math.min(this.r, Math.min(this.g, this.b)),
            e = Math.max(this.r, Math.max(this.g, this.b)),
            f = e - d;
        if (c = e, Math.equals(f, 0)) a = 0, b = 0;
        else {
            b = f / e;
            var g = ((e - this.r) / 6 + f / 2) / f,
                h = ((e - this.g) / 6 + f / 2) / f,
                i = ((e - this.b) / 6 + f / 2) / f;
            Math.equals(this.r, e) ? a = i - h : Math.equals(this.g, e) ? a = .3333333 + g - i : Math.equals(this.b, e) && (a = .6666667 + h - g), 0 > a && (a += 1), a > 1 && (a -= 1)
        }
    },
    saturate: function() {
        this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1)
    },
    saturateCopy: function() {
        var a = this;
        return a.saturate(), a
    }
}, ColourValue.ZERO = new ColourValue(0, 0, 0, 0), ColourValue.Black = new ColourValue(0, 0, 0, 1), ColourValue.White = new ColourValue(1, 1, 1, 1), ColourValue.Red = new ColourValue(1, 0, 0, 1), ColourValue.Green = new ColourValue(0, 1, 0, 1), ColourValue.Blue = new ColourValue(0, 0, 1, 1);
var Euler = function(a, b, c, d) {
    this._x = a || 0, this._y = b || 0, this._z = c || 0, this._order = d || Euler.DefaultOrder
};
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Euler.DefaultOrder = "XYZ", Euler.prototype = {
    constructor: Euler,
    _x: 0,
    _y: 0,
    _z: 0,
    _order: Euler.DefaultOrder,
    get x() {
        return this._x
    },
    set x(a) {
        this._x = a
    },
    get y() {
        return this._y
    },
    set y(a) {
        this._y = a
    },
    get z() {
        return this._z
    },
    set z(a) {
        this._z = a
    },
    get order() {
        return this._order
    },
    set order(a) {
        this._order = a
    },
    set: function(a, b, c, d) {
        return this._x = a, this._y = b, this._z = c, this._order = d || this._order, this
    },
    copy: function(a) {
        return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this
    },
    setFromMatrix: function(a, b) {
        var c = Math.clamp,
            d = a.m,
            e = d[0],
            f = d[4],
            g = d[8],
            h = d[1],
            i = d[5],
            j = d[9],
            k = d[2],
            l = d[6],
            m = d[10];
        return b = b || this._order, "XYZ" === b ? (this._y = Math.asin(c(g, -1, 1)), Math.abs(g) < .99999 ? (this._x = Math.atan2(-j, m), this._z = Math.atan2(-f, e)) : (this._x = Math.atan2(l, i), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-c(j, -1, 1)), Math.abs(j) < .99999 ? (this._y = Math.atan2(g, m), this._z = Math.atan2(h, i)) : (this._y = Math.atan2(-k, e), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(c(l, -1, 1)), Math.abs(l) < .99999 ? (this._y = Math.atan2(-k, m), this._z = Math.atan2(-f, i)) : (this._y = 0, this._z = Math.atan2(h, e))) : "ZYX" === b ? (this._y = Math.asin(-c(k, -1, 1)), Math.abs(k) < .99999 ? (this._x = Math.atan2(l, m), this._z = Math.atan2(h, e)) : (this._x = 0, this._z = Math.atan2(-f, i))) : "YZX" === b ? (this._z = Math.asin(c(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(-j, i), this._y = Math.atan2(-k, e)) : (this._x = 0, this._y = Math.atan2(g, m))) : "XZY" === b ? (this._z = Math.asin(-c(f, -1, 1)), Math.abs(f) < .99999 ? (this._x = Math.atan2(l, i), this._y = Math.atan2(g, e)) : (this._x = Math.atan2(-j, m), this._y = 0)) : console.warn("Euler: .setFromRotationMatrix() given unsupported order: " + b), this._order = b, this
    },
    setFromQuaternion: function(a, b, c) {
        var d = Math.clamp,
            e = a.x * a.x,
            f = a.y * a.y,
            g = a.z * a.z,
            h = a.w * a.w;
        return b = b || this._order, "XYZ" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.y * a.z), h - e - f + g), this._y = Math.asin(d(2 * (a.x * a.z + a.y * a.w), -1, 1)), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h + e - f - g)) : "YXZ" === b ? (this._x = Math.asin(d(2 * (a.x * a.w - a.y * a.z), -1, 1)), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h - e - f + g), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h - e + f - g)) : "ZXY" === b ? (this._x = Math.asin(d(2 * (a.x * a.w + a.y * a.z), -1, 1)), this._y = Math.atan2(2 * (a.y * a.w - a.z * a.x), h - e - f + g), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h - e + f - g)) : "ZYX" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.z * a.y), h - e - f + g), this._y = Math.asin(d(2 * (a.y * a.w - a.x * a.z), -1, 1)), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h + e - f - g)) : "YZX" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.z * a.y), h - e + f - g), this._y = Math.atan2(2 * (a.y * a.w - a.x * a.z), h + e - f - g), this._z = Math.asin(d(2 * (a.x * a.y + a.z * a.w), -1, 1))) : "XZY" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.y * a.z), h - e + f - g), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h + e - f - g), this._z = Math.asin(d(2 * (a.z * a.w - a.x * a.y), -1, 1))) : console.warn("Euler: .setFromQuaternion() given unsupported order: " + b), this._order = b, c !== !1 && this.onChangeCallback(), this
    },
    reorder: function() {
        var a = new Quaternion;
        return function(b) {
            a.setFromEuler(this), this.setFromQuaternion(a, b)
        }
    }(),
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
    },
    fromArray: function(a) {
        return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), this
    },
    toArray: function() {
        return [this._x, this._y, this._z, this._order]
    },
    clone: function() {
        return new Euler(this._x, this._y, this._z, this._order)
    }
}, Math.generateUUID = function() {
    var a, b = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
        c = new Array(36),
        d = 0;
    return function() {
        for (var e = 0; 36 > e; e++) 8 == e || 13 == e || 18 == e || 23 == e ? c[e] = "-" : 14 == e ? c[e] = "4" : (2 >= d && (d = 33554432 + 16777216 * Math.random() | 0), a = 15 & d, d >>= 4, c[e] = b[19 == e ? 3 & a | 8 : a]);
        return c.join("")
    }
}(), e3d._cp(e3d._drowssap_sea), Math.TWO_PI = 2 * Math.PI, Math.HALF_PI = .5 * Math.PI, Math.radians = function(a) {
    return a * Math.PI / 180
}, Math.degrees = function(a) {
    return 180 * a / Math.PI
}, Math.invSqrt = function(a) {
    return 1 / Math.sqrt(a)
}, Math.clamp = function(a, b, c) {
    return b > a ? b : a > c ? c : a
}, Math.rangeRandom = function(a, b) {
    return Math.random() * (b - a) + a
}, Math.symmetricRandom = function() {
    return 2 * Math.random() - 1
}, Math.sqr = function(a) {
    return a * a
}, Math.sign = function(a) {
    return a > 0 ? 1 : 0 > a ? -1 : 0
}, Math.equals = function(a, b) {
    return Math.abs(b - a) <= 1e-6 ? !0 : !1
}, Math.RealEqual = Math.equals, Math.log2 = function(a) {
    return Math.log(a) / Math.log(2)
}, Math.compose = function(a, b, c) {
    var d = new Matrix4;
    return d.setFromQuaternion(b), d.setPosition(a), d.setScale(c), d
}, Math.decompose = function() {
    var a = new Vector3,
        b = new Quaternion,
        c = new Vector3;
    return function(d) {
        var e = d.extract3x3Matrix();
        return b.fromRotationMatrix(e), c.copy(d.getScale()), a.copy(d.getPosition()), [a, b, c]
    }
}(), Math.makeTranslationMatrix = function(a, b, c) {
    var d = new Matrix4(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
    return d
}, Math.makeRotationMatrix = function(a, b, c, d) {
    var e = Math.cos(d),
        f = Math.sin(d),
        g = 1 - e,
        h = g * a,
        i = g * b;
    return new Matrix4(h * a + e, h * b - f * c, h * c + f * b, 0, h * b + f * c, i * b + e, i * c - f * a, 0, h * c - f * b, i * c + f * a, g * c * c + e, 0, 0, 0, 0, 1)
}, Math.makeScaleMatrix = function(a, b, c) {
    return new Matrix4(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1)
}, Math.makeFrustumMatrix = function(a, b, c, d, e, f) {
    var g = b + a,
        h = b - a,
        i = d - c,
        j = d + c,
        k = f + e,
        l = f - e;
    return new Matrix4(0 * e / h, 0, 0, 0, 0, 2 * e / i, 0, 0, g / h, j / i, -k / l, -1, 0, 0, -2 * f * e / l, 0)
}, Math.makePerspectiveMatrix = function(a, b, c, d) {
    var e = 1 / Math.tan(a / 2);
    return new Matrix4(e / b, 0, 0, 0, 0, e, 0, 0, 0, 0, (d + c) / (c - d), -1, 0, 0, 2 * d * c / (c - d), 0)
}, Math.makeOrthoMatrix = function(a, b, c, d, e, f) {
    var g = b + a,
        h = b - a,
        i = d - c,
        j = d + c,
        k = f + e,
        l = f - e;
    return new Matrix4(2 / h, 0, 0, 0, 0, 2 / i, 0, 0, 0, 0, -2 / l, 0, -g / h, -j / i, -k / l, 1)
}, Math.makeLookAt = function(a, b, c) {
    var d = a.sub(b).normalisedCopy(),
        e = c.cross(d).normalisedCopy(),
        f = d.cross(e);
    return new Matrix4(e.x, f.x, d.x, 0, e.y, f.y, d.y, 0, e.z, f.z, d.z, 0, -e.dot(a), -f.dot(a), -d.dot(a), 1)
}, Math.makeViewMatrix = function(a, b, c) {
    var d = b.ToRotationMatrix(),
        e = d.transpose(),
        f = e.multiply(a).multiply(-1),
        g = new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return g.setFromMatrix(e), g.m[3] = f.x, g.m[7] = f.y, g.m[11] = f.z, c && (g = g.multiply(c)), g
}, Math.makeTransform = function(a, b, c) {
    var d = new Matrix4,
        e = b.toMatrix3(),
        f = d.m,
        g = e.m;
    return f[0] = c.x * g[0], f[1] = c.y * g[1], f[2] = c.z * g[2], f[3] = a.x, f[4] = c.x * g[3], f[5] = c.y * g[4], f[6] = c.z * g[5], f[7] = a.y, f[8] = c.x * g[6], f[9] = c.y * g[7], f[10] = c.z * g[8], f[11] = a.z, f[12] = 0, f[13] = 0, f[14] = 0, f[15] = 1, d
};
var Radian = function(a) {
    this.mRad = a || 0
};
Radian.prototype = {
    constructor: Radian,
    add: function(a) {
        return a instanceof Radian ? new Radian(this.mRad + a.mRad) : a instanceof Degree ? new Radian(this.mRad + a.valueRadians()) : void 0
    },
    sub: function(a) {
        return a instanceof Radian ? new Radian(this.mRad + a.mRad) : a instanceof Degree ? new Radian(this.mRad + a.valueRadians()) : void 0
    },
    multiply: function(a) {},
    div: function(a) {},
    smallerThan: function(a) {
        return a instanceof Radian ? this.mRad < a.mRad : void console.error("TypeError")
    },
    biggerThan: function(a) {
        return a instanceof Radian ? this.mRad > a.mRad : void console.error("TypeError")
    }
};
var Degree = function() {
    this.mDeg = 0
};
Degree.prototype = {
    constructor: Degree,
    add: function(a) {},
    sub: function(a) {},
    multiply: function(a) {},
    div: function(a) {}
};
var XMLJS = function() {};
XMLJS.apply = function(a, b, c) {
    if (c && XMLJS.apply(a, c), a && b && "object" == typeof b)
        for (var d in b) a[d] = b[d];
    return a
}, XMLJS.apply(XMLJS, {
    docObjs: new Array,
    initDocs: function(a) {
        null == a && (a = 3);
        for (var b = 0; a > b; b++) {
            XMLJS.docObjs[b] = new Object;
            try {
                XMLJS.docObjs[b].doc = new DOMParser, XMLJS.docObjs[b].doc.async = !1, XMLJS.docObjs[b].free = !0
            } catch (c) {
                XMLJS.docObjs[b].doc = new ActiveXObject("Microsoft.XMLDOM"), XMLJS.docObjs[b].doc.async = !1, XMLJS.docObjs[b].free = !0
            }
        }
    },
    getFreeDocObj: function() {
        for (var a = null, b = 0; b < XMLJS.docObjs.length; b++)
            if (XMLJS.docObjs[b].free) {
                XMLJS.docObjs[b].free = !1, a = XMLJS.docObjs[b];
                break
            }
        return a
    },
    parseXML: function(a) {
        var b = XMLJS.getFreeDocObj();
        try {
            var c = b.doc.parseFromString(a, "text/xml");
            return b.free = !0, c
        } catch (d) {
            b.doc.loadXML(a);
            var e = b.doc;
            return b.free = !0, e
        }
    },
    parseXML2: function(a) {
        var b;
        try {
            b = new DOMParser;
            var c = b.parseFromString(a, "text/xml");
            return c
        } catch (d) {
            return b = new ActiveXObject("Microsoft.XMLDOM"), b.async = !1, b.loadXML(a), b
        }
    },
    getXMLSubNodes: function(a, b) {
        for (var c = [], d = a, e = null, f = b.split("/"), g = 0; null != f && g < f.length - 1; g++)
            if ("" != f[g]) {
                e = d.childNodes;
                for (var h = 0; null != e && h < e.length; h++)
                    if (e[h].nodeName.toLowerCase() == f[g].toLowerCase()) {
                        d = e[h];
                        break
                    }
            }
        e = d.childNodes;
        for (var g = 0; g < e.length; g++) e[g].nodeName.toLowerCase() == f[f.length - 1].toLowerCase() && c.push(e[g]);
        return c
    },
    getXMLRootNode: function(a) {
        return null == a ? null : a.documentElement
    },
    getXMLChildNodes: function(a) {
        for (var b = [], c = a.childNodes, d = 0; d < c.length; d++) 1 == c[d].nodeType && b.push(c[d]);
        return b
    },
    getXMLChildNode: function(a, b) {
        var c = a.getElementsByTagName(b);
        return c.documentElement
    },
    getXMLNodeValue: function(a, b) {
        return null == a ? null : XMLJS.getXMLSingleNodeValue(a.documentElement, b)
    },
    getXMLSingleNodeValue: function(a, b) {
        var c = a.getElementsByTagName(b),
            d = "";
        return null != c[0] && null != c[0].firstChild && (d = c[0].firstChild.nodeValue), null != d ? d.replace(/^\s+|\s+$/g, "").replace(/[ ]+/, " ") : d
    },
    getAttributeNodeValues: function(a, b, c) {
        if (null == a) return null;
        for (var d = [], e = a.length, f = "", g = 0; e > g; g++) a[g].nodeName == b && (f = a[g].getAttribute(c), d.push(f));
        return d
    },
    getAttributeNodeValue: function(a, b) {
        var c = "";
        return null != a && (c = a.getAttribute(b)), null != c ? c.replace(/^\s+|\s+$/g, "").replace(/[ ]+/, " ") : c
    },
    getNodeName: function(a) {
        var b = null;
        return null != a && (b = a.nodeName), null != b ? b.replace(/^\s+|\s+$/g, "").replace(/[ ]+/, " ") : b
    }
}), XMLJS.initDocs();
var JSONJS = function() {};
JSONJS.apply = function(a, b, c) {
    if (c && JSONJS.apply(a, c), a && b && "object" == typeof b)
        for (var d in b) a[d] = b[d];
    return a
}, JSONJS.apply(JSONJS, {
    docObjs: new Array,
    getAttributeNodeValue: function(a, b) {
        var c = null,
            d = null;
        return null != a && (d = a["@attributes"]), d && (c = d[b]), c ? c.replace(/^\s+|\s+$/g, "").replace(/[ ]+/, " ") : null
    },
    getJSONChildNodes: function(a) {
        var b = [];
        for (var c in a) b.push(c);
        return b
    },
    getJSONChildNode: function(a, b) {
        var c = a[b];
        return c ? c : null
    },
    parseJSON: function(a) {
        var b = JSON.parse(a);
        return b ? b : null
    }
});
var E3dWallpaperBase = function(a, b) {
    if (this.mRoot = new Root, window.innerWidth > window.innerHeight) {
        var c = a.width;
        a.width = a.height, a.height = c
    }
    var d = a.getBoundingClientRect(),
        e = this.mRoot.getCanvasRatio(a);
    this.mScreWid = d.width * e, this.mScreHet = d.height * e, a.width = this.mScreWid, a.height = this.mScreHet, this.mRoot.init(a, b);
    for (var f = 0, g = ["ms", "moz", "webkit", "o"], h = 0; h < g.length && !self.requestAnimationFrame; ++h) this.requestAnimationFrame = self[g[h] + "RequestAnimationFrame"],
        this.cancelAnimationFrame = self[g[h] + "CancelAnimationFrame"] || self[g[h] + "CancelRequestAnimationFrame"];
    void 0 === this.requestAnimationFrame && void 0 !== self.setTimeout && (this.requestAnimationFrame = function(a) {
        var b = Date.now(),
            c = Math.max(0, 16 - (b - f)),
            d = self.setTimeout(function() {
                a(b + c)
            }, c);
        return f = b + c, d
    }), void 0 === this.cancelAnimationFrame && void 0 !== self.clearTimeout && (this.cancelAnimationFrame = function(a) {
        self.clearTimeout(a)
    }), this.mLoadingAssetsTree = {
        children: []
    }, this.mIsLoadingAssets = !1, this.mLoadingAssetList = [], this.mIsLoadingAsset = !1
};
E3dWallpaperBase.prototype = {
    constructor: E3dWallpaperBase,
    destroy: function() {
        this.mRoot.destroy(), this.mRoot = null
    },
    setEngineMode: function(a) {
        this.mRoot.setEngineMode(a)
    },
    loadBoxEditor2dAsset: function(a, b, c, d) {
        var e = Math.generateUUID();
        if (this.mRoot.mBoxEditor2dParameters.groupHandle = e, a) {
            var f = a.substring(a.lastIndexOf("/") + 1, a.length).toLowerCase(),
                g = a.substring(0, a.lastIndexOf("/")).toLowerCase();
            a = this.mRoot.getTextureManager().create(f, e), a.load(null, g), this.mRoot.mBoxEditor2dParameters.closeBtnAsset = f
        }
        if (b) {
            var f = b.substring(b.lastIndexOf("/") + 1, b.length).toLowerCase(),
                g = b.substring(0, b.lastIndexOf("/")).toLowerCase();
            b = this.mRoot.getTextureManager().create(f, e), b.load(null, g), this.mRoot.mBoxEditor2dParameters.editBtnAsset = f
        }
        if (c) {
            var f = c.substring(c.lastIndexOf("/") + 1, c.length).toLowerCase(),
                g = c.substring(0, c.lastIndexOf("/")).toLowerCase();
            c = this.mRoot.getTextureManager().create(f, e), c.load(null, g), this.mRoot.mBoxEditor2dParameters.lockBtnAsset = f
        }
        if (d) {
            var f = d.substring(d.lastIndexOf("/") + 1, d.length).toLowerCase(),
                g = d.substring(0, d.lastIndexOf("/")).toLowerCase();
            d = this.mRoot.getTextureManager().create(f, e), d.load(null, g), this.mRoot.mBoxEditor2dParameters.unlockBtnAsset = f
        }
    },
    loadAsset: function(a, b, c, d) {
        var e = new AssetHandle,
            f = null;
        return b ? (b.addChild(e), f = this._findLoadingAssetsNodeByAssetHandle(b, this.mLoadingAssetsTree)) : (this.mRoot.mRootAssetHandle.addChild(e), f = this.mLoadingAssetsTree), f && f.children.push({
            assetPath: a,
            assetHandle: e,
            loaded: !1,
            callback: c,
            children: [],
            transform: d
        }), this._tryToLoadAsset(), f = null, e
    },
    unloadAsset: function(a, b, c) {
        if (this._detachBoxEditor2d(), this.mIsLoadingAssets) return !1;
        if (null == c && (c = !0), null != a.groupHandle) this._unloadScene(a.groupHandle, b);
        else {
            for (var d = 0; d < a.children.length; d++) this.unloadAsset(a.children[d], null, !1);
            a.children = []
        }
        return c && a.removeFromParent(), a = null, b && b(), !0
    },
    unloadAllAssets: function(a) {
        if (this._detachBoxEditor2d(), this.mRoot.releaseAllResource(), this.mIsLoadingAssets) return !1;
        for (var b = this.mRoot.mRootAssetHandle, c = 0; c < b.children.length; c++) this.unloadAsset(b.children[c], a, !1);
        return b.children = [], b = null, !0
    },
    renderOneFrame: function() {
        var a = this;
        this.mRoot.renderOneFrame(), this.requestAnimationFrame(function() {
            a.renderOneFrame()
        })
    },
    start: function() {
        this.renderOneFrame()
    },
    pause: function() {
        this.mRoot.pause()
    },
    resume: function() {
        this.mRoot.resume()
    },
    getAssetTransform: function(a) {
        this._detachBoxEditor2d();
        var b = {};
        return this._getAssetTransform(a, b), b
    },
    _findLoadingAssetsNodeByAssetHandle: function(a, b) {
        if (b.assetHandle === a) return b;
        for (var c = 0; c < b.children.length; c++) {
            var d = this._findLoadingAssetsNodeByAssetHandle(a, b.children[c]);
            if (d) return d
        }
        return null
    },
    _popAssetsNode: function(a, b) {
        if (0 == b.children.length) return null;
        for (var c = 0; c < b.children.length; c++) {
            if (b.children[c].assetHandle === a) {
                var d = b.children[c];
                return b.children.splice(c, 1), d
            }
            var d = this._popAssetsNode(a, b.children[c]);
            if (d) return d
        }
        return null
    },
    _findLeftmostAssetsNode: function(a) {
        if (0 == a.children.length) return null;
        for (var b = 0; b < a.children.length; b++) return 0 == a.children[b].children.length ? a.children[b] : this._findLeftmostAssetsNode(a.children[b])
    },
    _tryToLoadAsset: function() {
        if (!this.mIsLoadingAssets && 0 != this.mLoadingAssetsTree.children.length) {
            var a = this._findLeftmostAssetsNode(this.mLoadingAssetsTree);
            a.loaded && 0 == a.children.length ? (this._popAssetsNode(a.assetHandle, this.mLoadingAssetsTree), this._tryToLoadAsset()) : this._loadAsset(a)
        }
    },
    _loadAsset: function(a) {
        this.mIsLoadingAssets = !0;
        var b = this,
            c = this._loadScene("", a.assetPath, a.assetHandle, function() {
                0 == b.mLoadingAssetList.length && (a.callback && a.callback(), a.transform && b._transformAsset(a.assetHandle, a.transform), b.mIsLoadingAssets = !1, a.loaded = !0, 0 == a.children.length && b._popAssetsNode(a.assetHandle, b.mLoadingAssetsTree), b._tryToLoadAsset())
            });
        a.assetHandle.addChild(new AssetHandle(c))
    },
    _transformAsset: function(a, b) {
        if (null == a.groupHandle)
            for (var c = 0; c < a.children.length; c++) this._transformAsset(a.children[c], b);
        else
            for (var d in this.mRoot.mScenes)
                for (var e = this.mRoot.mScenes[d], f = e.getSceneNodesByTag(BoxEditor2d.TAG), c = 0; c < f.length; c++)
                    if (f[c].getGroupID() == a.groupHandle) {
                        var g = f[c].getTransform();
                        if (b.quaternion && 0 != b.quaternion.localeCompare("")) {
                            var h = b.quaternion.split(" ");
                            h = new Quaternion(parseFloat(h[0]), parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3])), g.mOrientation = h
                        }
                        if (b.scale && 0 != b.scale.localeCompare("")) {
                            var i = b.scale.split(" ");
                            i = new Vector3(parseFloat(i[0]), parseFloat(i[1]), parseFloat(i[2])), g.mScale = i
                        }
                        if (b.translate && 0 != b.translate.localeCompare("")) {
                            var j = b.translate.split(" ");
                            4 === j.length ? g.setPositionPercentage(parseFloat(j[0]), parseFloat(j[1]), parseFloat(j[2]), parseFloat(j[3])) : 3 === j.length && g.setPositionPercentage(parseFloat(j[0]), parseFloat(j[1]), parseFloat(j[2]), 0)
                        }
                        if (null != b.event) {
                            var k = !1,
                                l = !1,
                                m = !1;
                            if (0 != b.event.localeCompare(""))
                                for (var n = b.event.split("|"), o = 0; o < n.length; o++) 0 == n[o].localeCompare("drag") ? k = !0 : 0 == n[o].localeCompare("scale") ? l = !0 : 0 == n[o].localeCompare("rotate") && (m = !0);
                            f[c].mEvent = 0, k && f[c].enableDefaultAutoDrag(), l && (f[c].mPickable = !0, f[c].mEvent += EVENT_SCALE), m && (f[c].mPickable = !0, f[c].mEvent += EVENT_ROTATE)
                        }
                    }
    },
    _loadScene: function(a, b, c, d) {
        var e = Math.generateUUID();
        return this.mLoadingAssetList.push({
            groupHandle: e,
            prefix: a,
            filename: b,
            parentAssetHandle: c,
            callback: d
        }), this._tryToLoadScene(), e
    },
    _tryToLoadScene: function() {
        if (!this.mIsLoadingAsset && 0 != this.mLoadingAssetList.length) {
            var a = this,
                b = this.mLoadingAssetList.shift();
            this.mRoot._setPreparedCallback(function() {
                a.mRoot.mInitSceneCallback && (a.mRoot.mInitSceneCallback(), a.mRoot._setInitSceneCallback(null)), a.mIsLoadingAsset = !1, a.mRoot._setPreparedCallback(null), b.callback && b.callback(), a._tryToLoadScene()
            }), this.__loadScene(b.prefix, b.filename, b.parentAssetHandle, b.groupHandle)
        }
    },
    __loadScene: function(prefix, filename, parentAssetHandle, groupHandle) {
        this.mIsLoadingAsset = !0, this.mRoot.mPrepared = !1, this.mRoot.mIsParsing = !0;
        var that = this;
        this.mRoot.debug && console.log("_____________loadScene", prefix, filename), this.mRoot.mArchive.textLoad(filename + "/assets.json", function(text, path) {
            var entry = eval("(" + text + ")").entry[0];
            entry = path + "/" + entry;
            var p = entry.lastIndexOf("/"),
                prefix = entry.substr(0, p),
                filename = entry.substr(p + 1),
                sceneXMLParser = new SceneXMLParse(that.mRoot, that, prefix, parentAssetHandle, filename, groupHandle);
            that.mRoot.mArchive.textLoad(entry, sceneXMLParser.parseScript, "", sceneXMLParser)
        }, "", filename)
    },
    _unloadScene: function(a, b) {
        this.mRoot.debug && console.log("_____________unloadScene", a), this.mRoot.releaseResourceByGroupId(a), b && b(this.mRoot.mCanvas)
    },
    _getAssetTransform: function(a, b) {
        if (null == a.groupHandle)
            for (var c = 0; c < a.children.length; c++) this._getAssetTransform(a.children[c], b);
        else {
            var d = null,
                e = null,
                f = null,
                g = null;
            for (var c in this.mRoot.mScenes)
                for (var h = this.mRoot.mScenes[c], i = h.getSceneNodesByTag(BoxEditor2d.TAG), c = 0; c < i.length; c++)
                    if (i[c].getGroupID() == a.groupHandle) {
                        var j = i[c].getTransform();
                        d = j.getOrientation(), e = j.getScale(), f = new Vector4(j.mPositionPercentage.x, j.mPositionPercentage.y, j.mPositionPercentage.z, j.mTMode), g = i[c].isGestureAllowed(EVENT_DRAG) ? "drag" : "";
                        break
                    }
            f && (b.position = "" + f.x + " " + f.y + " " + f.z + " " + f.w), e && (b.scale = "" + e.x + " " + e.y + " " + e.z), d && (b.quaternion = "" + d.w + " " + d.x + " " + d.y + " " + d.z), g && (b.event = "" + g)
        }
    },
    _detachBoxEditor2d: function(a) {
        null != this.mRoot.mBoxEditor2d && this.mRoot.mBoxEditor2d.detachGameObject()
    },
    onCanvasOrentationChange: function(a, b) {
        var c = a.width > a.height;
        console.log("shouldHenPing =" + b + " isHenPing=" + c), b != c ? this.onCanvasReverse(a) : console.log("do nothing")
    },
    onCanvasReverse: function(a) {
        var b = a.width == this.mScreWid ? this.mScreHet : this.mScreWid,
            c = a.height == this.mScreHet ? this.mScreWid : this.mScreHet;
        a.width = b, a.height = c;
        a.getBoundingClientRect();
        this.mRoot.onSize(b, c), this.mScreWid = b, this.mScreHet = c
    }
};
var Resource = function(a) {
    this.mGroupId = a
};
Resource.prototype.removeResource = function() {};
var ResourceManager = function() {
    this.mResourceList = []
};
ResourceManager.prototype.releaseResourceByGroupId = function(a) {
    for (var b = 0; b < this.mResourceList.length;) this.mResourceList[b].mGroupId == a ? this.mResourceList.splice(b, 1) : b++
}, ResourceManager.prototype.add = function(a) {
    this.mResourceList.push(a)
};
var ResourceGroupManager = function() {
    this.mResourceManagerList = []
};
ResourceGroupManager.prototype.releaseResourceByGroupId = function() {}, ResourceGroupManager.prototype.add = function(a) {
    this.mResourceManagerList.push(a)
}, Audio = function(a, b, c, d) {
    Resource.call(this), this.mRoot = a, this.mName = b, this.mPrefix = c, this.mSrc = d, this.mAudio = null, this.isResumable = !1
}, extend(Audio, Resource), Audio.prototype = {
    constructor: Audio,
    load: function() {
        var a = this;
        this.mRoot.mArchive.audioLoad(this.mSrc, function(b) {
            a.mAudio = b
        }, this.mPrefix)
    },
    play: function() {
        this.mAudio.play()
    },
    pause: function() {
        this.mAudio.paused || (this.isResumable = !0, this.mAudio.pause())
    },
    resume: function() {
        this.isResumable && (this.mAudio.play(), this.isResumable = !1)
    },
    setVolume: function(a) {
        this.mAudio.volume = a
    },
    getVolume: function() {
        return this.mAudio.volume
    },
    setAutoplay: function(a) {
        this.mAudio.autoplay = a
    },
    getAutoplay: function() {
        return this.mAudio.autoplay
    },
    setLoop: function(a) {
        this.mAudio.loop = a
    },
    getLoop: function() {
        return this.mAudio.loop
    },
    setPlaybackRate: function(a) {
        this.mAudio.playbackRate = a
    },
    getPlaybackRate: function() {
        return this.mAudio.playbackRate
    },
    getDefaultPlaybackRate: function() {
        return this.mAudio.defaultPlybackRate
    },
    getDuration: function() {
        return this.mAudio.duration
    },
    setCurrentTime: function(a) {
        this.mAudio.currentTime = a
    },
    getCurrentTime: function() {
        return this.mAudio.currentTime
    },
    rewind: function() {
        this.setCurrentTime(0)
    },
    replay: function() {
        this.rewind(), this.play()
    }
}, AudioManager = function(a) {
    this.mRoot = a, this.mAudios = {}
}, AudioManager.prototype = {
    constructor: AudioManager,
    createAudio: function(a, b, c, d) {
        var e = new Audio(this.mRoot, a, d, b);
        return e.mGroupId = c, null == this.mAudios[c] && (this.mAudios[c] = {}), null == this.mAudios[c][a] && (this.mAudios[c][a] = e), e
    },
    getAudio: function(a, b) {
        if (null == b) throw new Error("groupId cannot be null");
        var c = this.mAudios[b];
        return null == c ? null : c[a]
    },
    pause: function() {
        for (var a in this.mAudios) {
            var b = this.mAudios[a];
            for (var c in b) {
                var d = b[c];
                null != d && d.pause()
            }
        }
    },
    resume: function() {
        for (var a in this.mAudios) {
            var b = this.mAudios[a];
            for (var c in b) {
                var d = b[c];
                null != d && d.resume()
            }
        }
    },
    releaseByGroupId: function(a) {
        null != this.mAudios[a] && delete this.mAudios[a]
    }
};
var RenderQueueGroupID = {
        RENDER_QUEUE_BACKGROUND: 0,
        RENDER_QUEUE_OPAQUE: 1,
        RENDER_QUEUE_TRANSPARENT: 2,
        RENDER_QUEUE_SKIES_EARLY: 5,
        RENDER_QUEUE_SKIES_LATE: 95,
        RENDER_QUEUE_OVERLAY: 100,
        RENDER_QUEUE_OVERLAY_2: 101
    },
    RenderQueue = function() {
        this.mRenderQueueMap = {};
        for (var a in RenderQueueGroupID) this.mRenderQueueMap[RenderQueueGroupID[a]] = [];
        this.mDefaultQueueGroup = RenderQueueGroupID.RENDER_QUEUE_OPAQUE
    };
RenderQueue.prototype = {
    constructor: RenderQueue,
    addRenderable: function(a, b) {
        null == b && (b = this.mDefaultQueueGroup), this.mRenderQueueMap[b].push(a)
    },
    acceptVisitor: function(a, b) {
        if (null == b) this.acceptVisitor(a, RenderQueueGroupID.RENDER_QUEUE_BACKGROUND), this.acceptVisitor(a, RenderQueueGroupID.RENDER_QUEUE_OPAQUE), this.acceptVisitor(a, RenderQueueGroupID.RENDER_QUEUE_TRANSPARENT), this.acceptVisitor(a, RenderQueueGroupID.RENDER_QUEUE_SKIES_EARLY), this.acceptVisitor(a, RenderQueueGroupID.RENDER_QUEUE_SKIES_LATE), this.acceptVisitor(a, RenderQueueGroupID.RENDER_QUEUE_OVERLAY), this.acceptVisitor(a, RenderQueueGroupID.RENDER_QUEUE_OVERLAY_2);
        else
            for (var c = this.mRenderQueueMap[b], d = 0; d < c.length; d++) a.visit(c[d], b)
    },
    clear: function() {
        for (var a in this.mRenderQueueMap) this.mRenderQueueMap[a] = []
    }
};
var StringConverter = {
        parseVec3: function(a) {
            var b = a.split(" ");
            return new Vector3(parseFloat(b[0]), parseFloat(b[1]), parseFloat(b[2]))
        },
        parseVec2: function(a) {
            var b = a.split(" ");
            return new Vector2(parseFloat(b[0]), parseFloat(b[1]))
        },
        parseFloatArray: function(str, delimiter) {
            delimiter = delimiter || " ";
            for (var tm = str.split(delimiter), array = new Array, i = 0; i < tm.length; i++) array.push(parseFloat(eval(tm[i])));
            return array
        },
        parseArray: function(a, b) {
            b = b || " ";
            for (var c = a.split(b), d = new Array, e = 0; e < c.length; e++) d.push(c[e]);
            return d
        },
        parseBool: function(a) {
            return "true" == a.toLowerCase()
        },
        parsePath: function(a) {
            return this.parseStdStr(a)
        },
        parseStdStr: function(a) {
            return a = a.replace(/^\s+|\s+$/g, ""), a = a.replace(/[ ;]+/, " ")
        },
        parseSuffix: function(a) {
            return a.split(".").pop().toLowerCase()
        },
        parseSceneBlend: function(a, b) {
            var c = a.split(" ");
            if (1 == c.length) {
                var d;
                if ("add" == c[0]) d = SBT_ADD;
                else if ("modulate" == c[0]) d = SBT_MODULATE;
                else if ("colour_blend" == c[0]) d = SBT_TRANSPARENT_COLOUR;
                else {
                    if ("alpha_blend" != c[0]) return !1;
                    d = SBT_TRANSPARENT_ALPHA
                }
            } else if (2 == c.length) {
                var e, f;
                e = StringConverter.convertBlendFactor(c[0]), f = StringConverter.convertBlendFactor(c[1]), b.setSceneBlending(e, f)
            }
            return !1
        },
        convertBlendFactor: function(a) {
            return "one" == a ? SBF_ONE : "zero" == a ? SBF_ZERO : "dest_colour" == a ? SBF_DEST_COLOUR : "src_colour" == a ? SBF_SOURCE_COLOUR : "one_minus_dest_colour" == a ? SBF_ONE_MINUS_DEST_COLOUR : "one_minus_src_colour" == a ? SBF_ONE_MINUS_SOURCE_COLOUR : "dest_alpha" == a ? SBF_DEST_ALPHA : "src_alpha" == a ? SBF_SOURCE_ALPHA : "one_minus_dest_alpha" == a ? SBF_ONE_MINUS_DEST_ALPHA : "one_minus_src_alpha" == a ? SBF_ONE_MINUS_SOURCE_ALPHA : SBF_ONE
        },
        getSuffix: function(a) {
            return a.substring(a.lastIndexOf(".") + 1, a.length).toLowerCase()
        }
    },
    ParticleSystemJsonParse = function(a, b) {
        this.src = "", this.mRoot = a, this.parent = b
    };
ParticleSystemJsonParse.prototype = {
    constructor: ParticleSystemJsonParse,
    load: function(a) {
        this.mRoot.mArchive.textLoad(this.src, this.parseScript, a.mPrefix, this)
    },
    parseColour: function(a) {
        var b = a.split(" ");
        return new ColourValue(parseFloat(b[0]), parseFloat(b[1]), parseFloat(b[2]), parseFloat(b[3]))
    },
    parseVec3: function(a) {
        var b = a.split(" ");
        return new Vector3(parseFloat(b[0]), parseFloat(b[1]), parseFloat(b[2]))
    },
    parseArray: function(a) {
        for (var b = a.split(" "), c = new Array, d = 0; d < b.length; d++) c.push(parseFloat(b[d]));
        return c
    },
    parseBool: function(a) {
        return "true" == a.toLowerCase() || "yes" == a.toLowerCase()
    },
    parseScript: function(a, b) {
        var c = JSONJS.parseJSON(a),
            d = c.particle,
            e = d.particle_system;
        e && b.particleSystemeNodesParse(e, b, b.parent)
    },
    particleSystemeNodesParse: function(a, b, c) {
        for (var d in a) {
            var e = a[d];
            e && b.particleSystemNodeParse(e, b, c)
        }
        var f = this.mRoot.mParticleSystemManager.getTemplateMap(),
            g = null;
        for (var d in f) {
            g = f[d], g.mGroupId = c.mGroupId;
            var h = this.mRoot.getMaterialManager().getByName(g.getMaterialName(), g.mGroupId),
                i = c.mSceneManager.createGameObject(g.getName(), g.mGroupId);
            i.mGroupId = c.mGroupId, i && (i.Renderer.material = h, i.MeshFilter.mesh = g, g.setParentGameObject(b.parent), b.parent.addGameObject(i), g.resize(this.mRoot.mPhoneWidth, this.mRoot.mPhoneHeight))
        }
        for (var d in f) this.mRoot.mParticleSystemManager.getActiveParticleSystemMap()[d] = f[d];
        for (var d in f) f[d]._init_fast_forward && (f[d].fastForward(f[d]._init_fast_forward[0], f[d]._init_fast_forward[1]), delete f[d]._init_fast_forward);
        this.mRoot.mParticleSystemManager.mSystemTemplates = {}
    },
    particleSystemNodeParse: function(a, b, c) {
        var d = JSONJS.getAttributeNodeValue(a, "name"),
            e = JSONJS.getAttributeNodeValue(a, "material"),
            f = JSONJS.getAttributeNodeValue(a, "is_emitting"),
            g = JSONJS.getAttributeNodeValue(a, "stacks"),
            h = JSONJS.getAttributeNodeValue(a, "slices"),
            i = JSONJS.getAttributeNodeValue(a, "particle_width"),
            j = JSONJS.getAttributeNodeValue(a, "particle_height"),
            k = JSONJS.getAttributeNodeValue(a, "particle_width_factor"),
            l = JSONJS.getAttributeNodeValue(a, "particle_height_factor"),
            m = JSONJS.getAttributeNodeValue(a, "aspect_ratio"),
            n = JSONJS.getAttributeNodeValue(a, "quota"),
            o = JSONJS.getAttributeNodeValue(a, "quota_range_min"),
            p = JSONJS.getAttributeNodeValue(a, "quota_range_max"),
            q = JSONJS.getAttributeNodeValue(a, "always_generate_particle"),
            r = JSONJS.getAttributeNodeValue(a, "min_emit_delay_time"),
            s = JSONJS.getAttributeNodeValue(a, "max_emit_delay_time"),
            t = JSONJS.getAttributeNodeValue(a, "stick_to_finger"),
            u = JSONJS.getAttributeNodeValue(a, "fast_forward"),
            v = new ParticleSystem(this.mRoot);
        if (v.mGroupId = c.mGroupId, d && (v.mName = d), e && (v.setMaterialName(e), v.mMaterial = this.mRoot.getMaterialManager().getByName(e, v.mGroupId)), f) {
            var w = b.parseBool(f);
            v.setEmitting(w)
        }
        if (g && v.setStacks(parseInt(g)), h && v.setSlices(parseInt(h)), i && v.setDefaultWidth(parseFloat(i)), j && v.setDefaultHeight(parseFloat(j)), k && v.setDefaultWidthFactor(parseFloat(k)), l && v.setDefaultHeightFactor(parseFloat(l)), m && v.setAspectratio(parseFloat(m)), n && v.setParticleQuota(parseInt(n)), o && v.setMinParticleQuota(parseInt(o)), p && v.setMaxParticleQuota(parseInt(p)), q) {
            var x = b.parseBool(q);
            v.setAlwaysGeneratePartices(x)
        }
        r && v.setMinEmitDelayTime(parseInt(r)), s && v.setMaxEmitDelayTime(parseInt(s)), t && v.setStickToFinger(StringConverter.parseBool(t));
        var y = a.affector,
            z = a.emitter;
        y && b.affectorNodesParse(y, b, v), z && b.emitterNodesParse(z, b, v), this.mRoot.mParticleSystemManager.addTemplate(v.getName(), v), u && (u = u.split(" "), v._init_fast_forward = [parseFloat(u[0]), parseFloat(u[1])])
    },
    affectorNodesParse: function(a, b, c) {
        for (var d in a) {
            var e = a[d];
            b.affectorNodeParse(e, b, c)
        }
    },
    affectorNodeParse: function(a, b, c) {
        var d = JSONJS.getAttributeNodeValue(a, "type"),
            e = c.addAffector(d);
        switch (e.mGroupId = c.mGroupId, d) {
            case "LinearForce":
                var f = JSONJS.getAttributeNodeValue(a, "force_vector"),
                    g = JSONJS.getAttributeNodeValue(a, "force_application");
                f && e.setForceVector(b.parseVec3(f)), g && ("averag" == g ? e.setForceApplication(0) : "add" == g ? e.setForceApplication(1) : "product" == g && e.setForceApplication(2));
                break;
            case "Rotator":
                var h = JSONJS.getAttributeNodeValue(a, "rotation_speed_range_start"),
                    i = JSONJS.getAttributeNodeValue(a, "rotation_speed_range_end"),
                    j = JSONJS.getAttributeNodeValue(a, "rotation_range_start"),
                    k = JSONJS.getAttributeNodeValue(a, "rotation_range_end"),
                    l = JSONJS.getAttributeNodeValue(a, "is_sync_with_direction");
                if (h && e.setRotationSpeedRangeStart(parseFloat(h)), i && e.setRotationSpeedRangeEnd(parseFloat(i)), j && e.setRotationRangeStart(parseFloat(j)), k && e.setRotationRangeEnd(parseFloat(k)), l) {
                    var m = b.parseBool(l);
                    e.enableSyncWithDirection(m)
                }
                break;
            case "Scaler":
                var n = JSONJS.getAttributeNodeValue(a, "rate"),
                    o = JSONJS.getAttributeNodeValue(a, "width_rate"),
                    p = JSONJS.getAttributeNodeValue(a, "height_rate");
                n && e.setAdjust(parseFloat(n)), o && e.setWidthAdjust(parseFloat(o)), p && e.setHeightAdjust(parseFloat(p));
                break;
            case "ColourInterpolator":
                for (var q = 0;; q++) {
                    var r = JSONJS.getAttributeNodeValue(a, "time" + q),
                        s = JSONJS.getAttributeNodeValue(a, "colour" + q);
                    if (!r || !s) break;
                    if (r && e.setTimeAdjust(q, parseFloat(r)), s) {
                        var m = b.parseColour(s);
                        e.setColourAdjust(q, m)
                    }
                }
                break;
            case "Texture":
                var t = JSONJS.getAttributeNodeValue(a, "min_texcoord_index"),
                    u = JSONJS.getAttributeNodeValue(a, "max_texcoord_index"),
                    v = JSONJS.getAttributeNodeValue(a, "delta_time"),
                    w = JSONJS.getAttributeNodeValue(a, "texture_affect_mode"),
                    x = JSONJS.getAttributeNodeValue(a, "from_time"),
                    y = JSONJS.getAttributeNodeValue(a, "to_time");
                if (t && e.setMinTexcoordIndex(parseFloat(t)), u && e.setMaxTexcoordIndex(parseFloat(u)), v && e.setDeltaTime(parseFloat(v)), w) {
                    var m = w.toLowerCase();
                    0 == m.localeCompare("all") ? e.setTextureAffectMode(ALL_TIME) : 0 == m.localeCompare("part") && e.setTextureAffectMode(PART_TIME)
                }
                x && e.setFromTime(parseFloat(x)), y && e.setToTime(parseFloat(y));
                break;
            case "RandomCurveAffector":
                var z = JSONJS.getAttributeNodeValue(a, "scaled_x"),
                    A = JSONJS.getAttributeNodeValue(a, "scaled_y"),
                    B = JSONJS.getAttributeNodeValue(a, "scaled_z"),
                    C = JSONJS.getAttributeNodeValue(a, "scale_fixed"),
                    D = JSONJS.getAttributeNodeValue(a, "scale_factor"),
                    E = JSONJS.getAttributeNodeValue(a, "active_mode");
                if (z && e.setScaledX(parseFloat(z)), A && e.setScaledY(parseFloat(A)), B && e.setScaledZ(parseFloat(B)), C) {
                    var m = b.parseBool(C);
                    e.enableScaleFixed(m)
                }
                if (D && e.setScaleFactor(parseFloat(D)), E) {
                    var m = E.toLowerCase();
                    e.setActiveMode(E)
                }
                break;
            case "DirectionRandomiserAffector":
                var F = JSONJS.getAttributeNodeValue(a, "randomness"),
                    G = JSONJS.getAttributeNodeValue(a, "scope"),
                    H = JSONJS.getAttributeNodeValue(a, "keep_velocity");
                if (F && e.setRandomness(parseFloat(F)), G && e.setScope(parseFloat(G)), H) {
                    var m = b.parseBool(H);
                    e.setKeepVelocity(m)
                }
        }
    },
    emitterNodesParse: function(a, b, c) {
        for (var d in a) {
            var e = a[d];
            b.emitterNodeParse(e, b, c)
        }
    },
    emitterNodeParse: function(a, b, c) {
        var d = JSONJS.getAttributeNodeValue(a, "type"),
            e = JSONJS.getAttributeNodeValue(a, "name"),
            f = JSONJS.getAttributeNodeValue(a, "position"),
            g = JSONJS.getAttributeNodeValue(a, "position_factor"),
            h = JSONJS.getAttributeNodeValue(a, "position_x_factor"),
            i = JSONJS.getAttributeNodeValue(a, "position_y_factor"),
            j = JSONJS.getAttributeNodeValue(a, "direction"),
            k = JSONJS.getAttributeNodeValue(a, "angle"),
            l = JSONJS.getAttributeNodeValue(a, "emission_rate"),
            m = JSONJS.getAttributeNodeValue(a, "time_to_live"),
            n = JSONJS.getAttributeNodeValue(a, "time_to_live_min"),
            o = JSONJS.getAttributeNodeValue(a, "time_to_live_max"),
            p = JSONJS.getAttributeNodeValue(a, "tex_coord_index"),
            q = JSONJS.getAttributeNodeValue(a, "min_tex_coord_index"),
            r = JSONJS.getAttributeNodeValue(a, "max_tex_coord_index"),
            s = JSONJS.getAttributeNodeValue(a, "velocity"),
            t = JSONJS.getAttributeNodeValue(a, "velocity_min"),
            u = JSONJS.getAttributeNodeValue(a, "velocity_max"),
            v = JSONJS.getAttributeNodeValue(a, "colour"),
            w = JSONJS.getAttributeNodeValue(a, "colour_range_start"),
            x = JSONJS.getAttributeNodeValue(a, "colour_range_end"),
            y = JSONJS.getAttributeNodeValue(a, "duration"),
            z = JSONJS.getAttributeNodeValue(a, "duration_min"),
            A = JSONJS.getAttributeNodeValue(a, "duration_max"),
            B = JSONJS.getAttributeNodeValue(a, "repeat_delay"),
            C = JSONJS.getAttributeNodeValue(a, "repeat_delay_min"),
            D = JSONJS.getAttributeNodeValue(a, "repeat_delay_max"),
            E = JSONJS.getAttributeNodeValue(a, "max_width"),
            F = JSONJS.getAttributeNodeValue(a, "max_height"),
            G = JSONJS.getAttributeNodeValue(a, "max_size_fixed"),
            H = JSONJS.getAttributeNodeValue(a, "max_size_factor"),
            I = JSONJS.getAttributeNodeValue(a, "width"),
            J = JSONJS.getAttributeNodeValue(a, "height"),
            K = JSONJS.getAttributeNodeValue(a, "depth"),
            L = JSONJS.getAttributeNodeValue(a, "range_fixed"),
            M = JSONJS.getAttributeNodeValue(a, "range_factor"),
            N = JSONJS.getAttributeNodeValue(a, "width_range_factor"),
            O = JSONJS.getAttributeNodeValue(a, "height_range_factor"),
            P = JSONJS.getAttributeNodeValue(a, "depth_range_factor"),
            Q = null;
        if (d && (Q = c.addEmitter(d), Q.mGroupId = c.mGroupId, Q.mType = d), e && Q.setName(e), f) {
            var R = b.parseVec3(f);
            Q.setPosition(R.x, R.y, R.z)
        }
        if (g && Q.setPositionFactor(parseFloat(g)), h && Q.setPositionXFactor(parseFloat(h)), i && Q.setPositionYFactor(parseFloat(i)), j) {
            var S = b.parseVec3(j);
            Q.setDirection(S)
        }
        if (k && Q.setAngle(parseFloat(k)), l && Q.setEmissionRate(parseFloat(l)), m && Q.setTimeToLive(parseFloat(m)), n && Q.setMinTimeToLive(parseFloat(n)), o && Q.setMaxTimeToLive(parseFloat(o)), p && Q.setTexcoordIndex(parseInt(p)), q && Q.setMinTexcoordIndex(parseInt(q)), r && Q.setMaxTexcoordIndex(parseInt(r)), s && Q.setParticleVelocity(parseFloat(s)), t && Q.setMinParicleVelocity(parseFloat(t)), u && Q.setMaxParicleVelocity(parseFloat(u)), v) {
            var T = b.parseColour(v);
            Q.setColour(T)
        }
        if (w) {
            var T = b.parseColour(w);
            Q.setColourRangeStart(T)
        }
        if (x) {
            var T = b.parseColour(x);
            Q.setColourRangeEnd(T)
        }
        if (y && Q.setDuration(parseFloat(y)), z && Q.setMinDuration(parseFloat(z)), A && Q.setMaxDuration(parseFloat(A)), B && Q.setRepeatDelay(parseFloat(B)), C && Q.setMinRepeatDelay(parseFloat(C)), D && Q.setMaxRepeatDelay(parseFloat(D)), E && Q.setMaxWidth(parseFloat(E)), F && Q.setMaxHeight(parseFloat(F)), G) {
            var U = b.parseBool(G);
            Q.enableMaxSizeFixed(U)
        }
        if (H && Q.setMaxSizeFactor(parseFloat(H)), I && Q instanceof AreaEmitter && Q.setWidth(parseFloat(I)), J && Q instanceof AreaEmitter && Q.setHeight(parseFloat(J)), K && Q instanceof AreaEmitter && Q.setDepth(parseFloat(K)), L && Q instanceof AreaEmitter) {
            var U = b.parseBool(L);
            Q.enableRangeFixed(U)
        }
        M && Q instanceof AreaEmitter && Q.setRangeFactor(parseFloat(M)), N && Q instanceof AreaEmitter && Q.setXRangeFactor(parseFloat(N)), O && Q instanceof AreaEmitter && Q.setYRangeFactor(parseFloat(O)), P && Q instanceof AreaEmitter && Q.setZRangeFactor(parseFloat(P))
    }
};
var UVSParse = function(a) {
    this.src = "", this.mRoot = a, this.assetNameKey = "texture", this.imgUVSKey = "images", this.mUVSFloatRectMap = {}
};
UVSParse.prototype = {
    constructor: UVSParse,
    load: function(a) {
        this.mRoot.mArchive.textLoad(this.src, this.parseScript, a.mPrefix, this)
    },
    parseScript: function(a, b) {
        for (var c = a.split("\r\n"), d = "", e = -1, f = -1, g = 0; g < c.length; g++) {
            var h = c[g];
            if (0 !== h.length) {
                var i = h.split(" = ");
                switch (i[0]) {
                    case "btx":
                        break;
                    case "texture.assetname":
                        b.assetNameKey = i[1];
                        break;
                    case "texture.width":
                    case "texture.width ":
                        e = parseFloat(i[1]);
                        break;
                    case "texture.height":
                        f = parseFloat(i[1]);
                        break;
                    case "image.assetname":
                        d = i[1];
                        break;
                    case "image.uvs":
                        for (var j = i[1], k = j.split(" "), l = k.length - 1; l >= 0; l--) k[l] = parseFloat(k[l]);
                        var m = {
                            left: k[0],
                            right: k[4],
                            top: 1 - k[1],
                            bottom: 1 - k[5]
                        };
                        b.mUVSFloatRectMap[d] = m;
                        break;
                    case "image.rotated":
                        break;
                    case "image.trimmed":
                        break;
                    case "image.origsize":
                        break;
                    case "image.offset":
                        break;
                    case "image.trimmedsize":
                        break;
                    default:
                        console.info("Warnning: Maybe error")
                }
            }
        }
        b.mRoot.debug && console.log(b.mUVSFloatRectMap)
    },
    getUVSRect: function(a) {
        for (var b in this.mUVSFloatRectMap)
            if (0 == b.localeCompare(a)) return this.mUVSFloatRectMap[b];
        return null
    }
}, MeshParseInst = function(a) {
    this.mRoot = a, this.offset = 0, this.src = ""
}, MeshParseInst.prototype = {
    Read16: function() {
        if (this.byteLength < 1 + this.offset) return void 0;
        var a = this.dView.getUint8(this.offset++),
            b = this.dView.getUint8(this.offset++),
            c = b << 8 | a;
        return c
    },
    Read32: function() {
        if (this.byteLength < 3 + this.offset) return void 0;
        var a = this.dView.getUint8(this.offset++),
            b = this.dView.getUint8(this.offset++),
            c = this.dView.getUint8(this.offset++),
            d = this.dView.getUint8(this.offset++),
            e = d << 24 | c << 16 | b << 8 | a;
        return e
    },
    ReadName: function() {
        return this.Read32()
    },
    ReadLen: function() {
        return this.Read32()
    },
    ReadMark: function(a) {
        var b, c;
        return void 0 === (b = this.ReadName()) ? !1 : void 0 === (c = this.ReadLen()) ? !1 : (a.nName = b, a.nLen = c, !0)
    },
    ReadMeshName: function(a) {
        if (0 >= a || this.byteLength < this.offset + a) return void 0;
        var b = String.fromCharCode.apply(null, new Uint8Array(this.binaryBuff, this.offset, a));
        return this.offset = this.offset + a, b
    },
    ReadNumbers: function(a) {
        if (0 >= a || this.byteLength < this.offset + a) return void 0;
        var b = String.fromCharCode.apply(null, new Uint8Array(this.binaryBuff, this.offset, a));
        this.offset = this.offset + a;
        for (var c = b.split(" "), d = [], e = 0; e < c.length; e++) d.push(parseFloat(c[e]));
        return d
    },
    ReadMesh: function() {
        for (var a, b, c = "", d = {}, e = new Array, f = -1, g = -1, h = -1, i = null, j = null, k = null, l = null, m = -1, n = -1, o = null, p = null, q = -1, r = -1, s = null, t = -1; this.ReadMark(d);) switch (a = d.nName, b = d.nLen, a) {
            case ePODFileMesh | PVRTMODELPOD_TAG_END:
                return;
            case ePODFileMeshName:
                if (c = this.ReadMeshName(b), void 0 == c) return !1;
                c = e3d.trim0(c), i = new VertexData(this.mRoot.getHardwareBufferManager()), j = new IndexData(this.mRoot.getHardwareBufferManager()), k = i.vertexDeclaration, l = i.vertexBufferBinding;
                break;
            case ePODFileMeshBounds:
                e = this.ReadNumbers(b);
                break;
            case ePODFileMeshNumVtx:
                f = this.Read32(), i.vertexCount = f, i.vertexStart = 0;
                break;
            case ePODFileMeshNumFaces:
                m = this.Read32(), j.indexCount = 3 * m, j.indexStart = 0;
                break;
            case ePODFileMeshNumNorms:
                h = this.Read32();
                break;
            case ePODFileMeshNumUVW:
                n = this.Read32();
                break;
            case ePODFileMeshInterleaved:
                if (0 > f) return !1;
                var u = 0;
                if (k.addElement(0, u, VET_FLOAT3, VES_POSITION), u += VertexElement.getTypeSize(VET_FLOAT3), k.addElement(0, u, VET_FLOAT3, VES_NORMAL), u += VertexElement.getTypeSize(VET_FLOAT3), n > 0 && (k.addElement(0, u, VET_FLOAT2, VES_TEXTURE_COORDINATES, 0), u += VertexElement.getTypeSize(VET_FLOAT2)), g > 0 && (k.addElement(0, u, VET_COLOUR, VES_DIFFUSE), u += VertexElement.getTypeSize(VET_COLOUR)), r > 0)
                    if (t > 0 && 4 >= t) {
                        var v = t - 1;
                        k.addElement(0, u, v, VES_BLEND_INDICES, 0), u += VertexElement.getTypeSize(v), k.addElement(0, u, v, VES_BLEND_WEIGHTS, 0), u += VertexElement.getTypeSize(v)
                    } else console.log("tag_error:bonesPerVertex parse error: meshName=" + c + " numBonesPerVertex=" + t);
                var w = !0,
                    x = this.mRoot.getHardwareBufferManager().createVertexBuffer(k.getVertexSize(0), i.vertexCount, w ? HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE : HBU_STATIC_WRITE_ONLY);
                x.createDataBuffer(this.binaryBuff, this.offset), this.offset += x.mSizeInBytes, l.setBinding(0, x);
                x.lock();
                x.unlock();
                var y = new Mesh(this.mRoot);
                if (6 == e.length && (y.box_ab = {}, y.box_ab.min = new Vector3(e[0], e[1], e[2]), y.box_ab.max = new Vector3(e[3], e[4], e[5])), r > 0)
                    for (var z = 0; q > z; ++z) {
                        for (var A = p[z], B = y.createSubMesh(), C = 0; A > C; ++C) {
                            var D = o[z * r + C];
                            null == B.mBoneIdList && (B.mBoneIdList = []), null == y.mBoneIdList && (y.mBoneIdList = []), B.mBoneIdList.push(D), y.mBoneIdList.push(D)
                        }
                        var E;
                        E = q > z + 1 ? s[z + 1] - s[z] : m - s[z];
                        var F = 3 * s[z];
                        if (B.indexData && (B.indexData = null), B.useSharedVertices = !0, y.sharedVertexData = i, m > 0) {
                            var G = new IndexData(this.mRoot.getHardwareBufferManager());
                            G.indexStart = F, G.indexCount = 3 * E, G.indexBuffer = this.mRoot.getHardwareBufferManager().createIndexBuffer(IT_16BIT, G.indexCount, HBU_STATIC_WRITE_ONLY), G.indexBuffer.createDataBuffer();
                            for (var H = G.indexBuffer.lock(), I = j.indexBuffer.lock(), J = 0, K = G.indexStart; K < G.indexCount + G.indexStart; K++) H[J] = I[K], J++;
                            G.indexBuffer.unlock(), B.indexData = G, B.mBoneCount = t
                        }
                        B.operationType = RenderOperation.OT_TRIANGLE_LIST
                    } else {
                        var B = y.createSubMesh();
                        B.vertexData = i, B.indexData = j, B.operationType = RenderOperation.OT_TRIANGLE_LIST
                    }
                this.mRoot.mMeshMap[c] = y;
                break;
            case ePODFileMeshFaces:
                if (0 > m) return !1;
                break;
            case ePODFileData:
                j.indexBuffer = this.mRoot.getHardwareBufferManager().createIndexBuffer(IT_16BIT, j.indexCount, HBU_STATIC_WRITE_ONLY), j.indexBuffer.createDataBuffer(this.binaryBuff, this.offset), this.offset = this.offset + j.indexBuffer.mSizeInBytes;
                var H = j.indexBuffer.lock();
                j.indexBuffer.unlock();
                break;
            case ePODFileMeshBoneBatchBoneMax:
                r = this.Read32();
                break;
            case ePODFileMeshNumBonesPerVertex:
                if (r > 0) {
                    if (t = this.Read32(), 0 > t) return !1
                } else if (!this.skip(b)) return !1;
                break;
            case ePODFileMeshBoneBatchCnt:
                if (r > 0) {
                    if (q = this.Read32(), 0 > q) return !1
                } else if (!this.skip(b)) return !1;
                break;
            case ePODFileMeshBoneBatches:
                if (r > 0) {
                    if (o = this.readAsArrayBuffer(this.binaryBuff, b), !q) return !1
                } else if (!this.skip(b)) return !1;
                break;
            case ePODFileMeshBoneBatchBoneCnts:
                if (r > 0) {
                    if (p = this.readAsArrayBuffer(this.binaryBuff, b), !p) return !1
                } else if (!this.skip(b)) return !1;
                break;
            case ePODFileMeshBoneBatchOffsets:
                if (r > 0) {
                    if (s = this.readAsArrayBuffer(this.binaryBuff, b), !s) return !1
                } else if (!this.skip(b)) return !1;
                break;
            default:
                if (!this.skip(b)) return !1
        }
    },
    exportPodMesh: function(a) {
        this.binaryBuff = a, this.dView = new DataView(a), this.byteLength = this.binaryBuff.byteLength;
        for (var b, c, d = {}; this.ReadMark(d);) switch (b = d.nName, c = d.nLen, b) {
            case ePODFileScene | PVRTMODELPOD_TAG_END:
                return !0;
            case ePODFileMesh:
                !this.ReadMesh();
                break;
            default:
                if (!this.skip(c)) return !1
        }
    },
    readAsArrayBuffer: function(a, b) {
        var c = a.slice(this.offset, this.offset + b),
            d = new Uint32Array(c, 0, b / 4);
        return this.offset = this.offset + b, d
    },
    skip: function(a) {
        return this.offset += a, this.offset > this.byteLength ? !1 : !0
    }
};
var EMeshParse = function(a, b) {
    this.mRoot = a, this.src = ""
};
EMeshParse.prototype = {
    constructor: EMeshParse,
    load: function(a) {
        var b = new MeshParseInst(this.mRoot);
        this.mRoot.mArchive.binaryLoad(this.src, function(a) {
            b.exportPodMesh(a)
        }, a.mPrefix)
    }
};
var PVRTMODELPOD_TAG_MASK = 2147483648,
    PVRTMODELPOD_TAG_START = 0,
    PVRTMODELPOD_TAG_END = 2147483648,
    ePODFileVersion = 1e3,
    ePODFileScene = 1001,
    ePODFileExpOpt = 1002,
    ePODFileHistory = 1003,
    ePODFileEndiannessMisMatch = -402456576,
    ePODFileColourBackground = 2e3,
    ePODFileColourAmbient = 2001,
    ePODFileNumCamera = 2002,
    ePODFileNumLight = 2003,
    ePODFileNumMesh = 2004,
    ePODFileNumNode = 2005,
    ePODFileNumMeshNode = 2006,
    ePODFileNumTexture = 2007,
    ePODFileNumMaterial = 2008,
    ePODFileNumFrame = 2009,
    ePODFileCamera = 2010,
    ePODFileLight = 2011,
    ePODFileMesh = 2012,
    ePODFileNode = 2013,
    ePODFileTexture = 2014,
    ePODFileMaterial = 2015,
    ePODFileFlags = 2016,
    ePODFileFPS = 2017,
    ePODFileUserData = 2018,
    ePODFileMatName = 3e3,
    ePODFileMatIdxTexDiffuse = 3001,
    ePODFileMatOpacity = 3002,
    ePODFileMatAmbient = 3003,
    ePODFileMatDiffuse = 3004,
    ePODFileMatSpecular = 3005,
    ePODFileMatShininess = 3006,
    ePODFileMatEffectFile = 3007,
    ePODFileMatEffectName = 3008,
    ePODFileMatIdxTexAmbient = 3009,
    ePODFileMatIdxTexSpecularColour = 3010,
    ePODFileMatIdxTexSpecularLevel = 3011,
    ePODFileMatIdxTexBump = 3012,
    ePODFileMatIdxTexEmissive = 3013,
    ePODFileMatIdxTexGlossiness = 3014,
    ePODFileMatIdxTexOpacity = 3015,
    ePODFileMatIdxTexReflection = 3016,
    ePODFileMatIdxTexRefraction = 3017,
    ePODFileMatBlendSrcRGB = 3018,
    ePODFileMatBlendSrcA = 3019,
    ePODFileMatBlendDstRGB = 3020,
    ePODFileMatBlendDstA = 3021,
    ePODFileMatBlendOpRGB = 3022,
    ePODFileMatBlendOpA = 3023,
    ePODFileMatBlendColour = 3024,
    ePODFileMatBlendFactor = 3025,
    ePODFileMatFlags = 3026,
    ePODFileMatUserData = 3027,
    ePODFileTexName = 4e3,
    ePODFileNodeIdx = 5e3,
    ePODFileNodeName = 5001,
    ePODFileNodeIdxMat = 5002,
    ePODFileNodeIdxParent = 5003,
    ePODFileNodePos = 5004,
    ePODFileNodeRot = 5005,
    ePODFileNodeScale = 5006,
    ePODFileNodeAnimPos = 5007,
    ePODFileNodeAnimRot = 5008,
    ePODFileNodeAnimScale = 5009,
    ePODFileNodeMatrix = 5010,
    ePODFileNodeAnimMatrix = 5011,
    ePODFileNodeAnimFlags = 5012,
    ePODFileNodeAnimPosIdx = 5013,
    ePODFileNodeAnimRotIdx = 5014,
    ePODFileNodeAnimScaleIdx = 5015,
    ePODFileNodeAnimMatrixIdx = 5016,
    ePODFileNodeUserData = 5017,
    ePODFileMeshNumVtx = 6e3,
    ePODFileMeshNumFaces = 6001,
    ePODFileMeshNumUVW = 6002,
    ePODFileMeshFaces = 6003,
    ePODFileMeshStripLength = 6004,
    ePODFileMeshNumStrips = 6005,
    ePODFileMeshVtx = 6006,
    ePODFileMeshNor = 6007,
    ePODFileMeshTan = 6008,
    ePODFileMeshBin = 6009,
    ePODFileMeshUVW = 6010,
    ePODFileMeshVtxCol = 6011,
    ePODFileMeshBoneIdx = 6012,
    ePODFileMeshBoneWeight = 6013,
    ePODFileMeshInterleaved = 6014,
    ePODFileMeshBoneBatches = 6015,
    ePODFileMeshBoneBatchBoneCnts = 6016,
    ePODFileMeshBoneBatchOffsets = 6017,
    ePODFileMeshBoneBatchBoneMax = 6018,
    ePODFileMeshBoneBatchCnt = 6019,
    ePODFileMeshUnpackMatrix = 6020,
    ePODFileMeshName = 6021,
    ePODFileMeshBounds = 6022,
    ePODFileMeshNumVtxCol = 6023,
    ePODFileMeshStrideLen = 6024,
    ePODFileMeshNumBonesPerVertex = 6025,
    ePODFileMeshNumNorms = 6026,
    ePODFileLightIdxTgt = 7e3,
    ePODFileLightColour = 7001,
    ePODFileLightType = 7002,
    ePODFileLightConstantAttenuation = 7003,
    ePODFileLightLinearAttenuation = 7004,
    ePODFileLightQuadraticAttenuation = 7005,
    ePODFileLightFalloffAngle = 7006,
    ePODFileLightFalloffExponent = 7007,
    ePODFileCamIdxTgt = 8e3,
    ePODFileCamFOV = 8001,
    ePODFileCamFar = 8002,
    ePODFileCamNear = 8003,
    ePODFileCamAnimFOV = 8004,
    ePODFileDataType = 9e3,
    ePODFileN = 9001,
    ePODFileStride = 9002,
    ePODFileData = 9003,
    ePODFileKeyFrame = 1e4,
    ePODFileKeyFrameNum = 10001,
    ePODFileKeyFrameName = 10002,
    ePODFileKeyFrameData = 10003,
    filter_syntax = {
        st_ifdef: 0,
        st_else: 1,
        st_end: 2,
        st_define: 3,
        st_Not: 4
    },
    filter_process = function() {
        this.stack = [], this.content = [], this.result = "", this.currentMacro = null, this.definedMacros = []
    };
filter_process.prototype = {
    constructor: filter_process,
    process: function(a) {
        this.content = a.split("\n");
        var b = null,
            c = !1;
        for (var d in this.content) {
            var e = this.getSyntaxAndMacro(this.content[d]);
            switch (e.syntax) {
                case filter_syntax.st_ifdef:
                    var f = {
                        lineNum: d,
                        macro: e.macro,
                        isdefine: !0
                    };
                    c = this.isDefined(e.macro), this.stack.push(f), b = f;
                    break;
                case filter_syntax.st_else:
                    var g = this.stack.pop(),
                        f = {
                            lineNum: d,
                            macro: g.macro,
                            isdefine: !1
                        };
                    c = this.isDefined(g.macro), this.stack.push(f), b = f;
                    break;
                case filter_syntax.st_end:
                    this.stack.pop(), b = this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
                    break;
                case filter_syntax.st_define:
                    this.definedMacros.push(e.macro);
                    break;
                case filter_syntax.st_Not:
                    b && c != b.isdefine || (this.result += this.content[d], this.result += "\n");
                    break;
                default:
                    console.log("unknown syntax")
            }
        }
    },
    isDefined: function(a) {
        for (var b in this.definedMacros)
            if (a == this.definedMacros[b]) return !0;
        return !1
    },
    getSyntaxAndMacro: function(a) {
        var b = {};
        b.syntax = null, b.macro = null;
        var c = RegExp("#ifdef|#if defined", "g"),
            d = RegExp("#else"),
            e = RegExp("#endif"),
            f = RegExp("#define");
        return c.test(a) ? (b.syntax = filter_syntax.st_ifdef, b.macro = a.replace(c, "")) : d.test(a) ? b.syntax = filter_syntax.st_else : e.test(a) ? b.syntax = filter_syntax.st_end : f.test(a) ? (b.syntax = filter_syntax.st_define, b.macro = a.replace(f, "")) : b.syntax = filter_syntax.st_Not, b.macro && (b.macro = b.macro.replace(/[\r\(\)\ ]+/g, "")), b
    }
};
var ShaderPrecision = {
        SP_LOWP: 0,
        SP_MEDIUMP: 1,
        SP_HIGHP: 2
    },
    ShaderType = {
        ST_SURFACE: 0,
        ST_PHONG: 1,
        ST_GOURAUD: 2,
        ST_LAMBERT: 3,
        ST_BLINN: 4
    },
    MaterialAutoBuildParameters = function() {
        this.type = "surface", this.color = "", this.colorMap = "", this.alpha = "", this.alphaMap = "", this.ambient = "", this.diffuse = "", this.emissive = "", this.specular = "", this.shininess = "", this.bumpMap = "", this.depth_write = "true", this.depth_check = "true", this.use_vertex_color = "false", this.uv_ani = "false", this.alpha_ani = "false", this.texture_address_mode = "clamp", this.texture_filter = "bilinear", this.culling_mode = "anticlockwise", this.blend_mode = "src_alpha one_minus_src_alpha", this.precision_float = "highp", this.precision_int = "highp", this.isSkin = "false", this.doubleRender = !1, this.requireSkinNormal = "false", this.envMap = "", this.refStrength = 0, this.videosrc = "", this.uv_repeat = ""
    };
MaterialAutoBuildParameters.prototype = {
    constructor: MaterialAutoBuildParameters
};
var ShaderConstructParameters = function() {
    this.shaderType = ShaderType, this.colorMap = "", this.bUVAnim = !1, this.bUseVertexColor = !1, this.bColorModifier = !1, this.alphaMap = "", this.intPrecision = ShaderPrecision.SP_MEDIUMP, this.floatPrecision = ShaderPrecision.SP_MEDIUMP, this.isSkin = !1, this.requireSkinNormal = !1, this.doubleRender = !1, this.envMap = "", this.refStrength = 0, this.uv_repeat = !1
};
ShaderConstructParameters.prototype = {
    constructor: ShaderConstructParameters
};
var ShaderContent = function() {
    this.vertexProgramName = "", this.vertexDefaultParams = [], this.vertexShader = "", this.fragmentProgramName = "", this.fragmentDefaultParams = [], this.fragmentShader = ""
};
ShaderContent.prototype = {
    constructor: ShaderContent
};
var default_params = function() {
    this.pn_type = "", this.name = "", this.type = "", this.value = "", this.extra_info = ""
};
default_params.prototype = {
    constructor: default_params
};
var ParamsWithMacro = function() {
    this.MACRO = "", this.params = new default_params
};
ParamsWithMacro.prototype = {
    constructor: ParamsWithMacro
};
var ShaderElement = function() {
    this.vertexDefaultParams = [], this.vertexPars = "", this.vertexLogic = "", this.fragmentDefaultParams = [], this.fragmentPars = "", this.fragmentLogic = ""
};
ShaderElement.prototype = {
    constructor: ShaderElement
};
var MaterialBuilder = {};
MaterialBuilder.mShaderChunks = {}, MaterialBuilder._initShaderChunks = function() {
    MaterialBuilder.mShaderChunks.VERTEX_PARS_common = "attribute vec3 inPosition;\nattribute vec2 inTexCoord;\nattribute vec4 inColor;\nattribute vec3 inNormal;\n#if defined(SKIN_)\nuniform int boneCount;\nuniform mat4 boneMatrixArray[8];\nattribute mediump vec4 inBoneIndex;\nattribute mediump vec4 inBoneWeight;\n#endif\n#if defined(SKIN_NORMAL)\nuniform mat3 boneMatrixArrayIT[8];\n#endif\n#if defined(ENV_MAP)\nuniform float refStrength;\nvarying vec4 RelectDir;\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_PARS_pos_worldViewProj = "uniform mat4 worldViewProj;\n", MaterialBuilder.mShaderChunks.VERTEX_pos_base = "gl_Position = vec4(inPosition, 1.0);\n", MaterialBuilder.mShaderChunks.VERTEX_pos_worldViewProj = "gl_Position = worldViewProj * gl_Position;\n", MaterialBuilder.mShaderChunks.VERTEX_skin = "#if defined(SKIN_)\nmediump ivec4 boneIndex = ivec4(inBoneIndex);\nvec4 position = vec4(inPosition, 1.0);\nvTexCoord.xy = inTexCoord.xy;\nif(boneCount>0){\n   gl_Position=boneMatrixArray[boneIndex.x]*position*inBoneWeight.x;\n}\nif(boneCount>1){\n   gl_Position=gl_Position+boneMatrixArray[boneIndex.y]*position*inBoneWeight.y;\n}\nif(boneCount>2){\ngl_Position=gl_Position+boneMatrixArray[boneIndex.z]*position*inBoneWeight.z;\n}\nif(boneCount>3){\ngl_Position=gl_Position+boneMatrixArray[boneIndex.w]*position*inBoneWeight.w;\n}\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_normal_skin = "#if defined(SKIN_NORMAL)\nmat3 skinMatIT=mat3(0.0);\nif(boneCount>0){\n    skinMatIT=boneMatrixArrayIT[boneIndex.x]*inBoneWeight.x;\n}\nif(boneCount>1){\n    skinMatIT=skinMatIT+boneMatrixArrayIT[boneIndex.y]*inBoneWeight.y;\n}\nif(boneCount>2){\n    skinMatIT=skinMatIT+boneMatrixArrayIT[boneIndex.z]*inBoneWeight.z;\n}\nif(boneCount>3){\n    skinMatIT=skinMatIT+boneMatrixArrayIT[boneIndex.w]*inBoneWeight.w;\n}\nvNormal=skinMatIT*inNormal;\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_normal_base = "vNormal=inNormal.xyz;\n", MaterialBuilder.mShaderChunks.VERTEX_normal_light = "vec4 dn=normalMatrix * vec4(vNormal, 0.0);\nvNormal = normalize(dn.xyz/dn.w);\n", MaterialBuilder.mShaderChunks.VERTEX_PARS_texCoord = "varying vec2 vTexCoord;\n#if defined( UV_ANI )\n	uniform mat4 textureMatrix;\n#endif\n#if defined( UV_REPEAT)\n  uniform vec2 uv_repeat;\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_texCoord = "vTexCoord = inTexCoord;\n#if defined( UV_REPEAT)\nvTexCoord.x = inTexCoord.x*uv_repeat.x;\nvTexCoord.y = inTexCoord.y*uv_repeat.y;\n#endif\n#if defined( UV_ANI )\n	vec4 texCoord4;\n	texCoord4 = textureMatrix * vec4(vTexCoord, 0.0, 1.0);\n	vTexCoord = texCoord4.xy;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_PARS_texCoord = "varying vec2 vTexCoord;\n", MaterialBuilder.mShaderChunks.FRAGMENT_base = "gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n", MaterialBuilder.mShaderChunks.FRAGMENT_PARS_colorMap = "#if defined( COLOR_MAP )\n	uniform sampler2D colorMap;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_colorMap = "#if defined( COLOR_MAP )\n	gl_FragColor *= texture2D(colorMap, vTexCoord);\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_PARS_vertexColor = "#if defined( VERTEX_COLOR )\n	varying vec4 vColor;\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_vertexColor = "#if defined( VERTEX_COLOR )\n	vColor = vec4(inColor.r / 255.0, inColor.g / 255.0, inColor.b / 255.0, inColor.a / 255.0);\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_PARS_vertexColor = "#if defined( VERTEX_COLOR )\n	varying vec4 vColor;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_vertexColor = "#if defined( VERTEX_COLOR )\n	gl_FragColor *= vColor;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_PARS_colorModifier = "#if defined( COLOR_MODIFIER )\n	uniform vec4 colorModifier;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_colorModifier = "#if defined( COLOR_MODIFIER )\n	gl_FragColor *= colorModifier;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_PARS_alphaMap = "#if defined( ALPHA_MAP )\n	uniform sampler2D alphaMap;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_alphaMap = "#if defined( ALPHA_MAP )\n	gl_FragColor.a = texture2D(alphaMap, vTexCoord).r;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_PARS_doubleRender = "#if defined( DOUBLE_RENDER )\n	uniform int doubleRender;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_doubleRender = "#if defined( DOUBLE_RENDER )\n	if(doubleRender==0){\n  		if(gl_FragColor.a>0.999){\n			discard;\n		}\n	}else{\n   	if(gl_FragColor.a<0.999){\n			discard;\n		}\n	}\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_PARS_env_normal_surface = "#if defined(ENV_MAP)\nuniform mat4 normalMatrix;\nvarying vec3 vNormal;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_PARS_env_normal_surface = "#if defined(ENV_MAP)\nvarying vec3 vNormal;\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_env_normal_surface = "#if defined(ENV_MAP)\nvec4 dn=normalMatrix * vec4(inNormal, 0.0);\nvNormal = normalize(dn.xyz/dn.w);\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_PARS_env_worldview_surface = "#if defined(ENV_MAP)\nuniform mat4 worldViewMatrix;\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_env_worldview_surface = "#if defined(ENV_MAP)\nvec3 vertexPosition3_viewSpace = (worldViewMatrix * gl_Position).xyz;\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_envMap = "#if defined(ENV_MAP)\nvec3 eyeDir_ref = normalize(vertexPosition3_viewSpace.xyz);\nRelectDir.xyz=normalize(reflect(eyeDir_ref,vNormal).xyz);\nRelectDir.w=refStrength;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_PARS_envMap = "#if defined(ENV_MAP)\nuniform sampler2D envMap;\nvarying vec4 RelectDir;\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_envMap_tex = "#if defined(ENV_MAP)\nvec4 reflectcolor_env=texture2D(envMap,RelectDir.xy*0.5+0.5);\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_envMap_surface = "#if defined(ENV_MAP)\ngl_FragColor.rgb = mix(gl_FragColor.rgb,  reflectcolor_env.rgb, RelectDir.w );\n#endif\n", MaterialBuilder.mShaderChunks.FRAGMENT_envMap_light = "#if defined(ENV_MAP)\ndiffuseColor.rgb = mix(diffuseColor.rgb,  reflectcolor_env.rgb, RelectDir.w );\n#endif\n", MaterialBuilder.mShaderChunks.VERTEX_PARS_gouraud = "uniform mat4 normalMatrix;\nuniform mat4 worldViewMatrix;\nuniform float lightCount;\nuniform float matShiniess;	\nuniform vec4 derivedAmbientLightColor;\nuniform vec4 lightPositionViewSpaceArray[8];\nuniform vec4 lightDirectionViewSpaceArray[8];\nuniform vec4 derivedLightDiffuseColorArray[8];\nuniform vec4 derivedLightSpecularColorArray[8];\nuniform vec4 spotLightParamsArray[8];\nuniform vec4 lightAttenuationArray[8];\nvarying vec4 vColor;\n", MaterialBuilder.mShaderChunks.VERTEX_gouraud = "vec4 vertexPosition4_viewSpace = worldViewMatrix * gl_Position;\nvec3 vertexPosition3_viewSpace = vertexPosition4_viewSpace.xyz;\nvec4 normal4 = normalMatrix * vec4(inNormal, 1.0);\nvec3 vertexNormal = normalize(normal4.xyz / normal4.w);\nvColor = derivedAmbientLightColor;\nint lightMax = int(min(lightCount, 8.0));\nvec3 v = normalize(-vertexPosition3_viewSpace);\nvec3 l;\nvec3 h;\nfloat d;\nvec3 lightDir;\nfloat cosTheta;\nfloat cosInner;\nfloat cosOuter;\nfloat attenuation;\nfloat spotLightFactor;\nfor(int i = 0; i < lightMax; ++i)\n{ 	\n	lightDir = normalize(lightDirectionViewSpaceArray[i].xyz);\n	if (lightPositionViewSpaceArray[i].w == 0.0)\n	{\n		l = -lightDir;\n		spotLightFactor = 1.0;\n		attenuation = 1.0;\n	}\n	else{\n		l = normalize(vec3(lightPositionViewSpaceArray[i] - vertexPosition4_viewSpace));\n		cosTheta = max(dot(-l, lightDir), 0.0);\n		cosInner = spotLightParamsArray[i][0];\n		cosOuter = spotLightParamsArray[i][1];\n		spotLightFactor = clamp((cosTheta-cosOuter)/(cosInner-cosOuter), 0.0, 1.0);\n		if (spotLightFactor == 0.0 && spotLightParamsArray[i][2] == 0.0)\n			spotLightFactor = 1.0;\n		else\n			spotLightFactor = pow(spotLightFactor, spotLightParamsArray[i][2]);\n		d = distance(vertexPosition3_viewSpace, lightPositionViewSpaceArray[i].xyz);\n		if (d < lightAttenuationArray[i][0])\n			attenuation = 1.0 / (lightAttenuationArray[i][1] + lightAttenuationArray[i][2] * d + lightAttenuationArray[i][3] * d * d);\n		else\n			attenuation = 0.0;\n	}\n	h = normalize(v + l);\n	vColor += 	attenuation * \n		spotLightFactor *	\n		(	max(dot(vertexNormal, l), 0.0) * derivedLightDiffuseColorArray[i]; + 	\n		pow(max(dot(vertexNormal, h), 0.0), matShiniess) * derivedLightSpecularColorArray[i]);	\n}	\n", MaterialBuilder.mShaderChunks.FRAGMENT_gouraud = "gl_FragColor *= vColor;\n", MaterialBuilder.mShaderChunks.VERTEX_PARS_phong_blinn = "uniform mat4 normalMatrix;\nuniform mat4 worldViewMatrix;\nvarying vec4 vertexPosition4_viewSpace;\nvarying vec3 vertexPosition3_viewSpace;\n", MaterialBuilder.mShaderChunks.VERTEX_phong_blinn = "vertexPosition4_viewSpace = worldViewMatrix * gl_Position;\nvertexPosition3_viewSpace = vertexPosition4_viewSpace.xyz;\n", MaterialBuilder.mShaderChunks.FRAGMENT_PARS_phong_blinn = "uniform float lightCount;\nuniform float matShiniess;\nuniform vec4 derivedAmbientLightColor;\nuniform vec4 lightPositionViewSpaceArray[8];\nuniform vec4 lightDirectionViewSpaceArray[8];\nuniform vec4 derivedLightDiffuseColorArray[8];\nuniform vec4 derivedLightSpecularColorArray[8];\nuniform vec4 spotLightParamsArray[8];\nuniform vec4 lightAttenuationArray[8];\nvarying vec4 vertexPosition4_viewSpace;\nvarying vec3 vertexPosition3_viewSpace;\n", MaterialBuilder.mShaderChunks.FRAGMENT_phong = "vec4 lightColor = derivedAmbientLightColor;\nint lightMax = int(min(lightCount, 8.0));\nvec3 v = normalize(-vertexPosition3_viewSpace);\nvec3 l;\nvec3 r;\nfloat d;\nvec3 lightDir;\nfloat cosTheta;\nfloat cosInner;\nfloat cosOuter;\nfloat attenuation;\nfloat spotLightFactor;\nfor(int i = 0; i < lightMax; ++i)\n{ 	\n	lightDir = normalize(lightDirectionViewSpaceArray[i].xyz);\n	if (lightPositionViewSpaceArray[i].w == 0.0)	\n	{\n		l = -lightDir;\n		spotLightFactor = 1.0;\n		attenuation = 1.0;\n	}\n	else{	\n		l = normalize(vec3(lightPositionViewSpaceArray[i] - vertexPosition4_viewSpace));\n		cosTheta = max(dot(-l, lightDir), 0.0);\n		cosInner = spotLightParamsArray[i][0];\n		cosOuter = spotLightParamsArray[i][1];\n		spotLightFactor = clamp((cosTheta-cosOuter)/(cosInner-cosOuter), 0.0, 1.0);\n		if (spotLightFactor == 0.0 && spotLightParamsArray[i][2] == 0.0)	\n			spotLightFactor = 1.0;\n		else\n			spotLightFactor = pow(spotLightFactor, spotLightParamsArray[i][2]);\n		d = distance(vertexPosition3_viewSpace, lightPositionViewSpaceArray[i].xyz);\n		if (d < lightAttenuationArray[i][0])\n			attenuation = 1.0 / (lightAttenuationArray[i][1] + lightAttenuationArray[i][2] * d + lightAttenuationArray[i][3] * d * d);\n		else\n			attenuation = 0.0;\n	}\nr = reflect(-l, vNormal);	\nlightColor += 	attenuation *\n	spotLightFactor *\n	(	max(dot(vNormal, l), 0.0) * derivedLightDiffuseColorArray[i] +\n	pow(max(dot(r, v), 0.0), matShiniess) * derivedLightSpecularColorArray[i])	;\n}	\ngl_FragColor *= lightColor;\n", MaterialBuilder.mShaderChunks.FRAGMENT_blinn = "vec4 diffuseColor = derivedAmbientLightColor;\nvec4 specularColor = vec4(0.0);\nint lightMax = int(min(lightCount, 8.0));\nvec3 v = normalize(-vertexPosition3_viewSpace);\nvec3 l;\nvec3 h;\nfloat d;\nvec3 lightDir;\nfloat cosTheta;\nfloat cosInner;\nfloat cosOuter;\nfloat attenuation;\nfloat spotLightFactor;\nfor(int i = 0; i < 8; ++i)\n{ 	\n	if (i >= int(lightCount)) break;\n	lightDir = normalize(lightDirectionViewSpaceArray[i].xyz);\n	if (lightPositionViewSpaceArray[i].w == 0.0)	\n	{\n		l = -lightDir;\n		spotLightFactor = 1.0;\n		attenuation = 1.0;\n	}\n	else{	\n		l = normalize(vec3(lightPositionViewSpaceArray[i] - vertexPosition4_viewSpace));\n		cosTheta = max(dot(-l, lightDir), 0.0);\n		cosInner = spotLightParamsArray[i][0];\n		cosOuter = spotLightParamsArray[i][1];\n		spotLightFactor = clamp((cosTheta-cosOuter)/(cosInner-cosOuter), 0.0, 1.0);\n		if (spotLightFactor == 0.0 && spotLightParamsArray[i][2] == 0.0)	\n			spotLightFactor = 1.0;\n		else\n			spotLightFactor = pow(spotLightFactor, spotLightParamsArray[i][2]);\n		d = distance(vertexPosition3_viewSpace, lightPositionViewSpaceArray[i].xyz);\n		if (d < lightAttenuationArray[i][0])\n			attenuation = 1.0 / (lightAttenuationArray[i][1] + lightAttenuationArray[i][2] * d + lightAttenuationArray[i][3] * d * d);\n		else\n			attenuation = 0.0;\n	}\nh = normalize(v + l);	\ndiffuseColor += 	attenuation *\n	spotLightFactor *\n	(max(dot(vNormal, l), 0.0) * derivedLightDiffuseColorArray[i]);\nspecularColor+=	attenuation *spotLightFactor*( pow(max(dot(vNormal, h), 0.0), matShiniess) * derivedLightSpecularColorArray[i] );\n}	\ndiffuseColor = diffuseColor*gl_FragColor;\nspecularColor = specularColor;\n" + MaterialBuilder.mShaderChunks.FRAGMENT_envMap_light + "gl_FragColor.rgb = (diffuseColor + specularColor).rgb;\n", MaterialBuilder.mShaderChunks.VERTEX_PARS_lambert = "uniform mat4 normalMatrix;\nuniform mat4 worldViewMatrix;\nvarying vec4 vertexPosition4_viewSpace;\nvarying vec3 vertexPosition3_viewSpace;\n", MaterialBuilder.mShaderChunks.VERTEX_lambert = "vertexPosition4_viewSpace = worldViewMatrix * gl_Position;\nvertexPosition3_viewSpace = vertexPosition4_viewSpace.xyz;\n", MaterialBuilder.mShaderChunks.FRAGMENT_PARS_lambert = "uniform float lightCount;\nuniform vec4 derivedAmbientLightColor;\nuniform vec4 lightPositionViewSpaceArray[8];\nuniform vec4 lightDirectionViewSpaceArray[8];\nuniform vec4 derivedLightDiffuseColorArray[8];\nuniform vec4 spotLightParamsArray[8];\nuniform vec4 lightAttenuationArray[8];\nvarying vec4 vertexPosition4_viewSpace;\nvarying vec3 vertexPosition3_viewSpace;\n", MaterialBuilder.mShaderChunks.FRAGMENT_lambert = "vec4 diffuseColor = derivedAmbientLightColor;\nint lightMax = int(min(lightCount, 8.0));\nvec3 v = normalize(-vertexPosition3_viewSpace);\nvec3 l;\nfloat d;\nvec3 lightDir;\nfloat cosTheta;\nfloat cosInner;\nfloat cosOuter;\nfloat attenuation;\nfloat spotLightFactor;\nfor(int i = 0; i < 8; ++i)\n{ 	\n	if (i >= int(lightCount)) break;\n	lightDir = normalize(lightDirectionViewSpaceArray[i].xyz);\n	if (lightPositionViewSpaceArray[i].w == 0.0)	\n	{\n		l = -lightDir;\n		spotLightFactor = 1.0;\n		attenuation = 1.0;\n	}\n	else{	\n		l = normalize(vec3(lightPositionViewSpaceArray[i] - vertexPosition4_viewSpace));\n		cosTheta = max(dot(-l, lightDir), 0.0);\n		cosInner = spotLightParamsArray[i][0];\n		cosOuter = spotLightParamsArray[i][1];\n		spotLightFactor = clamp((cosTheta-cosOuter)/(cosInner-cosOuter), 0.0, 1.0);\n		if (spotLightFactor == 0.0 && spotLightParamsArray[i][2] == 0.0)	\n			spotLightFactor = 1.0;\n		else\n			spotLightFactor = pow(spotLightFactor, spotLightParamsArray[i][2]);\n		d = distance(vertexPosition3_viewSpace, lightPositionViewSpaceArray[i].xyz);\n		if (d < lightAttenuationArray[i][0])\n			attenuation = 1.0 / (lightAttenuationArray[i][1] + lightAttenuationArray[i][2] * d + lightAttenuationArray[i][3] * d * d);\n		else\n			attenuation = 0.0;\n	}\ndiffuseColor += 	attenuation *\n	spotLightFactor *\n	max(dot(vNormal, l), 0.0) * derivedLightDiffuseColorArray[i];\n}	\ndiffuseColor = diffuseColor*gl_FragColor;\n" + MaterialBuilder.mShaderChunks.FRAGMENT_envMap_light + "gl_FragColor = diffuseColor;\n"
}, MaterialBuilder._initShaderChunks(), MaterialBuilder.mShaderLib = {}, MaterialBuilder._initShaderLib = function() {
    MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE] = new ShaderElement;
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "worldViewProj", a.params.type = "", a.params.value = "worldviewproj_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "UV_ANI", a.params.pn_type = "param_named_auto", a.params.name = "textureMatrix", a.params.type = "", a.params.value = "texture_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "SKIN_", a.params.pn_type = "param_named", a.params.name = "boneCount", a.params.type = "int", a.params.value = "4", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "SKIN_", a.params.pn_type = "param_named", a.params.name = "boneMatrixArray", a.params.type = "matrix4x4Array", a.params.value = "0", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "SKIN_NORMAL", a.params.pn_type = "param_named", a.params.name = "boneMatrixArrayIT", a.params.type = "matrix3x3Array", a.params.value = "0", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ENV_MAP", a.params.pn_type = "param_named_auto", a.params.name = "normalMatrix", a.params.type = "", a.params.value = "inverse_transpose_worldview_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ENV_MAP", a.params.pn_type = "param_named_auto", a.params.name = "worldViewMatrix", a.params.type = "", a.params.value = "worldview_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ENV_MAP", a.params.pn_type = "param_named_auto", a.params.name = "refStrength", a.params.type = "", a.params.value = "ref_strength", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "UV_REPEAT", a.params.pn_type = "param_named_auto", a.params.name = "uv_repeat", a.params.type = "", a.params.value = "uv_repeat", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexDefaultParams.push(a), MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexPars = MaterialBuilder.mShaderChunks.VERTEX_PARS_common + MaterialBuilder.mShaderChunks.VERTEX_PARS_texCoord + MaterialBuilder.mShaderChunks.VERTEX_PARS_pos_worldViewProj + MaterialBuilder.mShaderChunks.VERTEX_PARS_vertexColor + MaterialBuilder.mShaderChunks.VERTEX_PARS_env_normal_surface + MaterialBuilder.mShaderChunks.VERTEX_PARS_env_worldview_surface, MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].vertexLogic = MaterialBuilder.mShaderChunks.VERTEX_texCoord + MaterialBuilder.mShaderChunks.VERTEX_pos_base + MaterialBuilder.mShaderChunks.VERTEX_skin + MaterialBuilder.mShaderChunks.VERTEX_pos_worldViewProj + MaterialBuilder.mShaderChunks.VERTEX_vertexColor + MaterialBuilder.mShaderChunks.VERTEX_env_worldview_surface + MaterialBuilder.mShaderChunks.VERTEX_env_normal_surface + MaterialBuilder.mShaderChunks.VERTEX_envMap;
    var a = new ParamsWithMacro;
    a.MACRO = "COLOR_MAP", a.params.pn_type = "param_named", a.params.name = "colorMap", a.params.type = "int", a.params.value = "0", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ALPHA_MAP", a.params.pn_type = "param_named", a.params.name = "alphaMap", a.params.type = "int", a.params.value = "0", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "COLOR_MODIFIER", a.params.pn_type = "param_named_auto", a.params.name = "colorModifier", a.params.type = "", a.params.value = "color_modifier", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "DOUBLE_RENDER", a.params.pn_type = "param_named", a.params.name = "doubleRender", a.params.type = "int", a.params.value = "1", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ENV_MAP", a.params.pn_type = "param_named", a.params.name = "envMap", a.params.type = "int", a.params.value = "0", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].fragmentDefaultParams.push(a), MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].fragmentPars = MaterialBuilder.mShaderChunks.FRAGMENT_PARS_texCoord + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_colorMap + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_alphaMap + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_vertexColor + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_colorModifier + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_envMap + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_doubleRender, MaterialBuilder.mShaderLib[ShaderType.ST_SURFACE].fragmentLogic = MaterialBuilder.mShaderChunks.FRAGMENT_base + MaterialBuilder.mShaderChunks.FRAGMENT_colorMap + MaterialBuilder.mShaderChunks.FRAGMENT_alphaMap + MaterialBuilder.mShaderChunks.FRAGMENT_vertexColor + MaterialBuilder.mShaderChunks.FRAGMENT_colorModifier + MaterialBuilder.mShaderChunks.FRAGMENT_envMap_tex + MaterialBuilder.mShaderChunks.FRAGMENT_envMap_surface + MaterialBuilder.mShaderChunks.FRAGMENT_doubleRender, MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT] = new ShaderElement;
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "worldViewProj", a.params.type = "", a.params.value = "worldviewproj_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "UV_ANI", a.params.pn_type = "param_named_auto", a.params.name = "textureMatrix", a.params.type = "", a.params.value = "texture_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "normalMatrix", a.params.type = "", a.params.value = "inverse_transpose_worldview_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "worldViewMatrix", a.params.type = "", a.params.value = "worldview_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "SKIN_", a.params.pn_type = "param_named", a.params.name = "boneCount", a.params.type = "int", a.params.value = "4", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "SKIN_", a.params.pn_type = "param_named", a.params.name = "boneMatrixArray", a.params.type = "matrix4x4Array", a.params.value = "0", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "SKIN_NORMAL", a.params.pn_type = "param_named", a.params.name = "boneMatrixArrayIT", a.params.type = "matrix3x3Array", a.params.value = "0", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ENV_MAP", a.params.pn_type = "param_named_auto", a.params.name = "refStrength", a.params.type = "", a.params.value = "ref_strength", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "UV_REPEAT", a.params.pn_type = "param_named_auto", a.params.name = "uv_repeat", a.params.type = "", a.params.value = "uv_repeat", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexDefaultParams.push(a), MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexPars = MaterialBuilder.mShaderChunks.VERTEX_PARS_texCoord + MaterialBuilder.mShaderChunks.VERTEX_PARS_common + MaterialBuilder.mShaderChunks.VERTEX_PARS_pos_worldViewProj + MaterialBuilder.mShaderChunks.VERTEX_PARS_vertexColor + MaterialBuilder.mShaderChunks.VERTEX_PARS_phong_blinn + "varying vec3 vNormal;\n", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].vertexLogic = MaterialBuilder.mShaderChunks.VERTEX_texCoord + MaterialBuilder.mShaderChunks.VERTEX_pos_base + MaterialBuilder.mShaderChunks.VERTEX_skin + MaterialBuilder.mShaderChunks.VERTEX_phong_blinn + MaterialBuilder.mShaderChunks.VERTEX_pos_worldViewProj + MaterialBuilder.mShaderChunks.VERTEX_vertexColor + MaterialBuilder.mShaderChunks.VERTEX_normal_base + MaterialBuilder.mShaderChunks.VERTEX_normal_skin + MaterialBuilder.mShaderChunks.VERTEX_normal_light + MaterialBuilder.mShaderChunks.VERTEX_envMap;
    var a = new ParamsWithMacro;
    a.MACRO = "COLOR_MAP", a.params.pn_type = "param_named", a.params.name = "colorMap", a.params.type = "int", a.params.value = "0", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ALPHA_MAP", a.params.pn_type = "param_named", a.params.name = "alphaMap", a.params.type = "int", a.params.value = "0", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "lightCount", a.params.type = "", a.params.value = "light_count", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "derivedAmbientLightColor", a.params.type = "", a.params.value = "derived_ambient_light_colour", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "lightPositionViewSpaceArray", a.params.type = "", a.params.value = "light_position_view_space_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "lightDirectionViewSpaceArray", a.params.type = "", a.params.value = "light_direction_view_space_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "derivedLightDiffuseColorArray", a.params.type = "", a.params.value = "derived_light_diffuse_colour_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "spotLightParamsArray", a.params.type = "", a.params.value = "spotlight_params_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "lightAttenuationArray", a.params.type = "", a.params.value = "light_attenuation_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "COLOR_MODIFIER", a.params.pn_type = "param_named_auto", a.params.name = "colorModifier", a.params.type = "", a.params.value = "color_modifier", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "DOUBLE_RENDER", a.params.pn_type = "param_named", a.params.name = "doubleRender", a.params.type = "int", a.params.value = "1", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ENV_MAP", a.params.pn_type = "param_named", a.params.name = "envMap", a.params.type = "int", a.params.value = "0", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentDefaultParams.push(a), MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentPars = MaterialBuilder.mShaderChunks.FRAGMENT_PARS_texCoord + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_colorMap + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_alphaMap + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_vertexColor + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_lambert + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_colorModifier + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_doubleRender + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_envMap + "varying vec3 vNormal;\n", MaterialBuilder.mShaderLib[ShaderType.ST_LAMBERT].fragmentLogic = MaterialBuilder.mShaderChunks.FRAGMENT_base + MaterialBuilder.mShaderChunks.FRAGMENT_colorMap + MaterialBuilder.mShaderChunks.FRAGMENT_alphaMap + MaterialBuilder.mShaderChunks.FRAGMENT_vertexColor + MaterialBuilder.mShaderChunks.FRAGMENT_colorModifier + MaterialBuilder.mShaderChunks.FRAGMENT_envMap_tex + MaterialBuilder.mShaderChunks.FRAGMENT_lambert + MaterialBuilder.mShaderChunks.FRAGMENT_doubleRender, MaterialBuilder.mShaderLib[ShaderType.ST_BLINN] = new ShaderElement;
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "worldViewProj", a.params.type = "", a.params.value = "worldviewproj_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "UV_ANI", a.params.pn_type = "param_named_auto", a.params.name = "textureMatrix", a.params.type = "", a.params.value = "texture_matrix", a.params.extra_info = "",
        MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "normalMatrix", a.params.type = "", a.params.value = "inverse_transpose_worldview_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "worldViewMatrix", a.params.type = "", a.params.value = "worldview_matrix", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "SKIN_", a.params.pn_type = "param_named", a.params.name = "boneCount", a.params.type = "int", a.params.value = "4", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "SKIN_", a.params.pn_type = "param_named", a.params.name = "boneMatrixArray", a.params.type = "matrix4x4Array", a.params.value = "0", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "SKIN_NORMAL", a.params.pn_type = "param_named", a.params.name = "boneMatrixArrayIT", a.params.type = "matrix3x3Array", a.params.value = "0", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ENV_MAP", a.params.pn_type = "param_named_auto", a.params.name = "refStrength", a.params.type = "", a.params.value = "ref_strength", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "UV_REPEAT", a.params.pn_type = "param_named_auto", a.params.name = "uv_repeat", a.params.type = "", a.params.value = "uv_repeat", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexDefaultParams.push(a), MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexPars = MaterialBuilder.mShaderChunks.VERTEX_PARS_texCoord + MaterialBuilder.mShaderChunks.VERTEX_PARS_common + MaterialBuilder.mShaderChunks.VERTEX_PARS_pos_worldViewProj + MaterialBuilder.mShaderChunks.VERTEX_PARS_vertexColor + MaterialBuilder.mShaderChunks.VERTEX_PARS_phong_blinn + "varying vec3 vNormal;\n", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].vertexLogic = MaterialBuilder.mShaderChunks.VERTEX_texCoord + MaterialBuilder.mShaderChunks.VERTEX_pos_base + MaterialBuilder.mShaderChunks.VERTEX_skin + MaterialBuilder.mShaderChunks.VERTEX_phong_blinn + MaterialBuilder.mShaderChunks.VERTEX_pos_worldViewProj + MaterialBuilder.mShaderChunks.VERTEX_vertexColor + MaterialBuilder.mShaderChunks.VERTEX_normal_base + MaterialBuilder.mShaderChunks.VERTEX_normal_skin + MaterialBuilder.mShaderChunks.VERTEX_normal_light + MaterialBuilder.mShaderChunks.VERTEX_envMap;
    var a = new ParamsWithMacro;
    a.MACRO = "COLOR_MAP", a.params.pn_type = "param_named", a.params.name = "colorMap", a.params.type = "int", a.params.value = "0", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ALPHA_MAP", a.params.pn_type = "param_named", a.params.name = "alphaMap", a.params.type = "int", a.params.value = "0", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "matShiniess", a.params.type = "", a.params.value = "surface_shininess", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "lightCount", a.params.type = "", a.params.value = "light_count", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "derivedAmbientLightColor", a.params.type = "", a.params.value = "derived_ambient_light_colour", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "lightPositionViewSpaceArray", a.params.type = "", a.params.value = "light_position_view_space_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "lightDirectionViewSpaceArray", a.params.type = "", a.params.value = "light_direction_view_space_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "derivedLightDiffuseColorArray", a.params.type = "", a.params.value = "derived_light_diffuse_colour_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "derivedLightSpecularColorArray", a.params.type = "", a.params.value = "derived_light_specular_colour_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "spotLightParamsArray", a.params.type = "", a.params.value = "spotlight_params_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "", a.params.pn_type = "param_named_auto", a.params.name = "lightAttenuationArray", a.params.type = "", a.params.value = "light_attenuation_array", a.params.extra_info = "8", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "COLOR_MODIFIER", a.params.pn_type = "param_named_auto", a.params.name = "colorModifier", a.params.type = "", a.params.value = "color_modifier", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "DOUBLE_RENDER", a.params.pn_type = "param_named", a.params.name = "doubleRender", a.params.type = "int", a.params.value = "1", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a);
    var a = new ParamsWithMacro;
    a.MACRO = "ENV_MAP", a.params.pn_type = "param_named", a.params.name = "envMap", a.params.type = "int", a.params.value = "0", a.params.extra_info = "", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentDefaultParams.push(a), MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentPars = MaterialBuilder.mShaderChunks.FRAGMENT_PARS_texCoord + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_colorMap + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_alphaMap + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_vertexColor + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_phong_blinn + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_colorModifier + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_doubleRender + MaterialBuilder.mShaderChunks.FRAGMENT_PARS_envMap + "varying vec3 vNormal;\n", MaterialBuilder.mShaderLib[ShaderType.ST_BLINN].fragmentLogic = MaterialBuilder.mShaderChunks.FRAGMENT_base + MaterialBuilder.mShaderChunks.FRAGMENT_colorMap + MaterialBuilder.mShaderChunks.FRAGMENT_vertexColor + MaterialBuilder.mShaderChunks.FRAGMENT_alphaMap + MaterialBuilder.mShaderChunks.FRAGMENT_colorModifier + MaterialBuilder.mShaderChunks.FRAGMENT_envMap_tex + MaterialBuilder.mShaderChunks.FRAGMENT_blinn + MaterialBuilder.mShaderChunks.FRAGMENT_doubleRender
}, MaterialBuilder._initShaderLib(), MaterialBuilder._extractDefaultParamsByMacro = function(a, b, c, d) {
    null == d && (d = "");
    for (var e in b) {
        var f = b[e];
        f.MACRO == c && ("" !== d && (f.params.value = d), a.push(f.params))
    }
}, MaterialBuilder.buildShader = function(a) {
    var b = new ShaderContent;
    b.vertexProgramName = "v", b.fragmentProgramName = "f";
    var c = a.shaderType;
    b.vertexProgramName += c, b.fragmentProgramName += c;
    var d = "",
        e = "";
    switch (a.intPrecision) {
        case ShaderPrecision.SP_LOWP:
            d += "precision lowp int;\n", e += "precision lowp int;\n";
            break;
        case ShaderPrecision.SP_MEDIUMP:
            d += "precision mediump int;\n", e += "precision mediump int;\n";
            break;
        case ShaderPrecision.SP_HIGHP:
            d += "precision highp int;\n", e += "precision highp int;\n"
    }
    switch (a.floatPrecision) {
        case ShaderPrecision.SP_LOWP:
            d += "precision lowp float;\n", e += "precision lowp float;\n";
            break;
        case ShaderPrecision.SP_MEDIUMP:
            d += "precision mediump float;\n", e += "precision mediump float;\n";
            break;
        case ShaderPrecision.SP_HIGHP:
            d += "precision highp float;\n", e += "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n"
    }
    var f = [];
    "" != a.colorMap && (e += "#define COLOR_MAP\n", f.push("COLOR_MAP")), a.bUVAnim && (d += "#define UV_ANI\n", e += "#define UV_ANI\n", f.push("UV_ANI")), a.bUseVertexColor && (d += "#define VERTEX_COLOR\n", e += "#define VERTEX_COLOR\n", f.push("VERTEX_COLOR")), a.bColorModifier && (e += "#define COLOR_MODIFIER\n", f.push("COLOR_MODIFIER")), "" != a.alphaMap && (e += "#define ALPHA_MAP\n", f.push("ALPHA_MAP")), a.isSkin && (d += "#define SKIN_\n", f.push("SKIN_")), a.requireSkinNormal && (d += "#define SKIN_NORMAL\n", f.push("SKIN_NORMAL")), a.doubleRender && (e += "#define DOUBLE_RENDER\n", f.push("DOUBLE_RENDER")), "" != a.envMap && (e += "#define ENV_MAP\n", d += "#define ENV_MAP\n", f.push("ENV_MAP")), a.uv_repeat && (e += "#define UV_REPEAT\n", d += "#define UV_REPEAT\n", f.push("UV_REPEAT"));
    var g = 0,
        h = 0;
    MaterialBuilder._extractDefaultParamsByMacro(b.vertexDefaultParams, MaterialBuilder.mShaderLib[c].vertexDefaultParams, ""), "" != a.colorMap && (MaterialBuilder._extractDefaultParamsByMacro(b.vertexDefaultParams, MaterialBuilder.mShaderLib[c].vertexDefaultParams, "COLOR_MAP"), b.vertexProgramName += "COLOR_MAP_", b.fragmentProgramName += "COLOR_MAP_"), a.bUVAnim && (MaterialBuilder._extractDefaultParamsByMacro(b.vertexDefaultParams, MaterialBuilder.mShaderLib[c].vertexDefaultParams, "UV_ANI"), b.vertexProgramName += "UV_ANI_", b.fragmentProgramName += "UV_ANI_"), a.bUseVertexColor && (MaterialBuilder._extractDefaultParamsByMacro(b.vertexDefaultParams, MaterialBuilder.mShaderLib[c].vertexDefaultParams, "VERTEX_COLOR"), b.vertexProgramName += "VERTEX_COLOR_", b.fragmentProgramName += "VERTEX_COLOR_"), a.bColorModifier && (MaterialBuilder._extractDefaultParamsByMacro(b.vertexDefaultParams, MaterialBuilder.mShaderLib[c].vertexDefaultParams, "COLOR_MODIFIER"), b.vertexProgramName += "COLOR_MODIFIER_", b.fragmentProgramName += "COLOR_MODIFIER_"), "" != a.alphaMap && (MaterialBuilder._extractDefaultParamsByMacro(b.vertexDefaultParams, MaterialBuilder.mShaderLib[c].vertexDefaultParams, "ALPHA_MAP_"), b.vertexProgramName += "ALPHA_MAP_", b.fragmentProgramName += "ALPHA_MAP_"), a.isSkin && (MaterialBuilder._extractDefaultParamsByMacro(b.vertexDefaultParams, MaterialBuilder.mShaderLib[c].vertexDefaultParams, "SKIN_"), b.vertexProgramName += "SIKN_", b.fragmentProgramName += "SKIN_"), a.requireSkinNormal && (MaterialBuilder._extractDefaultParamsByMacro(b.vertexDefaultParams, MaterialBuilder.mShaderLib[c].vertexDefaultParams, "SKIN_NORMAL"), b.vertexProgramName += "SIKN_NORMAL", b.fragmentProgramName += "SKIN_NORMAL"), a.uv_repeat && (MaterialBuilder._extractDefaultParamsByMacro(b.vertexDefaultParams, MaterialBuilder.mShaderLib[c].vertexDefaultParams, "UV_REPEAT"), b.vertexProgramName += "UV_REPEAT", b.fragmentProgramName += "UV_REPEAT"), "" != a.envMap && (MaterialBuilder._extractDefaultParamsByMacro(b.vertexDefaultParams, MaterialBuilder.mShaderLib[c].vertexDefaultParams, "ENV_MAP"), b.vertexProgramName += "ENV_MAP", b.fragmentProgramName += "ENV_MAP"), b.vertexProgramName += "_", b.fragmentProgramName += "_", MaterialBuilder._extractDefaultParamsByMacro(b.fragmentDefaultParams, MaterialBuilder.mShaderLib[c].fragmentDefaultParams, ""), "" != a.colorMap && (MaterialBuilder._extractDefaultParamsByMacro(b.fragmentDefaultParams, MaterialBuilder.mShaderLib[c].fragmentDefaultParams, "COLOR_MAP", g.toString()), b.vertexProgramName += "COLOR_MAP_", b.fragmentProgramName += "COLOR_MAP_", ++h), a.bUVAnim && (MaterialBuilder._extractDefaultParamsByMacro(b.fragmentDefaultParams, MaterialBuilder.mShaderLib[c].fragmentDefaultParams, "UV_ANI"), b.vertexProgramName += "UV_ANI_", b.fragmentProgramName += "UV_ANI_"), a.bUseVertexColor && (MaterialBuilder._extractDefaultParamsByMacro(b.fragmentDefaultParams, MaterialBuilder.mShaderLib[c].fragmentDefaultParams, "VERTEX_COLOR"), b.vertexProgramName += "VERTEX_COLOR_", b.fragmentProgramName += "VERTEX_COLOR_"), a.bColorModifier && (MaterialBuilder._extractDefaultParamsByMacro(b.fragmentDefaultParams, MaterialBuilder.mShaderLib[c].fragmentDefaultParams, "COLOR_MODIFIER"), b.vertexProgramName += "COLOR_MODIFIER_", b.fragmentProgramName += "COLOR_MODIFIER_"), "" != a.alphaMap && (MaterialBuilder._extractDefaultParamsByMacro(b.fragmentDefaultParams, MaterialBuilder.mShaderLib[c].fragmentDefaultParams, "ALPHA_MAP", h.toString()), b.vertexProgramName += "ALPHA_MAP_", b.fragmentProgramName += "ALPHA_MAP_", ++h), a.doubleRender && (MaterialBuilder._extractDefaultParamsByMacro(b.fragmentDefaultParams, MaterialBuilder.mShaderLib[c].fragmentDefaultParams, "DOUBLE_RENDER"), b.vertexProgramName += "DOUBLE_RENDER", b.fragmentProgramName += "DOUBLE_RENDER"), "" != a.envMap && (MaterialBuilder._extractDefaultParamsByMacro(b.fragmentDefaultParams, MaterialBuilder.mShaderLib[c].fragmentDefaultParams, "ENV_MAP", h.toString()), b.vertexProgramName += "ENV_MAP", b.fragmentProgramName += "ENV_MAP", ++h), b.vertexShader = d + MaterialBuilder.mShaderLib[c].vertexPars + "void main() { \n" + MaterialBuilder.mShaderLib[c].vertexLogic + "} \n", b.fragmentShader = e + MaterialBuilder.mShaderLib[c].fragmentPars + "void main() { \n" + MaterialBuilder.mShaderLib[c].fragmentLogic + "} \n";
    var i = new filter_process;
    i.process(b.vertexShader), b.vertexShader = i.result;
    var j = new filter_process;
    return j.process(b.fragmentShader), b.fragmentShader = j.result, b
}, MaterialBuilder.buildMaterial = function(a, b, c, d) {
    if (null != a) {
        var e = a.mRoot;
        switch (b.type) {
            case ShaderType.ST_LAMBERT:
            case ShaderType.ST_BLINN:
            case ShaderType.ST_PHONG:
            case ShaderType.ST_GOURAUD:
            case ShaderType.ST_SURFACE:
                "" !== b.culling_mode && (0 == "none".localeCompare(b.culling_mode) ? a.pass.mCullMode = CULL_NONE : 0 == "anticlockwise".localeCompare(b.culling_mode) ? a.pass.mCullMode = CULL_ANTICLOCKWISE : 0 == "clockwise".localeCompare(b.culling_mode) && (a.pass.mCullMode = CULL_CLOCKWISE));
                var f = new ShaderConstructParameters;
                if (f.shaderType = b.type, "" !== b.blend_mode && StringConverter.parseSceneBlend(b.blend_mode, a.pass), "" !== b.depth_check && (a.pass.mDepthCheck = StringConverter.parseBool(b.depth_check)), "" !== b.depth_write && (a.pass.mDepthWrite = StringConverter.parseBool(b.depth_write)), "" !== b.colorMap) {
                    f.colorMap = b.colorMap;
                    var g = new TextureUnitState(e, c, d);
                    switch (g.setTextureName(b.colorMap), b.texture_address_mode) {
                        case "wrap":
                            g.setTextureAddressingMode(TAM_WRAP);
                            break;
                        case "mirror":
                            g.setTextureAddressingMode(TAM_MIRROR);
                            break;
                        case "clamp":
                            g.setTextureAddressingMode(TAM_CLAMP);
                            break;
                        case "border":
                            g.setTextureAddressingMode(TAM_BORDER)
                    }
                    a.pass.TextureUnitStates.push(g)
                }
                var h = [1, 1, 1, 1];
                "" !== b.color && (f.bColorModifier = !0, h = StringConverter.parseFloatArray(b.color));
                var i = StringConverter.parseBool(b.alpha_ani);
                if (("" !== b.alpha || i) && ("" === b.alpha ? alpha = 1 : alpha = parseFloat(b.alpha), (alpha < 0 || alpha > 1) && (alpha = 1), f.bColorModifier = !0, h[3] = alpha), a.pass.setColorModifier(h), "" !== b.alphaMap) {
                    f.alphaMap = b.alphaMap;
                    var g = new TextureUnitState(e, c, d);
                    g.setTextureName(b.alphaMap), "" !== b.tex_address_mode && (0 == "wrap".localeCompare(b.tex_address_mode) ? g.setTextureAddressingMode(TAM_WRAP) : 0 == "mirror".localeCompare(b.tex_address_mode) ? g.setTextureAddressingMode(TAM_MIRROR) : 0 == "clamp".localeCompare(b.tex_address_mode) ? g.setTextureAddressingMode(TAM_CLAMP) : 0 == "border".localeCompare(b.tex_address_mode) && g.setTextureAddressingMode(TAM_BORDER)), a.pass.TextureUnitStates.push(g)
                }
                if (b.type != ShaderType.ST_SURFACE && ("" != b.ambient && a.pass.setAmbient(StringConverter.parseFloatArray(b.ambient)), "" != b.diffuse && a.pass.setDiffuse(StringConverter.parseFloatArray(b.diffuse)), "" != b.emissive && a.pass.setEmissive(StringConverter.parseFloatArray(b.emissive)), "" != b.specular && a.pass.setSpecular(StringConverter.parseFloatArray(b.specular)), "" != b.shininess && a.pass.setShininess(parseFloat(b.shininess))), "" !== b.use_vertex_color && (f.bUseVertexColor = StringConverter.parseBool(b.use_vertex_color)), "" !== b.uv_ani && (f.bUVAnim = StringConverter.parseBool(b.uv_ani)), "" !== b.precision_float && ("lowp" == b.precision_float ? f.floatPrecision = ShaderPrecision.SP_LOWP : "mediump" == b.precision_float ? f.floatPrecision = ShaderPrecision.SP_MEDIUMP : "highp" == b.precision_float && (f.floatPrecision = ShaderPrecision.SP_HIGHP)), "" !== b.precision_int && ("lowp" == b.precision_int ? f.intPrecision = ShaderPrecision.SP_LOWP : "mediump" == b.precision_int ? f.intPrecision = ShaderPrecision.SP_MEDIUMP : "highp" == b.precision_int && (f.intPrecision = ShaderPrecision.SP_HIGHP)), "" !== b.isSkin && (f.isSkin = StringConverter.parseBool(b.isSkin)), f.isSkin && (f.requireSkinNormal = StringConverter.parseBool(b.requireSkinNormal), a.mRequireSkinNormal = f.requireSkinNormal), b.doubleRender && (a.doubleRender = b.doubleRender, f.doubleRender = a.doubleRender), "" !== b.envMap) {
                    f.envMap = b.envMap, f.refStrength = b.refStrength;
                    var g = new TextureUnitState(e, c, d);
                    g.setTextureName(b.envMap), "" !== b.tex_address_mode && (0 == "wrap".localeCompare(b.tex_address_mode) ? g.setTextureAddressingMode(TAM_WRAP) : 0 == "mirror".localeCompare(b.tex_address_mode) ? g.setTextureAddressingMode(TAM_MIRROR) : 0 == "clamp".localeCompare(b.tex_address_mode) ? g.setTextureAddressingMode(TAM_CLAMP) : 0 == "border".localeCompare(b.tex_address_mode) && g.setTextureAddressingMode(TAM_BORDER)), a.pass.TextureUnitStates.push(g), a.pass.setReflectionStrength(f.refStrength)
                }
                if ("" !== b.videosrc) {
                    f.colorMap = b.videosrc;
                    var g = new TextureUnitState(e, c, d);
                    switch (b.texture_address_mode) {
                        case "wrap":
                            g.setTextureAddressingMode(TAM_WRAP);
                            break;
                        case "mirror":
                            g.setTextureAddressingMode(TAM_MIRROR);
                            break;
                        case "clamp":
                            g.setTextureAddressingMode(TAM_CLAMP);
                            break;
                        case "border":
                            g.setTextureAddressingMode(TAM_BORDER)
                    }
                    a.pass.TextureUnitStates.push(g), "null" == b.videosrc && (a.mForbidden = !0);
                    e.mArchive.videoLoad(b.videosrc, function(a) {
                        g.setTexture(a)
                    }, g.mPrefix)
                }
                var j = MaterialBuilder.buildShader(f);
                if (null == e.getProgram(j.vertexProgramName)) {
                    var k = new Program(e, VERTEX_SHADER);
                    k.name = j.vertexProgramName, k.source = j.vertexShader, e.mVertexProgram.push(k);
                    for (var l in j.vertexDefaultParams) {
                        var m = new Default_param;
                        m.name = j.vertexDefaultParams[l].name, m.value = j.vertexDefaultParams[l].value, m.pn_type = j.vertexDefaultParams[l].pn_type, m.type = j.vertexDefaultParams[l].type, m.extra_info = j.vertexDefaultParams[l].extra_info, k.default_params.push(m)
                    }
                }
                if (a.pass.vertex_program_ref = j.vertexProgramName, null == e.getProgram(j.fragmentProgramName)) {
                    var k = new Program(e, FRAGMENT_SHADER);
                    k.name = j.fragmentProgramName, k.source = j.fragmentShader, e.mFragmentProgram.push(k);
                    for (var l in j.fragmentDefaultParams) {
                        var m = new Default_param;
                        m.name = j.fragmentDefaultParams[l].name, m.value = j.fragmentDefaultParams[l].value, m.pn_type = j.fragmentDefaultParams[l].pn_type, m.type = j.fragmentDefaultParams[l].type, m.extra_info = j.fragmentDefaultParams[l].extra_info, k.default_params.push(m)
                    }
                }
                a.pass.fragment_program_ref = j.fragmentProgramName
        }
    }
};
var MaterialManager = function(a) {
    if (null == a) throw new Error("root cannot be null");
    this.mRoot = a, this.mMaterials = {}
};
MaterialManager.prototype = {
    constructor: MaterialManager,
    create: function(a, b) {
        var c = this.getByName(a, b);
        return null != c ? c : (c = new Material(this.mRoot), c.mGroupId = b, c.name = a, null == this.mMaterials[b] && (this.mMaterials[b] = {}), null == this.mMaterials[b][a] && (this.mMaterials[b][a] = c), c)
    },
    buildMaterial: function(a, b, c, d) {
        var e = this.create(a, b);
        return MaterialBuilder.buildMaterial(e, c, b, d), e
    },
    getByName: function(a, b) {
        if (null == b) throw new Error("groupId cannot be null");
        var c = this.mMaterials[b];
        return null == c ? null : c[a]
    },
    releaseByGroupId: function(a) {
        null != this.mMaterials[a] && delete this.mMaterials[a]
    }
};
var SceneXMLParse = function(a, b, c, d, e, f) {
    this.mRoot = a, this.mPrefix = c || "", this.mGroupId = f, this.mParentAssetHandle = d, this.mParentAssetPath = e, this.mScriptExist = !1, this.mE3d = b
};
SceneXMLParse.prototype = {
    constructor: SceneXMLParse,
    curParsingSceneMgr: null,
    parseScript: function(a, b) {
        e3d.requirePath = b.mPrefix;
        var c = XMLJS.parseXML(a),
            d = XMLJS.getXMLRootNode(c);
        if ("Assets" === d.nodeName) {
            var e = d;
            b.AssetsNodeParse(e, b)
        }
        b.mScriptExist || (b.mRoot.mIsParsing = !1)
    },
    AssetsNodeParse: function(a, b) {
        for (var c = XMLJS.getXMLChildNodes(a), d = 0; d < c.length; d++) {
            var e = c[d],
                f = e.nodeName;
            0 == f.localeCompare("Asset") && b.AssetNodeParse(e, b)
        }
    },
    AssetNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "src"),
            d = (XMLJS.getAttributeNodeValue(a, "id"), XMLJS.getAttributeNodeValue(a, "type"), XMLJS.getAttributeNodeValue(a, "url"));
        if (d || c) {
            var e;
            d ? e = d : c && (e = this.mPrefix + "/" + c);
            for (var f = {
                    translate: null,
                    scale: null,
                    quaternion: null,
                    event: null
                }, g = XMLJS.getXMLChildNodes(a), h = 0; h < g.length; h++) {
                this.mRoot.debug && console.log(g[h].nodeName);
                var i = g[h],
                    j = i.nodeName;
                if (0 == j.localeCompare("Transform")) {
                    var k = XMLJS.getAttributeNodeValue(i, "position"),
                        l = XMLJS.getAttributeNodeValue(i, "scale"),
                        m = XMLJS.getAttributeNodeValue(i, "quaternion");
                    k && (f.translate = k), l && (f.scale = l), m && (f.quaternion = m)
                } else if (0 == j.localeCompare("Event")) {
                    var n = XMLJS.getAttributeNodeValue(i, "event");
                    null != n && (f.event = n)
                }
            }
            this.mE3d.loadAsset(e, this.mParentAssetHandle, null, f)
        } else {
            var g = XMLJS.getXMLChildNodes(a);
            this.mRoot.debug && console.log(g.length);
            for (var h = 0; h < g.length; h++) {
                this.mRoot.debug && console.log(g[h].nodeName);
                var i = g[h],
                    j = i.nodeName;
                0 == j.localeCompare("Programs") ? b.ProgramsNodeParse(i, b) : 0 == j.localeCompare("Material") ? b.MaterialNodeParse(i, b) : 0 == j.localeCompare("Texture") ? b.TextureNodeParse(i, b) : 0 == j.localeCompare("UVSFile") ? b.UVSNodeParse(i, b) : 0 == j.localeCompare("eRect") ? b.eRectNodeParse(i, b) : 0 == j.localeCompare("eMesh") ? b.eMeshNodeParse(i, b) : 0 == j.localeCompare("Audio") ? b.AudioNodeParse(i, b) : 0 == j.localeCompare("Scene") ? b.SceneNodeParse(i, b) : 0 == j.localeCompare("Script") ? b.ScriptNodeParse(i, b) : 0 == j.localeCompare("JS") && b.ScriptNodeParse(i, b)
            }
        }
    },
    SceneNodeParse: function(a, b) {
        var c = b.mRoot,
            d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "clear_depth"),
            f = XMLJS.getAttributeNodeValue(a, "debug");
        if (f && (c.debug = StringConverter.parseBool(f)), null == c.mScenes[d]) {
            var g = new SceneManager(b.mRoot, d, b.mGroupId);
            c.mScenes[d] = g
        }
        b.curParsingSceneMgr = c.mScenes[d], e && (b.curParsingSceneMgr.clear_depth = e), c.debug && console.log("SceneNodeParse : ", d, e);
        var h = XMLJS.getXMLChildNodes(a);
        c.debug && console.log(h.length);
        for (var i = 0; i < h.length; i++) {
            c.debug && console.log(h[i].nodeName);
            var j = h[i],
                k = j.nodeName;
            0 == k.localeCompare("Camera") ? b.CameraNodeParse(j, b) : 0 == k.localeCompare("RenderTarget") ? b.RenderTargetNodeParse(j, b) : 0 == k.localeCompare("GameObject") ? b.GameObjectNodeParse(j, b) : 0 == k.localeCompare("AmbientLight") ? b.AmbientLightNodeParse(j, b) : 0 == k.localeCompare("ParticleSystem") ? b.ParticleSystemNodeParse(j, b) : 0 == k.localeCompare("AnimationSet") ? b.AnimationSetNodeParse(j, b) : 0 == k.localeCompare("TranslateAnimation") ? b.TranslateAnimationNodeParse(j, b) : 0 == k.localeCompare("RotateAnimation") ? b.RotateAnimationNodeParse(j, b) : 0 == k.localeCompare("ScaleAnimation") ? b.ScaleAnimationNodeParse(j, b) : 0 == k.localeCompare("TexAlphaModifierAnimation") ? b.TexAlphaModifierAnimationNodeParse(j, b) : 0 == k.localeCompare("TexCoordModifierAnimation") ? b.TexCoordModifierAnimationNodeParse(j, b) : 0 == k.localeCompare("TexCoordSetAnimation") ? b.TexCoordSetAnimationNodeParse(j, b) : 0 == k.localeCompare("PathAnimation") ? b.PathAnimationNodeParse(j, b) : 0 == k.localeCompare("SequenceFrameAnimation") ? b.SequenceFrameAnimationNodeParse(j, b) : 0 == k.localeCompare("KeyFrames") ? b.KeyFramesNodeParse(j, b) : 0 == k.localeCompare("KF_TranslateAnimation") ? b.KeyFramesTranslateAnimationNodeParse(j, b) : 0 == k.localeCompare("KF_RotationAnimation") ? b.KeyFramesRotateAnimationNodeParse(j, b) : 0 == k.localeCompare("KF_ScaleAnimation") ? b.KeyFramesScaleAnimationNodeParse(j, b) : 0 == k.localeCompare("ValueAnimation") ? b.ValueAnimationNodeParse(j, b) : 0 == k.localeCompare("PathSpline") ? b.PathSplineNodeParse(j, b) : 0 == k.localeCompare("PathBrokenLine") ? b.PathBrokenLineNodeParse(j, b) : 0 == k.localeCompare("PathSimpleBezier") ? b.PathSimpleBezier(j, b) : 0 == k.localeCompare("Bone") ? b.BoneNodeParse(j, b) : c.debug && console.log("No Node Parse....")
        }
        c.debug && console.log("scope.mRoot.state = 2;")
    },
    CameraNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "width"),
            e = XMLJS.getAttributeNodeValue(a, "height"),
            f = XMLJS.getAttributeNodeValue(a, "position"),
            g = XMLJS.getAttributeNodeValue(a, "lookat"),
            h = XMLJS.getAttributeNodeValue(a, "fovy"),
            i = (XMLJS.getAttributeNodeValue(a, "orientation"), XMLJS.getAttributeNodeValue(a, "axies")),
            j = XMLJS.getAttributeNodeValue(a, "eulerRotation"),
            k = XMLJS.getAttributeNodeValue(a, "rotate"),
            l = XMLJS.getAttributeNodeValue(a, "rotate_x"),
            m = XMLJS.getAttributeNodeValue(a, "rotate_z"),
            n = XMLJS.getAttributeNodeValue(a, "auto_screen_size"),
            o = XMLJS.getAttributeNodeValue(a, "quaternion"),
            p = XMLJS.getAttributeNodeValue(a, "up_direction"),
            a = b.curParsingSceneMgr.createCamera(c);
        if (c) {
            a.name = c;
            b.curParsingSceneMgr.createGameObject(c, b.mGroupId)
        }
        if (n && (n = StringConverter.parseBool(n), a.auto_screen_size = n), d && (d = parseFloat(d)), e && (e = parseFloat(e)), !n) {
            if (f && (f = StringConverter.parseVec3(f), a.setPosition(f)), p && (p = StringConverter.parseVec3(p), a.setUpDirection(p.x, p.y, p.z)), g && (g = StringConverter.parseVec3(g), a.lookAt(g)), h && a.setFOVy(parseFloat(h)), i && (i = StringConverter.parseVec3(i)), j) {
                j = StringConverter.parseVec3(j);
                var q = new Vector3(1, 0, 0);
                a.rotate(q, Math.radians(j.x)), a.rotate(new Vector3(0, 1, 0), Math.radians(j.y)), a.rotate(new Vector3(0, 0, 1), Math.radians(j.z))
            }
            k && (k = parseFloat(k)), l && (l = parseFloat(l)), m && (m = parseFloat(m)), o && (o = o.split(" "), a.mOrientation = new Quaternion(parseFloat(o[0]), parseFloat(o[1]), parseFloat(o[2]), parseFloat(o[3])))
        }
        b.mRoot.debug && console.log("auto_screen_size:", n), a.reSize(b.mRoot.mPhoneWidth, b.mRoot.mPhoneHeight)
    },
    RenderTargetNodeParse: function(a, b) {
        var c = b.mRoot,
            d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "width"),
            f = XMLJS.getAttributeNodeValue(a, "height"),
            g = XMLJS.getAttributeNodeValue(a, "type"),
            h = XMLJS.getAttributeNodeValue(a, "target_texture");
        c.debug && console.log(d, e, f, h);
        var i = new RenderTarget(b.mRoot);
        if (d && i.setName(d), b.curParsingSceneMgr.mRenderTargets.push(i), g && h && "texture" === g) {
            var j = c.getTextureManager().getByName(h, b.mGroupId);
            j && (i.mType = RTType.RENDER_TEXTURE, i.mFboBuffer = j.fboBuffer, i.mWidth = j.fboBuffer.width, i.mHeight = j.fboBuffer.height)
        } else i.mWidth = c.mPhoneWidth, i.mHeight = c.mPhoneHeight;
        var k = XMLJS.getXMLChildNodes(a);
        c.debug && console.log(k.length);
        for (var l = 0; l < k.length; l++) {
            var m = k[l],
                n = m.nodeName;
            "Viewport" == n && b.ViewPortNodeParse(i, m, b)
        }
    },
    ViewPortNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(b, "name"),
            e = XMLJS.getAttributeNodeValue(b, "camera"),
            f = XMLJS.getAttributeNodeValue(b, "background_color"),
            g = XMLJS.getAttributeNodeValue(b, "left"),
            h = XMLJS.getAttributeNodeValue(b, "top"),
            i = XMLJS.getAttributeNodeValue(b, "width"),
            j = XMLJS.getAttributeNodeValue(b, "height"),
            k = XMLJS.getAttributeNodeValue(b, "clear");
        if (i && (i = "SCWidthDivRTWidth" === i ? c.mRoot.mPhoneWidth / a.getWidth() : parseFloat(i)), j && (j = "SCHeightDivRTHeight" == j ? c.mRoot.mPhoneHeight / a.getHeight() : parseFloat(j)), a.mViewport = new Viewport(a, g, h, i, j), c.mRoot.debug && console.log(d, e, f, g, h, i, j, k), d && (a.mViewport.name = d), e && (a.mViewport.mCamera = c.curParsingSceneMgr.getCamera(e)), f) {
            var l = StringConverter.parseFloatArray(f);
            a.mViewport.mBackColor = l
        }
        g && (g = parseFloat(g), a.mViewport.left = g), h && (h = parseFloat(h), a.mViewport.top = h), k && (a.mViewport.mClearEveryFrame = StringConverter.parseBool(k)), a.mViewport._updateDimensions()
    },
    ProgramsNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "groupname"),
            e = XMLJS.getAttributeNodeValue(a, "source");
        b.mRoot.debug && console.log(c, d, e);
        var f = XMLJS.getXMLChildNodes(a);
        b.mRoot.debug && console.log(f.length);
        for (var g = 0; g < f.length; g++) {
            var h = f[g],
                i = h.nodeName;
            "vertex_program" == i ? b.VertexProgramNodeParse(h, b) : "fragment_program" == i && b.FragmentProgramNodeParse(h, b)
        }
    },
    VertexProgramNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "source");
        b.mRoot.debug && console.log(c, d);
        var e = new Program(b.mRoot, VERTEX_SHADER);
        e.mGroupId = b.mGroupId, c && (e.name = c), e.load(d, b), b.mRoot.mVertexProgram.push(e);
        var f = XMLJS.getXMLChildNodes(a);
        b.mRoot.debug && console.log(f.length);
        for (var g = 0; g < f.length; g++) {
            var h = f[g],
                i = h.nodeName;
            "default_params" == i && b.DefaultProgramNodeParse(h, e)
        }
    },
    FragmentProgramNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "source");
        b.mRoot.debug && console.log(c, d);
        var e = new Program(b.mRoot, FRAGMENT_SHADER);
        e.mGroupId = b.mGroupId, c && (e.name = c), e.load(d, b), b.mRoot.mFragmentProgram.push(e);
        var f = XMLJS.getXMLChildNodes(a);
        b.mRoot.debug && console.log(f.length);
        for (var g = 0; g < f.length; g++) {
            var h = f[g],
                i = h.nodeName;
            "default_params" == i && b.DefaultProgramNodeParse(h, e)
        }
    },
    DefaultProgramNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "value"),
            e = XMLJS.getAttributeNodeValue(a, "pn_type"),
            f = XMLJS.getAttributeNodeValue(a, "type"),
            g = XMLJS.getAttributeNodeValue(a, "extra_info");
        b.mRoot.debug && console.log(c, d, e);
        var h = new Default_param;
        c && (h.name = c), d && (h.value = d), e && (h.pn_type = e), f && (h.type = f), g && (g = g, h.extra_info = g), b.default_params.push(h)
    },
    TextureNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "width"),
            e = XMLJS.getAttributeNodeValue(a, "height");
        if (c) {
            d = "screen_width" == d ? b.mRoot.mPhoneWidth : ~~d, e = "screen_height" == e ? b.mRoot.mPhoneHeight : ~~e;
            var f = XMLJS.getAttributeNodeValue(a, "color");
            f = null != f ? StringConverter.parseFloatArray(f) : [0, 0, 0, 0], null == b.mRoot.getTextureManager().getByName(c, b.mGroupId) && b.mRoot.getTextureManager().createManual(c, b.mGroupId, d, e, f)
        }
    },
    MaterialNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "type"),
            d = XMLJS.getAttributeNodeValue(a, "name");
        null == d && (d = "");
        var e;
        if (c) {
            var f = new MaterialAutoBuildParameters;
            switch (c) {
                case "surface":
                    f.type = ShaderType.ST_SURFACE;
                    break;
                case "phong":
                    f.type = ShaderType.ST_PHONG;
                    break;
                case "gouraud":
                    f.type = ShaderType.ST_GOURAUD;
                    break;
                case "lambert":
                    f.type = ShaderType.ST_LAMBERT;
                    break;
                case "blinn":
                    f.type = ShaderType.ST_BLINN
            }
            var g = XMLJS.getAttributeNodeValue(a, "color");
            g && (f.color = g);
            var h = XMLJS.getAttributeNodeValue(a, "colorMap");
            h && (f.colorMap = h);
            var i = XMLJS.getAttributeNodeValue(a, "alpha");
            i && (f.alpha = i);
            var j = XMLJS.getAttributeNodeValue(a, "alphaMap");
            j && (f.alphaMap = j);
            var k = XMLJS.getAttributeNodeValue(a, "ambient");
            k && (f.ambient = k);
            var l = XMLJS.getAttributeNodeValue(a, "diffuse");
            l && (f.diffuse = l);
            var m = XMLJS.getAttributeNodeValue(a, "emissive");
            m && (f.emissive = m);
            var n = XMLJS.getAttributeNodeValue(a, "specular");
            n && (f.specular = n);
            var o = XMLJS.getAttributeNodeValue(a, "shininess");
            o && (f.shininess = o);
            var p = XMLJS.getAttributeNodeValue(a, "bumpMap");
            p && (f.bumpMap = p);
            var q = XMLJS.getAttributeNodeValue(a, "depth_check");
            q && (f.depth_check = q);
            var r = XMLJS.getAttributeNodeValue(a, "depth_write");
            r && (f.depth_write = r);
            var s = XMLJS.getAttributeNodeValue(a, "use_vertex_color");
            s && (f.use_vertex_color = s);
            var t = XMLJS.getAttributeNodeValue(a, "uv_ani");
            t && (f.uv_ani = t);
            var u = XMLJS.getAttributeNodeValue(a, "alpha_ani");
            u && (f.alpha_ani = u);
            var v = XMLJS.getAttributeNodeValue(a, "culling_mode");
            v && (f.culling_mode = v);
            var w = XMLJS.getAttributeNodeValue(a, "scene_blend");
            w && (f.blend_mode = w);
            var x = XMLJS.getAttributeNodeValue(a, "texture_address_mode");
            x && (f.texture_address_mode = x);
            var y = XMLJS.getAttributeNodeValue(a, "texture_filter");
            y && (f.texture_filter = y);
            var z = XMLJS.getAttributeNodeValue(a, "precision_int");
            z && (f.precision_int = z);
            var A = XMLJS.getAttributeNodeValue(a, "precision_float");
            A && (f.precision_float = A);
            var B = XMLJS.getAttributeNodeValue(a, "isSkin"),
                C = XMLJS.getAttributeNodeValue(a, "requireSkinNormal");
            C && (f.requireSkinNormal = C), B && (f.isSkin = B);
            var D = XMLJS.getAttributeNodeValue(a, "doubleRender");
            D && (f.doubleRender = StringConverter.parseBool(D));
            var E = XMLJS.getAttributeNodeValue(a, "defer_loading");
            E && XMLJS.getAttributeNodeValue(a, "defer_loading");
            var F = XMLJS.getAttributeNodeValue(a, "reflect_ev_map"),
                G = XMLJS.getAttributeNodeValue(a, "refStrength");
            F && (f.envMap = F), G && (f.refStrength = parseFloat(G));
            var H = XMLJS.getAttributeNodeValue(a, "video");
            H && (f.videosrc = H);
            var I = XMLJS.getAttributeNodeValue(a, "uv_repeat");
            I && (f.uv_repeat = I), e = b.mRoot.getMaterialManager().buildMaterial(d, b.mGroupId, f, b.mPrefix);
        } else {
            var J = XMLJS.getXMLChildNodes(a)[0],
                K = XMLJS.getAttributeNodeValue(J, "vertex_program_ref"),
                L = XMLJS.getAttributeNodeValue(J, "fragment_program_ref"),
                k = XMLJS.getAttributeNodeValue(J, "ambient"),
                l = XMLJS.getAttributeNodeValue(J, "diffuse"),
                m = XMLJS.getAttributeNodeValue(J, "emissive"),
                n = XMLJS.getAttributeNodeValue(J, "specular"),
                o = XMLJS.getAttributeNodeValue(J, "shininess"),
                q = XMLJS.getAttributeNodeValue(J, "depth_check"),
                r = XMLJS.getAttributeNodeValue(J, "depth_write"),
                M = XMLJS.getAttributeNodeValue(J, "scissor_check"),
                v = XMLJS.getAttributeNodeValue(J, "culling_mode"),
                w = XMLJS.getAttributeNodeValue(J, "scene_blend"),
                E = XMLJS.getAttributeNodeValue(J, "defer_loading");
            e = b.mRoot.getMaterialManager().create(d, b.mGroupId), K && (e.pass.vertex_program_ref = K), L && (e.pass.fragment_program_ref = L);
            for (var N = XMLJS.getXMLChildNodes(J), O = 0; O < N.length; O++) {
                var P = N[O];
                if (0 == P.nodeName.localeCompare("TextureUnit")) {
                    var Q = XMLJS.getAttributeNodeValue(N[O], "texture"),
                        R = XMLJS.getAttributeNodeValue(N[O], "tex_address_mode"),
                        S = (XMLJS.getAttributeNodeValue(N[O], "filtering"), new TextureUnitState(b.mRoot, b.mGroupId, b.mPrefix));
                    Q && S.setTextureName(Q), R && (0 == "wrap".localeCompare(R) ? S.setTextureAddressingMode(TAM_WRAP) : 0 == "mirror".localeCompare(R) ? S.setTextureAddressingMode(TAM_MIRROR) : 0 == "clamp".localeCompare(R) ? S.setTextureAddressingMode(TAM_CLAMP) : 0 == "border".localeCompare(R) && S.setTextureAddressingMode(TAM_BORDER)), e.pass.TextureUnitStates.push(S)
                }
            }
            k && e.pass.setAmbient(StringConverter.parseFloatArray(k)), l && e.pass.setDiffuse(StringConverter.parseFloatArray(l)), m && e.pass.setEmissive(StringConverter.parseFloatArray(m)), n && e.pass.setSpecular(StringConverter.parseFloatArray(n)), o && e.pass.setShininess(parseFloat(o)), q && (e.pass.mDepthCheck = StringConverter.parseBool(q)), r && (e.pass.mDepthWrite = StringConverter.parseBool(r)), M && (e.pass.mScissor = StringConverter.parseBool(M)), v && (0 == "none".localeCompare(v) ? e.pass.mCullMode = CULL_NONE : 0 == "anticlockwise".localeCompare(v) ? e.pass.mCullMode = CULL_ANTICLOCKWISE : 0 == "clockwise".localeCompare(v) && (e.pass.mCullMode = CULL_CLOCKWISE)), w && StringConverter.parseSceneBlend(w, e.pass)
        }
        e && e.load()
    },
    UVSNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "src");
        if (c) {
            b.mRoot.debug && console.log("Load UVSFile");
            var d = b.mRoot.mUVSParse;
            d.src = c, d.load(b)
        }
    },
    eMeshNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "src");
        if (c) {
            b.mRoot.debug && console.log("加载eMesh");
            var d = new EMeshParse(b.mRoot);
            d.src = c, d.load(b)
        }
    },
    eRectNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "width"),
            e = XMLJS.getAttributeNodeValue(a, "height"),
            f = XMLJS.getAttributeNodeValue(a, "depth"),
            g = XMLJS.getAttributeNodeValue(a, "anchor"),
            h = XMLJS.getAttributeNodeValue(a, "customize_anchor"),
            i = XMLJS.getAttributeNodeValue(a, "stack_slice_set"),
            j = XMLJS.getAttributeNodeValue(a, "stack_slice_set_flip"),
            k = XMLJS.getAttributeNodeValue(a, "scale"),
            l = XMLJS.getAttributeNodeValue(a, "uvs"),
            m = XMLJS.getAttributeNodeValue(a, "uvs_name");
        b.mRoot.debug && console.log(c, d, e, f, g, h, i, j, k, l, m);
        var n = new Mesh,
            o = new eRectManipulator(b.mRoot, n);
        if (n.mManipulator = o, c && (o.name = c), g) {
            var p = StringConverter.parseStdStr(g).split(" ");
            2 == p.length ? (o.mAnchor = CUSTOMIZE, o.mCustomizeAnchorX = parseFloat(p[0]), o.mCustomizeAnchorY = parseFloat(p[1])) : "top_left" == g.toLowerCase() ? o.mAnchor = TOP_LEFT : "top_right" == g.toLowerCase() ? o.mAnchor = TOP_RIGHT : "bottom_left" == g.toLowerCase() ? o.mAnchor = BOTTOM_LEFT : "bottom_right" == g.toLowerCase() ? o.mAnchor = BOTTOM_RIGHT : "center" == g.toLowerCase() ? o.mAnchor = CENTER : "customize" == g.toLowerCase() || (o.mAnchor = TOP_LEFT)
        }
        if (h) {
            var p = StringConverter.parseVec3(h);
            o.setCustomizeAnchor(p.x, p.y, !0)
        }
        if (i) {
            o.longUpdate = !0;
            var q = i.split(" ");
            if (q.length < 2) return;
            var r = parseInt(q[0]),
                s = parseInt(q[1]),
                t = 0,
                u = !1;
            q.length >= 3 && (t = parseInt(q[2]), q.length >= 4 && (u = StringConverter.parseBool(q[3])));
            var v = new TextureSplit;
            v.setTextureStacksAndSlices(r, s, !0, u), o.setTextureCoord(v.getTextureCoord(t))
        }
        if (d && (o.width = parseFloat(d)), e && (o.height = parseFloat(e)), k) {
            var w = StringConverter.parseFloatArray(k),
                x = b.mRoot.mPhoneWidth,
                y = b.mRoot.mPhoneHeight,
                z = w[3];
            if (4 == w.length) switch (z) {
                case LayoutMode.NONE:
                    break;
                case LayoutMode.SHORTSIDE_OLD:
                case LayoutMode.SHORTSIDE:
                    var A = x > y ? y : x;
                    o.width = A * w[0], o.height = o.width * w[1];
                    break;
                case LayoutMode.STRETCH_OLD:
                case LayoutMode.STRETCH:
                    o.width = x * w[0], o.height = y * w[1];
                    break;
                case LayoutMode.LONGSIDE_OLD:
                case LayoutMode.LONGSIDE:
                    var A = x > y ? x : y;
                    o.height = A * w[1], o.width = o.height * w[0]
            }
        }
        if (o.updateVertices(), l) {
            var B = {},
                C = l.split(" ");
            B.left = parseFloat(C[0]), B.right = parseFloat(C[4]), B.top = 1 - parseFloat(C[1]), B.bottom = 1 - parseFloat(C[5]), o.updateTexCoords(B)
        }
        if (m) {
            var D = new Task;
            D.uvs_name = m, D.manipulator = o, D.run = function() {
                var a = b.mRoot.getUVSFileParser(),
                    c = a.getUVSRect(this.uvs_name);
                return null !== c ? (this.manipulator.updateTexCoords(c), !0) : !1
            }, b.mRoot.addTask(D)
        }
        b.mRoot.mMeshMap[c] = n
    },
    AudioNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "src"),
            e = XMLJS.getAttributeNodeValue(a, "volume"),
            f = XMLJS.getAttributeNodeValue(a, "playbackRate"),
            g = XMLJS.getAttributeNodeValue(a, "autoplay"),
            h = XMLJS.getAttributeNodeValue(a, "loop"),
            i = b.mRoot.getAudioManager().createAudio(c, d, b.mGroupId, b.mPrefix);
        i.load(), e && i.setVolume(parseFloat(e)), f && i.setPlaybackRate(parseFloat(f));
        var j = !1;
        g && (j = StringConverter.parseBool(g)), i.setAutoplay(j);
        var k = !1;
        h && (k = StringConverter.parseBool(h)), i.setLoop(k)
    },
    TransformNodeParse: function(a, b, c) {
        var d = b.mRoot,
            e = XMLJS.getAttributeNodeValue(a, "position"),
            f = XMLJS.getAttributeNodeValue(a, "percentagePos"),
            g = (XMLJS.getAttributeNodeValue(a, "offsetPos"), XMLJS.getAttributeNodeValue(a, "scale")),
            h = XMLJS.getAttributeNodeValue(a, "eulerRotation"),
            i = XMLJS.getAttributeNodeValue(a, "quaternion");
        if (d.debug && console.log(e, g, h), e)
            if (e = e.split(" "), 4 === e.length) c.Transform.setPositionPercentage(parseFloat(e[0]), parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]));
            else {
                if (3 !== e.length) throw new Error(" GameObject Position's Data Error.. ");
                c.Transform.setPositionPercentage(parseFloat(e[0]), parseFloat(e[1]), parseFloat(e[2]), 0)
            }
        if (f) {
            if (f = f.split(" "), 4 != f.length) return void console.error("SceneXMLParse::GameObjectNodeParse the percentagePos must have 4 value");
            c.Transform.setPositionPercentage(parseFloat(f[0]), parseFloat(f[1]), parseFloat(f[2]), parseFloat(f[3]))
        }
        g && (g = g.split(" "), c.Transform.mScale = new Vector3(parseFloat(g[0]), parseFloat(g[1]), parseFloat(g[2]))), h && (h = h.split(" "), c.Transform.rotate(new Vector3(1, 0, 0), .01744 * parseFloat(h[0]), TS_LOCAL), c.Transform.rotate(new Vector3(0, 1, 0), .01744 * parseFloat(h[1]), TS_LOCAL), c.Transform.rotate(new Vector3(0, 0, 1), .01744 * parseFloat(h[2]), TS_LOCAL)), i && (i = i.split(" "), c.Transform.mOrientation = new Quaternion(parseFloat(i[0]), parseFloat(i[1]), parseFloat(i[2]), parseFloat(i[3])), d.debug && console.log(c.Transform.mOrientation))
    },
    GameObjectNodeParse: function(a, b, c) {
        var d = b.mRoot,
            e = XMLJS.getAttributeNodeValue(a, "name"),
            f = XMLJS.getAttributeNodeValue(a, "visible"),
            g = XMLJS.getAttributeNodeValue(a, "pickable"),
            h = XMLJS.getAttributeNodeValue(a, "event"),
            i = XMLJS.getAttributeNodeValue(a, "composite"),
            j = XMLJS.getAttributeNodeValue(a, "isFixDepth"),
            k = XMLJS.getAttributeNodeValue(a, "fixDepth"),
            l = XMLJS.getAttributeNodeValue(a, "renderQueueGroupId"),
            m = XMLJS.getAttributeNodeValue(a, "isEnalbeSortCenter"),
            n = XMLJS.getAttributeNodeValue(a, "sortCenter"),
            o = XMLJS.getAttributeNodeValue(a, "tag");
        d.debug && console.log(e, f, g, i, j, k, l, m, n);
        var p = b.curParsingSceneMgr.createGameObject(e, b.mGroupId);
        if (p.mGroupId = b.mGroupId, f && p.setVisible(StringConverter.parseBool(f)), g && (p.mPickable = StringConverter.parseBool(g)), l && (p.mRenderQueueGroupID = ~~l), o && (p.mTag = ~~o), (null == c || void 0 == c) && (c = b.curParsingSceneMgr.mSceneRoot), c && c.addGameObject(p), h)
            for (var q = h.split(" "), r = 0; r < q.length; r++) "drag" === q[r] ? p.enableDefaultAutoDrag() : "rotate" === q[r] ? (p.mPickable = !0, p.mEvent += EVENT_ROTATE) : "scale" === q[r] && (p.mPickable = !0, p.mEvent += EVENT_SCALE);
        var s = XMLJS.getXMLChildNodes(a);
        d.debug && console.log(s.length);
        for (var r = 0; r < s.length; r++) {
            var t = s[r],
                u = t.nodeName;
            if (d.debug && console.log(u), "Transform" == u) "nurbsCircle2" == p.name && console.log("error......."), b.TransformNodeParse(t, b, p);
            else if ("Renderer" == u) {
                var v = XMLJS.getAttributeNodeValue(t, "material");
                d.debug && console.log(v), v && (p.Renderer.material = d.getMaterialManager().getByName(v, b.mGroupId))
            } else if ("MeshFilter" == u) {
                var w = XMLJS.getAttributeNodeValue(t, "mesh");
                d.debug && console.log(w), p.MeshFilter.mesh = w;
                var x = XMLJS.getAttributeNodeValue(t, "skeleton");
                if (x) {
                    p.mMeshSkeletonName = x;
                    var y = d.getSkeletonManager().getSkeletonByName(b.mGroupId, x);
                    y || (y = d.getSkeletonManager().createSkeleton(b.mGroupId, x)), p.mMeshSkeleton = y
                }
            } else "ParticleSystem" == u ? b.ParticleSystemNodeParse(t, b, p) : "GameObject" == u ? arguments.callee(t, b, p) : "Light" == u ? b.LightNodeParse(t, b, p) : "CameraComponent" == u ? b.CameraComponentNodeParse(t, b, p) : "Bone" == u && b.BoneNodeParse(t, b, p)
        }
    },
    CameraComponentNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "position"),
            f = XMLJS.getAttributeNodeValue(a, "lookat"),
            g = XMLJS.getAttributeNodeValue(a, "up_direction"),
            a = b.curParsingSceneMgr.getCamera(d);
        null == a && console.log("error: cameraComponent is null camera name=" + d + " doesn't exists"), null != c && a.setParentGameObject(c), e && (e = StringConverter.parseVec3(e), a.setPosition(e)), g && (g = StringConverter.parseVec3(g), a.setUpDirection(g.x, g.y, g.z)), f && (f = StringConverter.parseVec3(f), a.lookAt(f))
    },
    ParticleSystemNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "src");
        if (b.mRoot.debug && console.log(d, e), (null == c || void 0 == c) && (c = b.curParsingSceneMgr.mSceneRoot), e) {
            var f = StringConverter.parseSuffix(e);
            "json" !== f && "aes" !== f && (e += ".json"), d || (d = e);
            var g = b.curParsingSceneMgr.createGameObject(d, b.mGroupId);
            g.mGroupId = b.mGroupId, c && c.addGameObject(g);
            var h = new ParticleSystemJsonParse(b.mRoot, g);
            h.src = e, h.load(b)
        }
    },
    AnimationSetNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "interpolator"),
            e = XMLJS.getAttributeNodeValue(a, "shareInterpolator"),
            f = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            g = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            h = XMLJS.getAttributeNodeValue(a, "canstop"),
            i = XMLJS.getAttributeNodeValue(a, "start"),
            j = XMLJS.getAttributeNodeValue(a, "version");
        b.mRoot.debug && console.log(c, d, e, f, g, h, i, j);
        var k = new AnimationSet(b.mRoot);
        k.mGroupId = b.mGroupId;
        var l = !0,
            m = 1;
        c && k.setName(c), d && (d = InterpolatorSet.getInterpolatorInstance(d), k.setInterpolator(d)), f && (f = ~~f, k.setRepeatCount(f)), g && k.setRepeatMode(g), h && (k.mCanStop = StringConverter.parseBool(h)), i && (l = StringConverter.parseBool(i)), j && (m = ~~j), k.setVersion(m);
        var n = XMLJS.getXMLChildNodes(a);
        b.mRoot.debug && console.log(n.length);
        for (var o = 0; o < n.length; o++) {
            var p = n[o],
                q = p.nodeName;
            b.mRoot.debug && console.log(q), "TranslateAnimation" == q ? b.TranslateAnimationNodeParse(p, b, k) : "RotateAnimation" == q ? b.RotateAnimationNodeParse(p, b, k) : "ScaleAnimation" == q ? b.ScaleAnimationNodeParse(p, b, k) : "TexAlphaModifierAnimation" == q ? b.TexAlphaModifierAnimationNodeParse(p, b, k) : "TexCoordModifierAnimation" == q ? b.TexCoordModifierAnimationNodeParse(p, b, k) : "TexCoordSetAnimation" == q ? b.TexCoordSetAnimationNodeParse(p, b, k) : "PathAnimation" == q ? b.PathAnimationNodeParse(p, b, k) : "SequenceFrameAnimation" == q ? b.SequenceFrameAnimationNodeParse(p, b, k) : "KF_TranslateAnimation" == q ? b.KeyFramesTranslateAnimationNodeParse(p, b, k) : "KF_RotationAnimation" == q ? b.KeyFramesRotateAnimationNodeParse(p, b, k) : "KF_ScaleAnimation" == q ? b.KeyFramesScaleAnimationNodeParse(p, b, k) : "ValueAnimation" == q ? b.ValueAnimationNodeParse(p, b, k) : "PathSpline" == q ? b.PathSplineNodeParse(p, b, k) : "PathBrokenLine" == q ? b.PathBrokenLineNodeParse(p, b, k) : "PathSimpleBezier" == q && b.PathSimpleBezier(p, b, k)
        }
        l && k.startAnimation(), k.setMaxDuration(), b.mRoot.mAnimationManager.registerAnimation(k)
    },
    TranslateAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "version"),
            p = XMLJS.getAttributeNodeValue(a, "TransformSpace"),
            q = XMLJS.getAttributeNodeValue(a, "isCoordinateRelativeToScreen");
        b.mRoot.debug && console.log(d, f, g, h, i, j, k, l, m, n, o, p, q);
        var r = XMLJS.getAttributeNodeValue(a, "relative"),
            s = XMLJS.getAttributeNodeValue(a, "mFromXDelta"),
            t = XMLJS.getAttributeNodeValue(a, "mToXDelta"),
            u = XMLJS.getAttributeNodeValue(a, "mFromYDelta"),
            v = XMLJS.getAttributeNodeValue(a, "mToYDelta"),
            w = XMLJS.getAttributeNodeValue(a, "mFromZDelta"),
            x = XMLJS.getAttributeNodeValue(a, "mToZDelta");
        b.mRoot.debug && console.log(r, s, t, u, v, w, x);
        var y = new TranslateAnimation(b.mRoot);
        y.mGroupId = b.mGroupId;
        var z = !0,
            A = 1;
        if (d && y.setName(d), e) {
            var B = b.curParsingSceneMgr.getSceneNode(e);
            null != B && (y.mTarget = B.Transform)
        }
        if (f) {
            var C = f.split(" ");
            f = 2 == C.length ? InterpolatorSet.getInterpolatorInstance(C[0], parseFloat(C[1])) : InterpolatorSet.getInterpolatorInstance(C[0]), y.setInterpolator(f)
        }
        if (g && (g = parseInt(g), y.setDuration(g)), h && (h = parseInt(h), y.setRepeatCount(h)), i && y.setRepeatMode(i), j && (j = StringConverter.parseBool(j), y.mCanStop = j), k && (k = parseInt(k), y.setStartOffset(k)), l && (l = StringConverter.parseBool(l), y.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), y.setFillBefore(m)), n && (z = StringConverter.parseBool(n)), o && (A = parseInt(o)), p && y.setTransformSpace(p), q) {
            var D = StringConverter.parseBool(q);
            y.setIsCoordinateRelativeToScreen(D)
        }
        if (r && (r = StringConverter.parseBool(r), y.setRelavie(r)), s) {
            var E = parseFloat(s);
            y.setFromXDelta(E)
        }
        if (t) {
            var F = parseFloat(t);
            y.setToXDelta(F)
        }
        if (u) {
            var G = parseFloat(u);
            y.setFromYDelta(G)
        }
        if (v) {
            var H = parseFloat(v);
            y.setToYDelta(H)
        }
        if (w) {
            var I = parseFloat(w);
            y.setFromZDelta(I)
        }
        if (x) {
            var J = parseFloat(x);
            y.setToZDelta(J)
        }
        return y.setVersion(A), void 0 === c || null == c ? (z && (y.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(y)) : c.addAnimation(y), y
    },
    RotateAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "version"),
            p = XMLJS.getAttributeNodeValue(a, "TransformSpace");
        b.mRoot.debug && console.log(d, f, g, h, i, j, k, l, m, n, o, p);
        var q = XMLJS.getAttributeNodeValue(a, "relative"),
            r = XMLJS.getAttributeNodeValue(a, "fromDegrees"),
            s = XMLJS.getAttributeNodeValue(a, "toDegrees"),
            t = XMLJS.getAttributeNodeValue(a, "DegreeOffset"),
            u = XMLJS.getAttributeNodeValue(a, "rotateMode"),
            v = XMLJS.getAttributeNodeValue(a, "velocity"),
            w = XMLJS.getAttributeNodeValue(a, "axis"),
            x = XMLJS.getAttributeNodeValue(a, "ignorefirst"),
            y = XMLJS.getAttributeNodeValue(a, "resetMode");
        b.mRoot.debug && console.log(q, r, s, u, v, w, x, y);
        var z = new RotateAnimation(b.mRoot);
        z.mGroupId = b.mGroupId;
        var A = !0,
            B = 1;
        if (d && z.setName(d), e) {
            var C = b.curParsingSceneMgr.getSceneNode(e);
            null != C && (z.mTarget = C.Transform)
        }
        if (f) {
            var D = f.split(" ");
            f = 2 == D.length ? InterpolatorSet.getInterpolatorInstance(D[0], parseFloat(D[1])) : InterpolatorSet.getInterpolatorInstance(D[0]), z.setInterpolator(f)
        }
        if (g && (g = ~~g, z.setDuration(g)), h && (h = ~~h, z.setRepeatCount(h)), i && z.setRepeatMode(i), j && (j = StringConverter.parseBool(j), z.mCanStop = j), k && (k = ~~k, z.setStartOffset(k)), l && (l = StringConverter.parseBool(l), z.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), z.setFillBefore(m)), n && (A = StringConverter.parseBool(n)), o && (B = ~~o), p && z.setTransformSpace(p), q && (q = StringConverter.parseBool(q)), r && (r = parseFloat(r), z.setFromDegrees(r)), s && (s = "TWO_PI" == s ? Math.TWO_PI : parseFloat(s), z.setToDegrees(s)), t && (t = parseFloat(t), z.setDegreesOffset(t)), u && z.setAniMode(u), v && z.setVelocity(v), w) {
            if (0 == "pitch".localeCompare(w)) w = new Vector3(1, 0, 0);
            else if (0 == "roll".localeCompare(w)) w = new Vector3(0, 0, 1);
            else if (0 == "yaw".localeCompare(w)) w = new Vector3(0, 1, 0);
            else {
                var E = w.split(" ");
                w = new Vector3(parseFloat(E[0]), parseFloat(E[1]), parseFloat(E[2]))
            }
            z.setAxis(w)
        }
        return x && (x = StringConverter.parseBool(x), z.setIgnoreFirst(x)), y && ("NONE" == y ? z.setResetMode(Animation.RESETMODE_NONE) : "ORIGINAL" == y ? z.setResetMode(Animation.RESETMODE_ORIGINAL) : "UNIT" == y && z.setResetMode(Animation.RESETMODE_UNIT)), z.setVersion(B), void 0 === c || null == c ? (A && (z.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(z)) : c.addAnimation(z), z
    },
    ScaleAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "version"),
            p = XMLJS.getAttributeNodeValue(a, "TransformSpace");
        b.mRoot.debug && console.log(d, f, g, h, i, j, k, l, m, n, o, p);
        var q = XMLJS.getAttributeNodeValue(a, "relative"),
            r = XMLJS.getAttributeNodeValue(a, "mFromXDelta"),
            s = XMLJS.getAttributeNodeValue(a, "mToXDelta"),
            t = XMLJS.getAttributeNodeValue(a, "mFromYDelta"),
            u = XMLJS.getAttributeNodeValue(a, "mToYDelta"),
            v = XMLJS.getAttributeNodeValue(a, "mFromZDelta"),
            w = XMLJS.getAttributeNodeValue(a, "mToZDelta");
        b.mRoot.debug && console.log(q, r, s, t, u, v, w);
        var x = new ScaleAnimation(b.mRoot);
        x.mGroupId = b.mGroupId;
        var y = !0,
            z = 1;
        if (d && x.setName(d), e) {
            var A = b.curParsingSceneMgr.getSceneNode(e);
            null != A && (x.mTarget = A.Transform)
        }
        if (f) {
            var B = f.split(" ");
            f = 2 == B.length ? InterpolatorSet.getInterpolatorInstance(B[0], parseFloat(B[1])) : InterpolatorSet.getInterpolatorInstance(B[0]), x.setInterpolator(f)
        }
        if (g && (g = ~~g, x.setDuration(g)), h && (h = ~~h, x.setRepeatCount(h)), i && x.setRepeatMode(i), j && (j = StringConverter.parseBool(j), x.mCanStop = j), k && (k = ~~k, x.setStartOffset(k)), l && (l = StringConverter.parseBool(l), x.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), x.setFillBefore(m)), n && (y = StringConverter.parseBool(n)), o && (z = ~~o), p && x.setTransformSpace(p), q && (q = StringConverter.parseBool(q), x.setRelavie(q)), r) {
            var C = parseFloat(r);
            x.setFromXDelta(C)
        }
        if (s) {
            var D = parseFloat(s);
            x.setToXDelta(D)
        }
        if (t) {
            var E = parseFloat(t);
            x.setFromYDelta(E)
        }
        if (u) {
            var F = parseFloat(u);
            x.setToYDelta(F)
        }
        if (v) {
            var G = parseFloat(v);
            x.setFromZDelta(G)
        }
        if (w) {
            var H = parseFloat(w);
            x.setToZDelta(H)
        }
        return x.setVersion(z), void 0 === c || null == c ? (y && (x.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(x)) : c.addAnimation(x), x
    },
    TexAlphaModifierAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "version");
        b.mRoot.debug && console.log(d, f, g, h, i, j, k, l, m, n, o);
        var p = XMLJS.getAttributeNodeValue(a, "mFromAlpha"),
            q = XMLJS.getAttributeNodeValue(a, "mToAlpha"),
            r = XMLJS.getAttributeNodeValue(a, "relative"),
            s = XMLJS.getAttributeNodeValue(a, "TransformSpace");
        b.mRoot.debug && console.log(p, q, r, s);
        var t = new TexAlphaModifierAnimation(b.mRoot);
        t.mGroupId = b.mGroupId;
        var u = !0,
            v = 1;
        if (d && t.setName(d), e) {
            var w = b.curParsingSceneMgr.getSceneNode(e);
            null != w && (t.mTarget = w.Transform, t.setTarget(w.getMaterial().pass))
        }
        if (f) {
            var x = f.split(" ");
            f = 2 == x.length ? InterpolatorSet.getInterpolatorInstance(x[0], parseFloat(x[1])) : InterpolatorSet.getInterpolatorInstance(x[0]), t.setInterpolator(f)
        }
        if (g && (g = ~~g, t.setDuration(g)), h && (h = ~~h, t.setRepeatCount(h)), i && t.setRepeatMode(i), j && (j = StringConverter.parseBool(j), t.mCanStop = j), k && (k = ~~k, t.setStartOffset(k)), l && (l = StringConverter.parseBool(l), t.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), t.setFillBefore(m)), n && (u = StringConverter.parseBool(n)), o && (v = ~~o), s && t.setTransformSpace(s), p) {
            var y = parseFloat(p);
            t.setFromAlpha(y)
        }
        if (q) {
            var z = parseFloat(q);
            t.setToAlpha(z)
        }
        return r && (r = StringConverter.parseBool(r), t.setRelavie(r)), t.setVersion(v), void 0 === c || null == c ? (u && (t.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(t)) : c.addAnimation(t), t
    },
    TexCoordModifierAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "version");
        b.mRoot.debug && console.log(d, f, g, h, i, j, k, l, m, n, o);
        var p = XMLJS.getAttributeNodeValue(a, "mFromScaleU"),
            q = XMLJS.getAttributeNodeValue(a, "mToScaleU"),
            r = XMLJS.getAttributeNodeValue(a, "mFromScaleV"),
            s = XMLJS.getAttributeNodeValue(a, "mToScaleV"),
            t = XMLJS.getAttributeNodeValue(a, "mFromTranslateU"),
            u = XMLJS.getAttributeNodeValue(a, "mToTranslateU"),
            v = XMLJS.getAttributeNodeValue(a, "mFromTranslateV"),
            w = XMLJS.getAttributeNodeValue(a, "mToTranslateV"),
            x = XMLJS.getAttributeNodeValue(a, "mFrameStart"),
            y = XMLJS.getAttributeNodeValue(a, "mFrameEnd"),
            z = XMLJS.getAttributeNodeValue(a, "mStack"),
            A = XMLJS.getAttributeNodeValue(a, "mSlice"),
            B = XMLJS.getAttributeNodeValue(a, "uvMoveSortMode"),
            C = XMLJS.getAttributeNodeValue(a, "mFromRotate"),
            D = XMLJS.getAttributeNodeValue(a, "mToRotate");
        b.mRoot.debug && console.log(p, q, r, s, t, u, v, w, x, y, z, A, B, C, D);
        var E, F = XMLJS.getAttributeNodeValue(a, "material_unit");
        if (F) {
            var G = StringConverter.parseStdStr(F),
                H = G.split(" "),
                I = b.mRoot.getMaterialManager().getByName(H[0], b.mGroupId),
                J = 0;
            H.length >= 2 && (J = ~~H[1]), E = I.pass.getTextureUnitState(J), E.setTextureAddressingMode(TAM_WRAP);
            var K = new TexCoordModifierAnimation(b.mRoot, E);
            K.mGroupId = b.mGroupId;
            var L = !0,
                M = 1;
            if (d && K.setName(d), e) {
                var N = b.curParsingSceneMgr.getSceneNode(e);
                null != N && (K.mTarget = N.Transform)
            }
            if (f) {
                var O = f.split(" ");
                f = 2 == O.length ? InterpolatorSet.getInterpolatorInstance(O[0], parseFloat(O[1])) : InterpolatorSet.getInterpolatorInstance(O[0]), K.setInterpolator(f)
            }
            if (g && (g = ~~g, K.setDuration(g)), h && (h = ~~h, K.setRepeatCount(h)), i && K.setRepeatMode(i), j && (j = StringConverter.parseBool(j), K.mCanStop = j), k && (k = ~~k, K.setStartOffset(k)), l && (l = StringConverter.parseBool(l), K.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), K.setFillBefore(m)), n && (L = StringConverter.parseBool(n)), o && (M = ~~o), p) {
                var P = parseFloat(p);
                K.setFromScaleU(P)
            }
            if (q) {
                var Q = parseFloat(q);
                K.setToScaleU(Q)
            }
            if (r) {
                var R = parseFloat(r);
                K.setFromScaleV(R)
            }
            if (s) {
                var S = parseFloat(s);
                K.setToScaleV(S)
            }
            if (t) {
                var T = parseFloat(t);
                K.setFromTranslateU(T)
            }
            if (u) {
                var U = parseFloat(u);
                K.setToTranslateU(U)
            }
            if (v) {
                var T = parseFloat(v);
                K.setFromTranslateV(T)
            }
            if (w) {
                var U = parseFloat(w);
                K.setToTranslateV(U)
            }
            if (x) {
                var V = ~~x;
                K.setStartFrame(V)
            }
            if (y) {
                var V = ~~y;
                K.setEndFrame(V)
            }
            if (z) {
                var V = ~~z;
                K.setStack(V)
            }
            if (A) {
                var V = ~~A;
                K.setSlice(V)
            }
            if (B) {
                var W = ~~B;
                K.setUVMoveSortMode(W)
            }
            if (C) {
                var X = parseFloat(C);
                K.setFromRotate(X)
            }
            if (D) {
                var X = parseFloat(D);
                K.setToRotate(X)
            }
            return K.setVersion(M), void 0 === c || null == c ? (L && (K.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(K)) : c.addAnimation(K), K
        }
    },
    TexCoordSetAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "version");
        b.mRoot.debug && console.log(d, f, g, h, i, j, k, l, m, n, o);
        var p = XMLJS.getAttributeNodeValue(a, "relative"),
            q = XMLJS.getAttributeNodeValue(a, "stack_slice_set"),
            r = XMLJS.getAttributeNodeValue(a, "uvs_set"),
            s = XMLJS.getAttributeNodeValue(a, "uvs_name_set");
        b.mRoot.debug && console.log(p, q, r, s);
        var t = new TexCoordSetAnimation(b.mRoot);
        t.mGroupId = b.mGroupId;
        var u = !0,
            v = 1;
        if (d && t.setName(d), e) {
            var w = b.mRoot.getMesh(e);
            null != w && (t.mTarget = w)
        }
        if (f) {
            var x = f.split(" ");
            f = 2 == x.length ? InterpolatorSet.getInterpolatorInstance(x[0], parseFloat(x[1])) : InterpolatorSet.getInterpolatorInstance(x[0]), t.setInterpolator(f)
        }
        if (g && (g = ~~g, t.setDuration(g)), h && (h = ~~h, t.setRepeatCount(h)), i && t.setRepeatMode(i), j && (j = StringConverter.parseBool(j), t.mCanStop = j), k && (k = ~~k, t.setStartOffset(k)), l && (l = StringConverter.parseBool(l), t.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), t.setFillBefore(m)), n && (u = StringConverter.parseBool(n)), o && (v = ~~o), p && (p = StringConverter.parseBool(p), t.setRelavie(p)), q) {
            var y = q.split(" ");
            if (y.length < 2) return;
            var z = ~~y[0],
                A = ~~y[1],
                B = new TextureSplit;
            if (B.setTextureStacksAndSlices(z, A, !0), y.length < 3) t.setTextureCoordSets(B.getTextureCoords());
            else {
                for (var C = [], D = 2; D < y.length; D++) {
                    var E = ~~y[D];
                    C.push(B.getTextureCoord(E))
                }
                t.setTextureCoordSets(C)
            }
        }
        if (r) {
            r = r.split(";");
            for (var C = [], F = 0; F < r.length; F++) {
                var G = r[F].split(" ");
                if (8 == G.length) {
                    var H = new TRect,
                        I = parseFloat(G[0]),
                        J = parseFloat(G[4]),
                        K = 1 - parseFloat(G[1]),
                        L = 1 - parseFloat(G[5]);
                    H.left = I, H.right = J, H.top = K, H.bottom = L, C.push(H)
                }
            }
            t.setTextureCoordSets(C)
        }
        if (s) {
            var r = StringConverter.parsePath(s).split(" "),
                C = [],
                M = new Task;
            M.uvs_set = r, M.run = function() {
                var a = b.mRoot.getUVSFileParser();
                C = [];
                for (var c = 0, d = b.uvs_set.length; d > c; c++) {
                    var e = a.getUVSRect(b.uvs_set[c]);
                    if (null == e || void 0 == e) return !1;
                    C.push(e)
                }
                return t.setTextureCoordSets(C), !0
            }, b.mRoot.addTask(M)
        }
        return t.setVersion(v), void 0 === c || null == c ? (u && (t.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(t)) : c.addAnimation(t), t
    },
    ValueAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "relative"),
            p = XMLJS.getAttributeNodeValue(a, "version"),
            q = XMLJS.getAttributeNodeValue(a, "mFromIntValue"),
            r = XMLJS.getAttributeNodeValue(a, "mToIntValue"),
            s = XMLJS.getAttributeNodeValue(a, "mFromFloatValue"),
            t = XMLJS.getAttributeNodeValue(a, "mToFloatValue"),
            u = new ValueAnimation(b.mRoot);
        u.mGroupId = b.mGroupId;
        var v = !0,
            w = 1;
        if (d && u.setName(d), e) {
            var x = b.curParsingSceneMgr.getSceneNode(e);
            null != x && (u.mTarget = x.Transform, u.setTarget(x.getMaterial().pass))
        }
        if (f) {
            var y = f.split(" ");
            f = 2 == y.length ? InterpolatorSet.getInterpolatorInstance(y[0], parseFloat(y[1])) : InterpolatorSet.getInterpolatorInstance(y[0]), u.setInterpolator(f)
        }
        if (g && (g = ~~g, u.setDuration(g)), h && (h = ~~h, u.setRepeatCount(h)), i && u.setRepeatMode(i), j && (j = StringConverter.parseBool(j), u.mCanStop = j), k && (k = ~~k, u.setStartOffset(k)), l && (l = StringConverter.parseBool(l), u.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), u.setFillBefore(m)), n && (v = StringConverter.parseBool(n)), p && (w = ~~p), q) {
            var z = parseFloat(q);
            u.setFromIntValue(z)
        }
        if (r) {
            var A = parseFloat(r);
            u.setToIntValue(A)
        }
        if (s) {
            var B = parseFloat(s);
            u.setFromFloatValue(B)
        }
        if (t) {
            var C = parseFloat(t);
            u.setToFloatValue(C)
        }
        return o && (o = StringConverter.parseBool(o), u.setRelavie(o)), u.setVersion(w), void 0 === c || null == c ? (v && (u.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(u)) : c.addAnimation(u), u
    },
    PathSplineNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "pathControlPoints");
        b.mRoot.debug && console.log(c, d);
        var e = null,
            f = b.mRoot.getPathManager();
        if (c && (e = f.createPath(c, "Spline"), e.mGroupId = b.mGroupId), d) {
            for (var g = d.split(/[ ;]+/), h = 0; h < g.length; h += 3) {
                var i = new Vector3(parseFloat(g[h]), parseFloat(g[h + 1]), parseFloat(g[h + 2]));
                e.addControlPoint(i)
            }
            e.generatePath()
        }
        return null != e ? e : null
    },
    PathBrokenLineNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "pathControlPoints");
        b.mRoot.debug && console.log(c, d);
        var e = null,
            f = b.mRoot.getPathManager();
        if (c && (e = f.createPath(c, "BrokenLine"), e.mGroupId = b.mGroupId), d) {
            for (var g = d.split(/[ ;]+/), h = 0; h < g.length; h += 3) {
                var i = new Vector3(parseFloat(g[h]), parseFloat(g[h + 1]), parseFloat(g[h + 2]));
                e.addControlPoint(i)
            }
            e.generatePath()
        }
        return null != e ? e : null
    },
    PathSimpleBezier: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "name"),
            d = XMLJS.getAttributeNodeValue(a, "pathControlPoints");
        b.mRoot.debug && console.log(c, d);
        var e = null,
            f = b.mRoot.getPathManager();
        if (c && (e = f.createPath(c, "SimpleBezier"), e.mGroupId = b.mGroupId), d) {
            for (var g = d.split(/[ ;]+/), h = 0; h < g.length; h += 3) {
                var i = new Vector3(parseFloat(g[h]), parseFloat(g[h + 1]), parseFloat(g[h + 2]));
                e.addControlPoint(i)
            }
            e.generatePath()
        }
        return null != e ? e : null
    },
    PathAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "relative"),
            g = XMLJS.getAttributeNodeValue(a, "interpolator"),
            h = XMLJS.getAttributeNodeValue(a, "duration"),
            i = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            j = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            k = XMLJS.getAttributeNodeValue(a, "canstop"),
            l = XMLJS.getAttributeNodeValue(a, "startOffset"),
            m = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            n = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            o = XMLJS.getAttributeNodeValue(a, "start"),
            p = XMLJS.getAttributeNodeValue(a, "version");
        b.mRoot.debug && console.log(d, g, h, i, j, k, l, m, n, o, p);
        var q = XMLJS.getAttributeNodeValue(a, "path"),
            r = XMLJS.getAttributeNodeValue(a, "isAutoRot"),
            s = XMLJS.getAttributeNodeValue(a, "headDirection"),
            t = new PathAnimation(b.mRoot);
        t.mGroupId = b.mGroupId;
        var u = !0,
            v = 1;
        if (d && t.setName(d), e) {
            var w = b.curParsingSceneMgr.getSceneNode(e);
            null != w && (t.mTarget = w.Transform)
        }
        if (f && (f = "true" == f, t.setRelavie(f)), g) {
            var x = g.split(" ");
            g = 2 == x.length ? InterpolatorSet.getInterpolatorInstance(x[0], parseFloat(x[1])) : InterpolatorSet.getInterpolatorInstance(x[0]), t.setInterpolator(g)
        }
        if (h && (h = ~~h, t.setDuration(h)), i && (i = ~~i, t.setRepeatCount(i)), j && t.setRepeatMode(j), k && (t.mCanStop = StringConverter.parseBool(k)), l && (l = ~~l, t.setStartOffset(l)), m && (m = StringConverter.parseBool(m), t.setFillEnabled(m)), n && (n = StringConverter.parseBool(n), t.setFillBefore(n)), o && (u = StringConverter.parseBool(o)), p && (v = ~~p), q) {
            q = b.mRoot.getPathManager().findPath(q);
            var y = t.setPath(q);
            y || b.mRoot.debug && console.log("Cannot find the path.")
        }
        if (r && t.setRotAuto("true" == r), s) {
            var z = StringConverter.parseVec3(s);
            t.setHeadDirection(z)
        }
        return t.setVersion(v), void 0 === c || null == c ? (u && (t.startAnimation(), b.mRoot.debug && console.log("PathAnimationNodeParse started")), b.mRoot.mAnimationManager.registerAnimation(t)) : c.addAnimation(t), t
    },
    SequenceFrameAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "version");
        b.mRoot.debug && console.log(d, f, g, h, i, j, k, l, m, n, o);
        var p = XMLJS.getAttributeNodeValue(a, "relative"),
            q = XMLJS.getAttributeNodeValue(a, "path"),
            r = XMLJS.getAttributeNodeValue(a, "isAutoRot"),
            s = XMLJS.getAttributeNodeValue(a, "headDirection");
        b.mRoot.debug && console.log(p, q, r, s);
        var t = new SequenceFrameAnimation(b.mRoot);
        t.mGroupId = b.mGroupId;
        var u = !0,
            v = 1;
        if (d && t.setName(d), e) {
            var w = b.curParsingSceneMgr.getSceneNode(e);
            null != w && (t.mTarget = w.Transform)
        }
        if (f) {
            var x = f.split(" ");
            f = 2 == x.length ? InterpolatorSet.getInterpolatorInstance(x[0], parseFloat(x[1])) : InterpolatorSet.getInterpolatorInstance(x[0]), t.setInterpolator(f)
        }
        return g && (g = ~~g, t.setDuration(g)), h && (h = ~~h, t.setRepeatCount(h)), i && t.setRepeatMode(i), j && (j = StringConverter.parseBool(j), t.mCanStop = j), k && (k = ~~k, t.setStartOffset(k)), l && (l = StringConverter.parseBool(l), t.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), t.setFillBefore(m)), n && (u = StringConverter.parseBool(n)), o && (v = ~~o), t.setVersion(v), void 0 === c || null == c ? (u && (t.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(t)) : c.addAnimation(t), t
    },
    KeyFramesNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "src");
        if (d) {
            b.mRoot.debug && console.log("Load keyFrames source..");
            var e = b.mRoot.getKeyFramesManager();
            e.src = d, e.load(b)
        }
    },
    KeyFramesTranslateAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "version");
        b.mRoot.debug && console.log(d, f, g, h, i, j, k, l, m, n, o);
        var p = XMLJS.getAttributeNodeValue(a, "TransformSpace"),
            q = XMLJS.getAttributeNodeValue(a, "isCoordinateRelativeToScreen"),
            r = XMLJS.getAttributeNodeValue(a, "relative"),
            s = XMLJS.getAttributeNodeValue(a, "numFrames"),
            t = XMLJS.getAttributeNodeValue(a, "kfsName");
        b.mRoot.debug && console.log(r, p, q, s, t);
        var u = new KeyFramesTranslateAnimation(b.mRoot);
        u.mGroupId = b.mGroupId;
        var v = !0,
            w = 1;
        if (d && u.setName(d), e) {
            var x = b.curParsingSceneMgr.getSceneNode(e);
            null != x && (u.mTarget = x.Transform)
        }
        if (f) {
            var y = f.split(" ");
            f = 2 == y.length ? InterpolatorSet.getInterpolatorInstance(y[0], parseFloat(y[1])) : InterpolatorSet.getInterpolatorInstance(y[0]), u.setInterpolator(f)
        }
        if (g && (g = ~~g, u.setDuration(g)), h && (h = ~~h, u.setRepeatCount(h)), i && u.setRepeatMode(i), j && (j = StringConverter.parseBool(j), u.mCanStop = j), k && (k = ~~k, u.setStartOffset(k)), l && (l = StringConverter.parseBool(l), u.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), u.setFillBefore(m)), n && (v = StringConverter.parseBool(n)), o && (w = ~~o), p && u.setTransformSpace(p), q) {
            var z = StringConverter.parseBool(q);
            u.setIsCoordinateRelativeToScreen(z)
        }
        r && (r = StringConverter.parseBool(r), u.setRelavie(r)), p && u.setTransformSpace(p), q && u.setIsCoordinateRelativeToScreen(StringConverter.parseBool(q)), s && (s = ~~s), t && (t = t);
        var A = new Task;
        return A.kfsName = t, A.run = function() {
            var a = u.setFrames(s, t);
            return a ? !0 : !1
        }, b.mRoot.addTask(A), u.setVersion(w), void 0 === c || null == c ? (v && (u.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(u)) : c.addAnimation(u), u
    },
    KeyFramesRotateAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "version");
        b.mRoot.debug && console.log(d, f, g, h, i, j, k, l, m, n, o);
        var p = XMLJS.getAttributeNodeValue(a, "TransformSpace"),
            q = XMLJS.getAttributeNodeValue(a, "isCoordinateRelativeToScreen"),
            r = XMLJS.getAttributeNodeValue(a, "relative"),
            s = XMLJS.getAttributeNodeValue(a, "numFrames"),
            t = XMLJS.getAttributeNodeValue(a, "kfsName");
        b.mRoot.debug && console.log(p, q, r, s, t);
        var u = new KeyFramesRotateAnimation(b.mRoot);
        u.mGroupId = b.mGroupId;
        var v = !0,
            w = 1;
        if (d && u.setName(d), e) {
            var x = b.curParsingSceneMgr.getSceneNode(e);
            null != x && (u.mTarget = x.Transform)
        }
        if (f) {
            var y = f.split(" ");
            f = 2 == y.length ? InterpolatorSet.getInterpolatorInstance(y[0], parseFloat(y[1])) : InterpolatorSet.getInterpolatorInstance(y[0]), u.setInterpolator(f)
        }
        if (g && (g = ~~g, u.setDuration(g)), h && (h = ~~h, u.setRepeatCount(h)), i && u.setRepeatMode(i), j && (j = StringConverter.parseBool(j), u.mCanStop = j), k && (k = ~~k, u.setStartOffset(k)), l && (l = StringConverter.parseBool(l), u.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), u.setFillBefore(m)), n && (v = StringConverter.parseBool(n)), o && (w = ~~o), p && u.setTransformSpace(p), q) {
            var z = StringConverter.parseBool(q);
            u.setIsCoordinateRelativeToScreen(z)
        }
        r && (r = StringConverter.parseBool(r), u.setRelavie(r)), p && u.setTransformSpace(p), q && u.setIsCoordinateRelativeToScreen(StringConverter.parseBool(q)), s && (s = ~~s), t && (t = t);
        var A = new Task;
        return A.kfsName = t, A.run = function() {
            return u.setFrames(s, t)
        }, b.mRoot.addTask(A), u.setVersion(w), void 0 === c || null == c ? (v && (u.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(u)) : c.addAnimation(u), u
    },
    KeyFramesScaleAnimationNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "target"),
            f = XMLJS.getAttributeNodeValue(a, "interpolator"),
            g = XMLJS.getAttributeNodeValue(a, "duration"),
            h = XMLJS.getAttributeNodeValue(a, "repeatCount"),
            i = XMLJS.getAttributeNodeValue(a, "repeatMode"),
            j = XMLJS.getAttributeNodeValue(a, "canstop"),
            k = XMLJS.getAttributeNodeValue(a, "startOffset"),
            l = XMLJS.getAttributeNodeValue(a, "fillEnabled"),
            m = XMLJS.getAttributeNodeValue(a, "fillBefore"),
            n = XMLJS.getAttributeNodeValue(a, "start"),
            o = XMLJS.getAttributeNodeValue(a, "version");
        b.mRoot.debug && console.log(d, f, g, h, i, j, k, l, m, n, o);
        var p = XMLJS.getAttributeNodeValue(a, "TransformSpace"),
            q = XMLJS.getAttributeNodeValue(a, "isCoordinateRelativeToScreen"),
            r = XMLJS.getAttributeNodeValue(a, "relative"),
            s = XMLJS.getAttributeNodeValue(a, "numFrames"),
            t = XMLJS.getAttributeNodeValue(a, "kfsName");
        b.mRoot.debug && console.log(p, q, r, s, t);
        var u = new KeyFramesScaleAnimation(b.mRoot);
        u.mGroupId = b.mGroupId;
        var v = !0,
            w = 1;
        if (d && u.setName(d), e) {
            var x = b.curParsingSceneMgr.getSceneNode(e);
            null != x && (u.mTarget = x.Transform)
        }
        if (f) {
            var y = f.split(" ");
            f = 2 == y.length ? InterpolatorSet.getInterpolatorInstance(y[0], parseFloat(y[1])) : InterpolatorSet.getInterpolatorInstance(y[0]), u.setInterpolator(f)
        }
        if (g && (g = ~~g, u.setDuration(g)), h && (h = ~~h, u.setRepeatCount(h)), i && u.setRepeatMode(i), j && (j = StringConverter.parseBool(j), u.mCanStop = j), k && (k = ~~k, u.setStartOffset(k)), l && (l = StringConverter.parseBool(l), u.setFillEnabled(l)), m && (m = StringConverter.parseBool(m), u.setFillBefore(m)), n && (v = StringConverter.parseBool(n)), o && (w = ~~o), p && u.setTransformSpace(p), q) {
            var z = StringConverter.parseBool(q);
            u.setIsCoordinateRelativeToScreen(z)
        }
        r && (r = StringConverter.parseBool(r), u.setRelavie(r)), p && u.setTransformSpace(p), q && u.setIsCoordinateRelativeToScreen(StringConverter.parseBool(q)), s && (s = ~~s), t && (t = t);
        var A = new Task;
        return A.kfsName = t, A.run = function() {
            var a = u.setFrames(s, t);
            return a ? !0 : !1
        }, b.mRoot.addTask(A), u.setVersion(w), void 0 === c || null == c ? (v && (u.startAnimation(), b.mRoot.debug && console.log("translate started")), b.mRoot.mAnimationManager.registerAnimation(u)) : c.addAnimation(u), u
    },
    ScriptNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "src");
        c && (b.mScriptExist = !0, b.mRoot.mArchive.scriptLoad(c, function() {
            null !== postCreateScene && b.mRoot._setInitSceneCallback(function() {
                postCreateScene(b.mRoot, b.mGroupId, b.mPrefix), b.mRoot.onSize(b.mRoot.getScreenWidth(), b.mRoot.getScreenHeight())
            }), b.mRoot.mIsParsing = !1
        }, b))
    },
    AmbientLightNodeParse: function(a, b) {
        var c = XMLJS.getAttributeNodeValue(a, "value");
        if (c) {
            var d = StringConverter.parseFloatArray(c);
            3 == d.length && (d[3] = 1), b.curParsingSceneMgr.setAmbientLight(d)
        }
    },
    LightNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name");
        if (d) {
            var e = new Light(d);
            e.setGameObject(c), c.mLights.push(e);
            var f = XMLJS.getAttributeNodeValue(a, "visible");
            f && e.setVisible(StringConverter.parseBool(f));
            var g = XMLJS.getAttributeNodeValue(a, "type");
            g && ("point" == g || "point_light" == g ? e.setType(Light.LT_POINT) : "directional" == g || "directional_light" == g ? e.setType(Light.LT_DIRECTIONAL) : ("spot" == g || "spot_light" == g) && e.setType(Light.LT_SPOTLIGHT));
            var h = XMLJS.getAttributeNodeValue(a, "position");
            h && e.setPosition(StringConverter.parseVec3(h));
            var i = XMLJS.getAttributeNodeValue(a, "direction");
            i && e.setDirection(StringConverter.parseVec3(i));
            var j = XMLJS.getAttributeNodeValue(a, "diffuse");
            j && (j = StringConverter.parseFloatArray(j), 3 == j.length && (j[3] = 1), e.setDiffuseColour(j));
            var k = XMLJS.getAttributeNodeValue(a, "specular");
            k && (k = StringConverter.parseFloatArray(k), 3 == k.length && (k[3] = 1), e.setSpecularColour(k));
            var l = XMLJS.getAttributeNodeValue(a, "spot_out");
            l && e.setSpotlightOuterAngle(Math.radians(parseFloat(l)));
            var m = XMLJS.getAttributeNodeValue(a, "spot_inner");
            m && e.setSpotlightInnerAngle(Math.radians(parseFloat(m)));
            var n = XMLJS.getAttributeNodeValue(a, "spot_fall_off");
            n && e.setSpotlightFalloff(parseFloat(n));
            var o = (XMLJS.getAttributeNodeValue(a, "spot_near_clip"), XMLJS.getAttributeNodeValue(a, "range"));
            o && e.setAttenuationRange(parseFloat(o));
            var p = XMLJS.getAttributeNodeValue(a, "attenuation_const");
            p && e.setAttenuationConstant(parseFloat(p));
            var q = XMLJS.getAttributeNodeValue(a, "attenuation_linear");
            q && e.setAttenuationLinear(parseFloat(q));
            var r = XMLJS.getAttributeNodeValue(a, "attenuation_quad");
            r && e.setAttenuationQuadric(parseFloat(r));
            var s = XMLJS.getAttributeNodeValue(a, "power_scale");
            s && e.setPowerScale(parseFloat(s))
        }
    },
    BoneNodeParse: function(a, b, c) {
        var d = XMLJS.getAttributeNodeValue(a, "name"),
            e = XMLJS.getAttributeNodeValue(a, "visible"),
            f = XMLJS.getAttributeNodeValue(a, "index"),
            g = XMLJS.getAttributeNodeValue(a, "skeleton"),
            h = null;
        if (f && (f = parseInt(f)), e && (e = StringConverter.parseBool(e)), h = b.mRoot.getSkeletonManager().getSkeletonByName(b.mGroupId, g), h || (h = b.mRoot.getSkeletonManager().createSkeleton(b.mGroupId, g)), !h) return void console.log("error:skeleton parse error");
        var i = h.createBone(d, f, b.curParsingSceneMgr);
        c ? c.addGameObject(i) : b.curParsingSceneMgr.getSceneRoot().addGameObject(i);
        for (var j = XMLJS.getXMLChildNodes(a), k = 0; k < j.length; k++) {
            var l = j[k],
                m = l.nodeName;
            "GameObject" == m ? this.GameObjectNodeParse(l, b, i) : "Transform" == m ? this.TransformNodeParse(l, b, i) : "Bone" == m && this.BoneNodeParse(l, b, i)
        }
        i.getTransform().setOriginWorldTransform()
    }
};
var Task = function() {};
Task.prototype.run = function() {
    return !0
};
var Plane = function(a, b) {
    this.mNormal = new Vector3(a.x, a.y, a.z), this.mNormal.normalise(), this.mConstant = -b.dot(this.mNormal)
};
Plane.prototype = {
    constructor: Plane,
    distanceToPoint: function(a) {
        return this.mNormal.dot(a) + this.mConstant
    }
};
var Ray = function() {
    this.mOrigin = new Vector3(0, 0, 0), this.mPointInDir = new Vector3(0, 0, 1), this.mDirection, this.mTargetNear = new Vector3(0, 0, 0)
};
Ray.prototype = {
    constructor: Ray,
    setOrigin: function(a) {
        this.mOrigin = a
    },
    setTargetInNearPlane: function(a) {
        this.mTargetNear.x = a.x, this.mTargetNear.y = a.y, this.mTargetNear.z = a.z
    },
    getOrigin: function() {
        return this.mOrigin
    },
    setDirection: function(a) {
        this.mDirection = a
    },
    getDirection: function() {
        return this.mDirection
    },
    getPoint: function(a) {
        return this.mOrigin.add(this.mDirection.multiply(a))
    },
    distanceToPlane: function(a) {
        var b = a.mNormal.dot(this.mDirection);
        if (0 == b) return 0 == a.distanceToPoint(this.mOrigin) ? 0 : null;
        var c = -(this.mOrigin.dot(a.mNormal) + a.mConstant) / b;
        return c >= 0 ? c : null
    },
    intersectPlaneWithNP: function(a, b) {
        var c = new Plane(a, b);
        return this.intersectPlane(c)
    },
    intersectPlane: function(a) {
        var b = this.distanceToPlane(a);
        if (null === b) return null;
        var c = new Vector3(this.mDirection.x * b + this.mOrigin.x, this.mDirection.y * b + this.mOrigin.y, this.mDirection.z * b + this.mOrigin.z),
            d = {};
        return d.interSP = c, d.objDistance = c.sub(this.mOrigin).length(), d
    },
    intersectBox: function(a, b) {
        var c, d, e, f, g, h, i = 1 / this.mDirection.x,
            j = 1 / this.mDirection.y,
            k = 1 / this.mDirection.z,
            l = this.mOrigin;
        if (i >= 0 ? (c = (a.min.x - l.x) * i, d = (a.max.x - l.x) * i) : (c = (a.max.x - l.x) * i, d = (a.min.x - l.x) * i), j >= 0 ? (e = (a.min.y - l.y) * j, f = (a.max.y - l.y) * j) : (e = (a.max.y - l.y) * j, f = (a.min.y - l.y) * j), c > f || e > d) return null;
        if ((e > c || c !== c) && (c = e), (d > f || d !== d) && (d = f), k >= 0 ? (g = (a.min.z - l.z) * k, h = (a.max.z - l.z) * k) : (g = (a.max.z - l.z) * k, h = (a.min.z - l.z) * k), c > h || g > d) return null;
        if ((g > c || c !== c) && (c = g), (d > h || d !== d) && (d = h), 0 > d) return null;
        var m = c >= 0 ? c : d,
            n = new Vector3(this.mDirection.x * m + this.mOrigin.x, this.mDirection.y * m + this.mOrigin.y, this.mDirection.z * m + this.mOrigin.z);
        if (n) {
            var o = {};
            o.interSP = n;
            var p = n.sub(this.mOrigin);
            return o.objDistance = p.length(), o
        }
        return null
    }
};
var PickEntry = function(a, b, c) {
        this.hitObj = a, this.intersectionPoint = new Vector3(b.x, b.y, b.z), this.cameraDistance = c, this.originalOrderIndex = 0
    },
    PickResult = function() {
        this.pickEntries = []
    };
PickResult.prototype = {
    constructor: PickResult,
    addPickedObject: function(a, b, c) {
        var d = new PickEntry(a, b, c);
        this.pickEntries.push(d), d.originalOrderIndex = this.pickEntries.length - 1
    },
    getNearestPickResult: function() {
        return this.pickEntries.length < 1 ? null : (this.sort(), this.pickEntries[0])
    },
    findPickedObjectByName: function(a) {
        if (this.pickEntries.length < 1) return !1;
        this.sort();
        var b = null;
        for (var c in this.pickEntries)
            if (b = this.pickEntries[c].hitObj, 0 == b.getName().localeCompare(a)) return !0;
        return !1
    },
    sort: function() {
        this.pickEntries.reverse()
    }
};
var PickInfo = function(a, b, c) {
    this.screenXCoordinate = a, this.screenYCoordinate = b, this.originalPickRay = c
};
PickInfo.prototype = {
    constructor: Ray,
    getPickRay: function() {
        return this.originalPickRay
    },
    getScreenXCoordinate: function() {
        return this.screenXCoordinate
    },
    getScreenYCoordinate: function() {
        return this.screenYCoordinate
    }
};
var AssetHandle = function(a) {
    a ? this.groupHandle = a : this.groupHandle = null, this.parent = null, this.children = []
};
AssetHandle.prototype = {
    constructor: AssetHandle,
    addChild: function(a) {
        this.children.push(a), a.parent = this
    },
    removeChild: function(a) {
        a.parent = null;
        for (var b = 0; b < this.children.length; ++b)
            if (this.children[b] === a) {
                this.children.splice(b, 1);
                break
            }
    },
    removeFromParent: function() {
        this.parent && this.parent.removeChild(this)
    }
};
var Root = function() {
    this.debug = !1, this.mEngineMode = e3d.ENGINE_MODE.NORMAL, this.mBoxEditor2d = null, this.mBoxEditor2dParameters = {
        closeBtnAsset: null,
        editBtnAsset: null,
        lockBtnAsset: null,
        unlockBtnAsset: null,
        groupHandle: null
    }, this.mRootAssetHandle = new AssetHandle, this.mResourceGroupManager = new ResourceGroupManager, this.mArchive = new Archive(this), this.mKeyFramesManager = new KeyFramesManager(this), this.mAnimationManager = new AnimationManager(this), this.mSkeletonManager = new SkeletonManager(this), this.mScenes = {}, this.mPathManager = new PathManager, this.mAudioManager = new AudioManager(this), this.mVertexProgram = [], this.mFragmentProgram = [], this.mMaterialManager = new MaterialManager(this), this.mMeshMap = {}, this.mTextureManager = new TextureManager(this), this.mUVSParse = new UVSParse(this), this.mTimer = new Timer, this._lastFrameTime = this.mTimer.mStartTime, this._deltaTime = this.mTimer.mStartTime, this._curFrameTime = this.mTimer.mStartTime, this.mPhoneWidth = 0, this.mPhoneHeight = 0, this.mParticleSystemNeedUpdate = !1, this.mHardwareBufferManager = new HardwareBufferManagerBase(this), this.mDeferTask = [], this.mScriptTask = [], this.mCurrentSceneGroupID = null, this.mParticleSystemManager = new ParticleSystemManager(this), this.mRenderFunction = null, this.mAppEventListeners = [], this.mDestroyCallbacks = {}, this.mFrameEventListeners = [], this.mPreparedCallback = null, this.mInitSceneCallback = null, this.mPrepared = !1, this.mIsParsing = !1, this.mIsPaused = !1, this.mBrowserInfo = null
};
Root.prototype = {
    constructor: Root,
    init: function(a, b) {
        this.mCanvas = a, this.debug = void 0 === b ? !0 : b, this.mPhoneWidth = a.width || 0, this.mPhoneHeight = a.height || 0;
        var c = a.getContext("experimental-webgl", {
            antialias: !0,
            alpha: !1
        });
        this.mRenderFunction = new RenderFunction(this, c), this.mRenderFunction.setDefaultGLState(), this.mTouchEvent = new TouchScreenEvent(this, a, a), this._registerTouchEvent()
    },
    setEngineMode: function(a) {
        (this.mEngineMode = a) || (this._leaveEngineMode(a), this.mEngineMode = a)
    },
    getEngineMode: function(a) {
        return this.mEngineMode
    },
    _leaveEngineMode: function(a) {
        switch (a) {
            case e3d.ENGINE_MODE.NORMAL:
                break;
            case e3d.ENGINE_MODE.EDIT_2D:
                this.mBoxEditor2d = null
        }
    },
    _registerTouchEvent: function() {
        var a = this;
        this.mTouchEvent.registerTouchEvent(null, function(a) {}, function(b) {
            a.onTouchEvent(e3d.TOUCH_MOVE, 0, b.x * a.mPhoneWidth, b.y * a.mPhoneHeight)
        }, function(a) {}, function(b) {
            a.onTouchEvent(e3d.TOUCH_DOWN, 0, b.x * a.mPhoneWidth, b.y * a.mPhoneHeight)
        }, function(b) {
            a.onTouchEvent(e3d.TOUCH_UP, 0, b.x * a.mPhoneWidth, b.y * a.mPhoneHeight)
        })
    },
    getScreenWidth: function() {
        return this.mPhoneWidth
    },
    getScreenHeight: function() {
        return this.mPhoneHeight
    },
    onSize: function(a, b) {
        this.mPhoneWidth = a, this.mPhoneHeight = b, this.mParticleSystemManager.resize(a, b);
        for (var c in this.mScenes) this.mScenes[c].resize(a, b);
        for (var d = 0; d < this.mAppEventListeners.length; d++) null != this.mAppEventListeners[d].OnSize && this.mAppEventListeners[d].OnSize(this, a, b)
    },
    _setInitSceneCallback: function(a) {
        this.mInitSceneCallback = a
    },
    _setPreparedCallback: function(a) {
        this.mPreparedCallback = a
    },
    pause: function() {
        this.mIsPaused = !0, this.mParticleSystemManager.onStop(!0), this.mAnimationManager.pauseAnimaitonTime(), this.mAudioManager.pause()
    },
    resume: function() {
        this.mIsPaused = !1, this.mParticleSystemManager.onStop(!1), this.mAnimationManager.resumeAnimation(), this.mAudioManager.resume()
    },
    renderOneFrame: function() {
        this._curFrameTime = this.mTimer.getCurrTime(), this._deltaTime = this._curFrameTime - this._lastFrameTime, this._lastFrameTime = this._curFrameTime;
        for (var a = 0; a < this.mDeferTask.length;) {
            var b = this.mDeferTask[a].run();
            b ? this.mDeferTask.splice(a, 1) : a++
        }
        if (!this.mIsParsing) {
            if (!this.mPrepared) {
                if (!this.mTextureManager.isAllTexturePrepared() || !this.isAllProgramLoaded()) return;
                this.mPrepared = !0, this.mPreparedCallback && this.mPreparedCallback()
            }
            if (!this.mIsPaused) {
                this.fireFrameStarted(), this.mAnimationManager.update();
                for (var a in this.mScenes) this.mScenes[a].renderScene();
                this.fireFrameEnded()
            }
        }
    },
    getDeltaTime: function() {
        return this._deltaTime / 1e3
    },
    getMaterialManager: function() {
        return this.mMaterialManager
    },
    getParticleSystemManager: function() {
        return this.mParticleSystemManager
    },
    onTouchEvent: function(a, b, c, d) {
        this.mParticleSystemManager.onTouchEvent(a, b, c, d);
        for (var e = 0; e < this.mAppEventListeners.length; e++) null != this.mAppEventListeners[e].OnTouchScreen && this.mAppEventListeners[e].OnTouchScreen(this, a, b, c, d);
        if (this.mEngineMode == e3d.ENGINE_MODE.EDIT_2D) {
            if (null == this.mBoxEditor2d && (this.mBoxEditor2d = new BoxEditor2d(this, "_boxEditor", this.mBoxEditor2dParameters.closeBtnAsset, this.mBoxEditor2dParameters.editBtnAsset, this.mBoxEditor2dParameters.groupHandle)), a == e3d.TOUCH_DOWN) {
                for (var e in this.mScenes) {
                    var f = this.mScenes[e],
                        g = f.getComponentAt(c, d, !1, BoxEditor2d.TAG).hitObj;
                    if (!this.mBoxEditor2d.isInternalComponent(g) && this.mBoxEditor2d.getAttachedGameObject() != g && null != g && null != g.getParent()) {
                        this.mBoxEditor2d.attachToGameObject(g);
                        break
                    }
                }
                null != g && null != g.getParent() || null == this.mBoxEditor2d.getAttachedGameObject() || this.mBoxEditor2d._isTouchWholeBox(c, d) || this.mBoxEditor2d.detachGameObject()
            }
            null != this.mBoxEditor2d.getAttachedGameObject() && this.mBoxEditor2d.OnTouchEvent(a, c, d)
        }
    },
    getTimer: function() {
        return this.mTimer
    },
    getAudioManager: function() {
        return this.mAudioManager
    },
    getKeyFramesManager: function() {
        return this.mKeyFramesManager
    },
    getAnimationManager: function() {
        return this.mAnimationManager
    },
    getPathManager: function() {
        return this.mPathManager
    },
    getHardwareBufferManager: function() {
        return this.mHardwareBufferManager
    },
    getUVSFileParser: function() {
        return this.mUVSParse
    },
    addTask: function(a) {
        this.mDeferTask.push(a)
    },
    addScriptTask: function(a) {
        this.mScriptTask.push(a)
    },
    getSceneManager: function(a) {
        return this.mScenes[a]
    },
    getMesh: function(a) {
        if (a instanceof Mesh) return a;
        if (a instanceof ParticleSystem) return a;
        for (var b in this.mMeshMap) {
            var c = b.charCodeAt(b.length - 1);
            if (0 === c) {
                if (0 == b.substr(0, b.length - 1).localeCompare(a)) return this.mMeshMap[b]
            } else if (0 == b.localeCompare(a)) return this.mMeshMap[b]
        }
        return null
    },
    getTextureManager: function() {
        return this.mTextureManager
    },
    setFrameEventDelegate: function(a) {
        for (var b = 0; b < this.mFrameEventListeners.length; b++)
            if (this.mFrameEventListeners[b] === a) return;
        this.mFrameEventListeners.push(a)
    },
    removeFrameEventDelegate: function(a) {
        for (var b = 0; b < this.mFrameEventListeners.length;) this.mFrameEventListeners[b] === a ? this.mFrameEventListeners.splice(b, 1) : b++
    },
    fireFrameStarted: function() {
        for (var a = 0; a < this.mFrameEventListeners.length; a++) this.mFrameEventListeners[a].OnFrameStarted && this.mFrameEventListeners[a].OnFrameStarted()
    },
    fireFrameEnded: function() {
        for (var a = 0; a < this.mFrameEventListeners.length; a++) this.mFrameEventListeners[a].OnFrameEnded && this.mFrameEventListeners[a].OnFrameEnded()
    },
    releaseResourceByGroupId: function(a) {
        null != this.mBoxEditor2d && this.mBoxEditor2d.detachGameObject();
        for (var b in this.mScenes) this.mScenes[b].releaseResourceByGroupId(a);
        this.mMaterialManager.releaseByGroupId(a), this.getRenderFunction().releaseLinkProgramByGroupId(a);
        for (var b = 0; b < this.mVertexProgram.length;) this.mVertexProgram[b].mGroupId == a ? this.mVertexProgram.splice(b, 1) : b++;
        for (var b = 0; b < this.mFragmentProgram.length;) this.mFragmentProgram[b].mGroupId == a ? this.mFragmentProgram.splice(b, 1) : b++;
        this.mMaterialManager.releaseByGroupId(a), this.mTextureManager.releaseByGroupId(a);
        for (var b in this.mMeshMap) this.mMeshMap[b].mGroupId == a && delete this.mMeshMap[b];
        this.mParticleSystemManager.releaseResourceByGroupId(a), this.mKeyFramesManager.releaseResourceByGroupId(a), this.mAnimationManager.releaseResourceByGroupId(a), this.mAudioManager.releaseByGroupId(a);
        for (var b in this.mScenes) this.mScenes[b].releaseResourcesByGroupID(a);
        this.mTouchEvent.removeTouchEventByOwner(a);
        for (var c in this.mDestroyCallbacks) c == a && (this.mDestroyCallbacks[c][0].call(this.mDestroyCallbacks[c][1]), delete this.mDestroyCallbacks[c])
    },
    releaseAllResources: function() {
        null != this.mBoxEditor2d && this.mBoxEditor2d.detachGameObject(), this.mTextureManager.releaseAll();
        for (var a in this.mDestroyCallbacks) this.mDestroyCallbacks[a][0].call(this.mDestroyCallbacks[a][1]), delete this.mDestroyCallbacks[a]
    },
    getRenderFunction: function() {
        return this.mRenderFunction
    },
    getProgram: function(a) {
        for (var b = 0; b < this.mVertexProgram.length; b++)
            if (this.mVertexProgram[b].name === a) return this.mVertexProgram[b];
        for (var b = 0; b < this.mFragmentProgram.length; b++)
            if (this.mFragmentProgram[b].name === a) return this.mFragmentProgram[b];
        return null
    },
    isAllProgramLoaded: function() {
        for (var a = 0; a < this.mVertexProgram.length; a++)
            if (!this.mVertexProgram[a].isLoaded()) return !1;
        for (var a = 0; a < this.mFragmentProgram.length; a++)
            if (!this.mFragmentProgram[a].isLoaded()) return !1;
        return !0
    },
    setAppEventDelegate: function(a) {
        for (var b = 0; b < this.mAppEventListeners.length;) {
            if (this.mAppEventListeners[b] == a) return;
            b++
        }
        this.mAppEventListeners.push(a)
    },
    removeAppEventDelegate: function(a) {
        for (var b = 0; b < this.mAppEventListeners.length;) {
            if (this.mAppEventListeners[b] == a) return void this.mAppEventListeners.splice(b, 1);
            b++
        }
    },
    addOnDestroyCallback: function(a, b, c) {
        null == this.mDestroyCallbacks[c] && (this.mDestroyCallbacks[c] = [a, b])
    },
    setParticleSystemDelegate: function(a, b) {
        this.mParticleSystemManager.setParticleSystemListener(a, b)
    },
    removeParticleSystemDelegate: function(a, b) {
        this.mParticleSystemManager.setParticleSystemListener(a, null)
    },
    getCanvasRatio: function(a) {
        var b = a.getBoundingClientRect(),
            c = 720,
            d = 1280;
        if (b.width > b.height) {
            var e = c;
            c = d, d = e
        }
        var f = c / b.width,
            g = d / b.height,
            h = f > g ? g : f,
            i = window.devicePixelRatio > h ? h : window.devicePixelRatio;
        return 1 > i && (i = 1), i
    },
    destroy: function() {
        this.releaseAllResources()
    },
    getSkeletonManager: function() {
        return this.mSkeletonManager
    },
    getTextureVideoManager: function() {
        var a = this;
        return {
            getTextureVideo: function(b, c) {
                var d = b.substring(0, b.length - 6),
                    e = a.getMaterialManager().getByName(d, c),
                    f = e.pass.TextureUnitStates[0];
                return {
                    loadFromFile: function(b) {
                        a.mArchive.videoLoad(b, function(a) {
                            f.setTexture(a), e.mForbidden = !1
                        }, f.mPrefix)
                    }
                }
            }
        }
    },
    getBrowserInfo: function() {
        if (!this.mBrowserInfo) {
            navigator.userAgent || navigator.appVersion;
            this.mBrowserInfo = {
                trident: navigator.userAgent.indexOf("Trident") > -1,
                presto: navigator.userAgent.indexOf("Presto") > -1,
                webKit: navigator.userAgent.indexOf("AppleWebKit") > -1,
                gecko: navigator.userAgent.indexOf("Gecko") > -1 && -1 == navigator.userAgent.indexOf("KHTML"),
                mobile: !!navigator.userAgent.match(/AppleWebKit.*Mobile.*/),
                ios: !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),
                android: navigator.userAgent.indexOf("Android") > -1 || navigator.userAgent.indexOf("Linux") > -1,
                iPhone: navigator.userAgent.indexOf("iPhone") > -1 || navigator.userAgent.indexOf("Mac") > -1,
                iPad: navigator.userAgent.indexOf("iPad") > -1,
                webApp: -1 == navigator.userAgent.indexOf("Safari"),
                wx: "micromessenger" == navigator.userAgent.toLowerCase().match(/MicroMessenger/i)
            }
        }
        return this.mBrowserInfo
    }
};
var SceneManager = function(a, b, c) {
    ResourceManager.call(this), this.mRoot = a, this.name = b, this.clear_depth = 1, this.mSceneNodeMap = {}, this.mSceneRoot = this.createGameObject("scene_root", c), this.mCameras = {}, this.mRenderTargets = [], this.mRenderQueue = new RenderQueue, this.registerTouchEvent(), this.mAmbientLight = [0, 0, 0, 1], this.mLights = [], this.mLightsAffectingFrustum = [], this.currentPickEntry = null
};
extend(SceneManager, ResourceManager), SceneManager.prototype = {
    constructor: SceneManager,
    getSceneRoot: function() {
        return this.mSceneRoot
    },
    createGameObject: function(a, b) {
        var c = new GameObject(this.mRoot, a, b);
        return c.mSceneManager = this, c && (this.mSceneNodeMap[a] = c), c
    },
    createCamera: function(a) {
        for (var b in this.mCameras)
            if (0 == b.localeCompare(a)) return this.mCameras[b];
        var c = new Camera(this);
        return this.mCameras[a] = c, c
    },
    getCamera: function(a) {
        return this.mCameras[a]
    },
    getName: function() {
        return this.name
    },
    getSceneNode: function(a) {
        return this.mSceneNodeMap[a]
    },
    addToSceneNodes: function(a) {
        var b = a.getName();
        a.mGroupId;
        return this.getSceneNode(b) ? (console.log("hascreated the sameName gameobject name=" + b), !1) : (a && (this.mSceneNodeMap[b] = a), !0)
    },
    getComponentAt: function(a, b, c, d) {
        null == c && (c = !0), null == d && (d = -1);
        var e = null,
            f = new PickResult;
        if (null == this.mRoot.getRenderFunction().getCamera()) return null;
        var g = this.mRoot.getRenderFunction().getCamera().getCameraToViewportRay(a / this.mRoot.mPhoneWidth, b / this.mRoot.mPhoneHeight),
            h = new PickInfo(a, b, g);
        return this.mSceneRoot.pickRecursive(h, f, 1e6, h.getPickRay(), c, d), e = f.getNearestPickResult()
    },
    getSceneNodesByTag: function(a) {
        var b = [];
        for (var c in this.mSceneNodeMap) this.mSceneNodeMap[c].getTag() === a && b.push(this.mSceneNodeMap[c]);
        return b
    },
    releaseResourceByGroupId: function(a) {
        var b = null;
        for (var c in this.mSceneNodeMap) this.mSceneNodeMap[c].mGroupId === a && delete this.mSceneNodeMap[c];
        for (var d = 0; d < this.mSceneRoot.children.length;) b = this.mSceneRoot.children[d], b.mGroupId == a ? this.mSceneRoot.children.splice(d, 1) : d++
    },
    collectLights: function() {
        this.mLights = [];
        for (var a in this.mSceneNodeMap) {
            var b = this.mSceneNodeMap[a].mLights;
            0 != b.length && (this.mLights = this.mLights.concat(b))
        }
    },
    findLightsAffectingFrustum: function() {
        this.mLightsAffectingFrustum = this.mLights
    },
    renderScene: function() {
        for (var a in this.mRenderTargets) {
            var b = this.mRenderTargets[a];
            b.isActive() && (b.bind(), this.mRoot.getRenderFunction()._setViewport(b.mViewport), b.mViewport.getClearEveryFrame() && this.mRoot.getRenderFunction().clearFrameBuffer(b.mViewport.mBackColor, 1), this.mRoot.getRenderFunction().setCamera(b.mViewport.getCamera()), this.mRoot.getRenderFunction().setAmbientLightColour(this.mAmbientLight), this.collectLights(), this.findLightsAffectingFrustum(b.mViewport.getCamera()), this.findVisibleObject(), this.renderVisibleObjects(), this.mRenderQueue.clear(), b.unbind())
        }
    },
    findVisibleObject: function() {
        this.mSceneRoot.findVisibleObject(this.mRenderQueue)
    },
    renderVisibleObjects: function() {
        this.mRenderQueue.acceptVisitor(this)
    },
    visit: function(a, b) {
        this.renderSingleObject(a, b)
    },
    renderSingleObject: function(a, b) {
        var c = this.mRoot.getMesh(a.MeshFilter.mesh),
            d = a.Renderer.material,
            e = this.mRoot.getRenderFunction();
        if (d && !d.mForbidden && d.updateDoubleRender(b), null != c && null != d && !d.mForbidden) {
            a.MeshFilter.mesh = c;
            var f = a.getTransform();
            null != f && e.setWorldMatrices(f._getFullTransform()), this._setPass(d.pass);
            var g = [];
            g = this.mLightsAffectingFrustum, e.setCurrentLightList(g), e.mActiveLinkProgram.updateAutoUniforms(), e.mActiveLinkProgram.updateUniforms(), this.renderMesh(a, c, d.pass)
        }
    },
    _setPass: function(a) {
        a.buildProgram();
        var b = this.mRoot.getRenderFunction();
        b.mCurrentPass = a, b.bindGpuProgram(a.vertexProgram), b.bindGpuProgram(a.fragmentProgram), b.getActiveLinkProgram(), b._setSceneBlending(a.mSourceBlendFactor, a.mDestBlendFactor, a.mBlendOperation), b._setDepthBufferCheckEnabled(a.mDepthCheck), b._setDepthBufferWriteEnabled(a.mDepthWrite), b._setCullingMode(a.mCullMode);
        for (var c = a.TextureUnitStates, d = 0; d < c.length; d++) b._setTextureUnitSettings(d, c[d]);
        b._disableTextureUnitsFrom(a.TextureUnitStates.length)
    },
    renderMesh: function(a, b, c) {
        var d = [];
        b.getRenderOperation(d);
        for (var e = this.mRoot.getRenderFunction(), f = 0; f < d.length; f++) a && a.mMeshSkeleton && a.mMeshSkeleton.updateCurrentSubMeshBoneMatrixToGPU(c, b, f, this.root), e._render(d[f])
    },
    registerTouchEvent: function() {
        var a = this;
        this.mRoot.mTouchEvent.registerTouchEvent(null, function(a) {}, function(b) {
            a.onTouchEvent(2, 0, b.x * a.mRoot.mPhoneWidth, b.y * a.mRoot.mPhoneHeight)
        }, function(a) {}, function(b) {
            a.onTouchEvent(0, 0, b.x * a.mRoot.mPhoneWidth, b.y * a.mRoot.mPhoneHeight)
        }, function(b) {
            a.onTouchEvent(1, 0, b.x * a.mRoot.mPhoneWidth, b.y * a.mRoot.mPhoneHeight)
        })
    },
    onTouchEvent: function(a, b, c, d) {
        this.mRoot.getEngineMode() != e3d.ENGINE_MODE.EDIT_2D && (a == e3d.TOUCH_DOWN && (this.currentPickEntry = this.getComponentAt(c, d)), a == e3d.TOUCH_UP && (this.currentPickEntry = this.getComponentAt(c, d)), this.currentPickEntry && this.currentPickEntry.hitObj.onTouchEvent(a, b, c, d, this.currentPickEntry))
    },
    setAmbientLight: function(a) {
        a instanceof Array ? this.mAmbientLight = a : this.mAmbientLight = [a.r, a.g, a.b, a.a]
    },
    getAmbientLight: function() {
        return this.mAmbientLight
    },
    releaseResourcesByGroupID: function(a) {
        this.mSceneRoot.eraseChildrenByGroupID(a)
    },
    destroyGameObjects: function() {
        this.mSceneRoot.children = []
    },
    destroy: function() {
        this.destroyGameObjects()
    },
    resize: function(a, b) {
        for (var c in this.mRenderTargets) RenderTarget.mType == RTType.RENDER_WINDOW && this.mRenderTargets[c].resize(a, b)
    },
    getRenderTarget: function(a) {
        return this.mRenderTargets[a]
    }
};
var RenderFunction = function(a, b) {
    this.mRoot = a, this.mCurrentVertexProgram = null, this.mCurrentFragmentProgram = null, this.mActiveLinkProgram = null, this.mLinkProgramMap = {}, this.mCurrentViewport = null, this.mCurrentPass = null, this.mViewport = [0, 0, 0, 0], this.mScissor = [0, 0, 0, 0], this.gl = b, this.mCurrentCamera = null, this.mCurrentLightList = null, this.mWorldMatrix = new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this.mWorldViewMatrix = null, this.mViewProjMatrix = null, this.mWorldViewProjMatrix = null, this.mInverseWorldMatrix = null, this.mInverseWorldViewMatrix = null, this.mInverseViewMatrix = null, this.mInverseTransposeWorldMatrix = null, this.mInverseTransposeWorldViewMatrix = null, this.mViewMatrix = null, this.mProjectionMatrix = null, this.mAmbientLight = [0, 0, 0, 0], this.mWorldMatrixDirty = !0, this.mViewMatrixDirty = !0, this.mProjMatrixDirty = !0, this.mWorldViewMatrixDirty = !0, this.mViewProjMatrixDirty = !0, this.mWorldViewProjMatrixDirty = !0, this.mInverseWorldMatrixDirty = !0, this.mInverseWorldViewMatrixDirty = !0, this.mInverseViewMatrixDirty = !0, this.mInverseTransposeWorldMatrixDirty = !0, this.mInverseTransposeWorldViewMatrixDirty = !0, this.mSpotlightViewProjMatrixDirty = [], this.mSpotlightWorldViewProjMatrixDirty = [];
    for (var c = 0; c < e3d.E3D_MAX_SIMULTANEOUS_LIGHTS; ++c) this.mSpotlightViewProjMatrixDirty[c] = !0, this.mSpotlightWorldViewProjMatrixDirty[c] = !0;
    this.mBlankLight = new Light, this.mBlankLight.setDiffuseColour([0, 0, 0, 1]), this.mBlankLight.setSpecularColour([0, 0, 0, 1]), this.mBlankLight.setAttenuation(0, 1, 0, 0);
};
RenderFunction.prototype = {
    constructor: RenderFunction,
    setDefaultGLState: function() {
        this.gl.clearColor(0, 0, 0, 1), this.gl.clearDepth(1), this.gl.clearStencil(0), this.gl.enable(this.gl.DEPTH_TEST), this.gl.depthFunc(this.gl.LEQUAL), this.gl.frontFace(this.gl.CCW), this.gl.cullFace(this.gl.BACK), this.gl.enable(this.gl.CULL_FACE), this.gl.blendEquation(this.gl.FUNC_ADD), this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA)
    },
    clearFrameBuffer: function(a, b) {
        this.gl.clearColor(a[0], a[1], a[2], a[3]), this.gl.clearDepth(b), this.gl.depthFunc(this.gl.LEQUAL), this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)
    },
    bindGpuProgram: function(a) {
        switch (a.type) {
            case VERTEX_SHADER:
                this.mCurrentVertexProgram != a && (this.mCurrentVertexProgram && this.mCurrentVertexProgram.unbindProgram(), this.mCurrentVertexProgram = a);
                break;
            case FRAGMENT_SHADER:
                this.mCurrentFragmentProgram != a && (this.mCurrentFragmentProgram && this.mCurrentFragmentProgram.unbindProgram(), this.mCurrentFragmentProgram = a)
        }
        a.bindProgram()
    },
    _setSceneBlending: function(a, b, c) {
        var d = this.getBlendMode(a),
            e = this.getBlendMode(b);
        a == SBF_ONE && b == SBF_ZERO ? this.gl.disable(this.gl.BLEND) : (this.gl.enable(this.gl.BLEND), this.gl.blendFunc(d, e));
        var f = this.gl.FUNC_ADD;
        switch (c) {
            case SBO_ADD:
                f = this.gl.FUNC_ADD;
                break;
            case SBO_SUBTRACT:
                f = this.gl.FUNC_SUBTRACT;
                break;
            case SBO_REVERSE_SUBTRACT:
                f = this.gl.FUNC_REVERSE_SUBTRACT
        }
        this.gl.blendEquation(f)
    },
    _setTextureUnitSettings: function(a, b) {
        if (null != b.getTexture()) {
            this._setTexture(a, !0, b.texture);
            var c = b.getTextureAddressingMode();
            this._setTextureAddressingMode(a, c)
        }
    },
    _setTexture: function(a, b, c) {
        this.gl.activeTexture(this.gl.TEXTURE0 + a), b ? c.bind() : this.gl.bindTexture(this.gl.TEXTURE_2D, null), this.gl.activeTexture(this.gl.TEXTURE0 + 0)
    },
    _setViewport: function(a) {
        this.mCurrentViewport = a;
        var b = a.getActualWidth(),
            c = a.getActualHeight(),
            d = a.getActualLeft(),
            e = a.getActualTop();
        (this.mViewport[0] != d || this.mViewport[1] != e || this.mViewport[2] != b || this.mViewport[3] != c) && (this.mViewport[0] = d, this.mViewport[1] = e, this.mViewport[2] = b, this.mViewport[3] = c, this.gl.viewport(d, e, b, c)), (this.mScissor[0] != d || this.mScissor[1] != e || this.mScissor[2] != b || this.mScissor[3] != c) && (this.mScissor[0] = d, this.mScissor[1] = e, this.mScissor[2] = b, this.mScissor[3] = c, this.gl.enable(this.gl.SCISSOR_TEST), this.gl.scissor(d, e, b, c))
    },
    _setTextureAddressingMode: function(a, b) {
        this.gl.activeTexture(this.gl.TEXTURE0 + a), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.getTextureAddressingMode(b.u)), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.getTextureAddressingMode(b.v))
    },
    getTextureAddressingMode: function(a) {
        switch (a) {
            case TAM_CLAMP:
            case TAM_BORDER:
                return this.gl.CLAMP_TO_EDGE;
            case TAM_MIRROR:
                return this.gl.MIRRORED_REPEAT;
            case TAM_WRAP:
            default:
                return this.gl.REPEAT
        }
    },
    _disableTextureUnitsFrom: function(a) {
        for (var b = 8, c = a; b > c; c++) this._setTexture(c, !1, null)
    },
    getLinkProgram: function(a) {
        return this.mLinkProgramMap[a]
    },
    getActiveLinkProgram: function() {
        if (null != this.mCurrentVertexProgram && null != this.mCurrentFragmentProgram) {
            var a = this.mCurrentVertexProgram.name + "-" + this.mCurrentFragmentProgram.name,
                b = this.mLinkProgramMap[a];
            null == b ? (b = new LinkProgram(this.mRoot, this.mCurrentVertexProgram, this.mCurrentFragmentProgram), this.mLinkProgramMap[a] = b, this.mActiveLinkProgram = b) : b != this.mActiveLinkProgram && (this.mActiveLinkProgram = b), this.mActiveLinkProgram.activate()
        }
    },
    _setScissor: function(a, b) {
        this.gl.disable(this.gl.SCISSOR_TEST), a.mScissor && (this.gl.enable(this.gl.SCISSOR_TEST), this.gl.scissor(0, 250, 720, 300))
    },
    _setCullingMode: function(a) {
        switch (a) {
            case CULL_NONE:
                this.gl.disable(this.gl.CULL_FACE);
                break;
            default:
            case CULL_CLOCKWISE:
                this.gl.enable(this.gl.CULL_FACE), this.gl.cullFace(this.gl.FRONT);
                break;
            case CULL_ANTICLOCKWISE:
                this.gl.enable(this.gl.CULL_FACE), this.gl.cullFace(this.gl.BACK)
        }
    },
    getBlendMode: function(a) {
        switch (a) {
            case SBF_ONE:
                return this.gl.ONE;
            case SBF_ZERO:
                return this.gl.ZERO;
            case SBF_DEST_COLOUR:
                return this.gl.DST_COLOR;
            case SBF_SOURCE_COLOUR:
                return this.gl.SRC_COLOR;
            case SBF_ONE_MINUS_DEST_COLOUR:
                return this.gl.ONE_MINUS_DST_COLOR;
            case SBF_ONE_MINUS_SOURCE_COLOUR:
                return this.gl.ONE_MINUS_SRC_COLOR;
            case SBF_DEST_ALPHA:
                return this.gl.DST_ALPHA;
            case SBF_SOURCE_ALPHA:
                return this.gl.SRC_ALPHA;
            case SBF_ONE_MINUS_DEST_ALPHA:
                return this.gl.ONE_MINUS_DST_ALPHA;
            case SBF_ONE_MINUS_SOURCE_ALPHA:
                return this.gl.ONE_MINUS_SRC_ALPHA
        }
        return this.gl.ONE
    },
    _setDepthBufferCheckEnabled: function(a) {
        a ? this.gl.enable(this.gl.DEPTH_TEST) : this.gl.disable(this.gl.DEPTH_TEST)
    },
    _setDepthBufferWriteEnabled: function(a) {
        this.gl.depthMask(a)
    },
    _setDepthBias: function(a, b) {},
    setCamera: function(a) {
        this.mCurrentCamera = a, this.mViewMatrixDirty = !0, this.mProjMatrixDirty = !0, this.mWorldViewMatrixDirty = !0, this.mViewProjMatrixDirty = !0, this.mWorldViewProjMatrixDirty = !0, this.mInverseViewMatrixDirty = !0, this.mInverseWorldViewMatrixDirty = !0, this.mInverseTransposeWorldViewMatrixDirty = !0
    },
    getCamera: function(a) {
        return this.mCurrentCamera
    },
    findLinkProgram: function(a, b, c) {
        for (var d = 0; d < this.mLinkProgramMap.length;)
            if (this.mLinkProgramMap[d].mVertexProgram.name == a && this.mLinkProgramMap[d].mFragmentProgram.name == b && (null == c ? !0 : c == this.mLinkProgramMap[d].mGroupId)) return this.mLinkProgramMap[d];
        return null
    },
    releaseLinkProgramByGroupId: function(a) {
        for (var b = 0; b < this.mLinkProgramMap.length;) this.mLinkProgramMap[b].mGroupId == a ? this.mLinkProgramMap.splice(b, 1) : b++
    },
    _render: function(a) {
        if (!(a.vertexData.vertexCount <= 0)) {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, a.vertexData.vertexBufferBinding.getBuffer(0).mBufferId);
            for (var b in a.vertexData.vertexDeclaration.mElementList) {
                var c = a.vertexData.vertexDeclaration.mElementList[b],
                    d = a.vertexData.vertexBufferBinding.getBuffer(c.getSource()),
                    e = c.getOffset(),
                    f = c.getSemantic(),
                    g = this.mActiveLinkProgram.getAttributeIndex(f, c.getIndex()),
                    h = VertexElement.getTypeCount(c.getType()),
                    i = this.getGLType(c.getType()),
                    j = !1,
                    k = d.getVertexSize();
                switch (f) {
                    case VES_DIFFUSE:
                        h = 4, i = this.gl.FLOAT
                } - 1 != g && (this.gl.enableVertexAttribArray(g), this.gl.vertexAttribPointer(g, h, i, j, k, e))
            }
            var l;
            switch (a.operationType) {
                default:
                    case RenderOperation.OT_TRIANGLE_LIST:
                    l = this.gl.TRIANGLES
            }
            a.useIndexes ? (this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, a.indexData.indexBuffer.mBufferId), this.gl.drawElements(l, a.indexData.indexCount, this.gl.UNSIGNED_SHORT, 0)) : this.gl.drawArrays(l, 0, a.vertexData.vertexCount)
        }
    },
    getGLType: function(a) {
        var b = this.mRoot.getRenderFunction().gl;
        switch (a) {
            case VET_FLOAT1:
            case VET_FLOAT2:
            case VET_FLOAT3:
            case VET_FLOAT4:
                return b.FLOAT;
            case VET_SHORT1:
            case VET_SHORT2:
            case VET_SHORT3:
            case VET_SHORT4:
                return b.SHORT;
            case VET_COLOUR:
            case VET_COLOUR_ABGR:
            case VET_COLOUR_ARGB:
            case VET_UBYTE4:
                return b.UNSIGNED_BYTE;
            default:
                return 0
        }
    },
    setWorldMatrices: function(a) {
        this.mWorldMatrix = a, this.mWorldMatrixDirty = !0, this.mWorldViewMatrixDirty = !0, this.mWorldViewProjMatrixDirty = !0, this.mInverseWorldMatrixDirty = !0, this.mInverseWorldViewMatrixDirty = !0, this.mInverseTransposeWorldMatrixDirty = !0, this.mInverseTransposeWorldViewMatrixDirty = !0
    },
    getWorldMatrix: function() {
        return this.mWorldMatrixDirty && (this.mWorldMatrixDirty = !1), this.mWorldMatrix
    },
    getViewMatrix: function() {
        return this.mViewMatrixDirty && (this.mViewMatrix = this.mCurrentCamera.getViewMatrix(!0), this.mViewMatrixDirty = !1), this.mViewMatrix
    },
    getViewProjectionMatrix: function() {
        return this.mViewProjMatrixDirty && (this.mViewProjMatrix = this.getProjectionMatrix().multiply(this.getViewMatrix()), this.mViewProjMatrixDirty = !1), this.mViewProjMatrix
    },
    getProjectionMatrix: function() {
        return this.mProjMatrixDirty && (this.mProjectionMatrix = this.mCurrentCamera.getProjectionMatrix(), this.mProjMatrixDirty = !1), this.mProjectionMatrix
    },
    getWorldViewMatrix: function() {
        return this.mWorldViewMatrixDirty && (this.mWorldViewMatrix = this.getViewMatrix().multiply(this.getWorldMatrix()), this.mWorldViewMatrixDirty = !1), this.mWorldViewMatrix
    },
    getWorldViewProjMatrix: function() {
        return this.mWorldViewProjMatrixDirty && (this.mWorldViewProjMatrix = this.getProjectionMatrix().multiply(this.getWorldViewMatrix()), this.mWorldViewProjMatrixDirty = !1), this.mWorldViewProjMatrix
    },
    getInverseWorldMatrix: function() {
        return this.mInverseWorldMatrixDirty && (this.mInverseWorldMatrix = this.getWorldMatrix().inverseAffine(), this.mInverseWorldMatrixDirty = !1), this.mInverseWorldMatrix
    },
    getInverseWorldViewMatrix: function() {
        return this.mInverseWorldViewMatrixDirty && (this.mInverseWorldViewMatrix = this.getWorldViewMatrix().inverseAffine(), this.mInverseWorldViewMatrixDirty = !1), this.mInverseWorldViewMatrix
    },
    getInverseViewMatrix: function() {
        return this.mInverseViewMatrixDirty && (this.mInverseViewMatrix = this.getViewMatrix().inverseAffine(), this.mInverseViewMatrixDirty = !1), this.mInverseViewMatrix
    },
    getInverseTransposeViewMatrix: function() {
        return this.getInverseViewMatrix().transpose()
    },
    getInverseTransposeWorldMatrix: function() {
        return this.mInverseTransposeWorldMatrixDirty && (this.mInverseTransposeWorldMatrix = this.getInverseWorldMatrix().transpose(), this.mInverseTransposeWorldMatrixDirty = !1), this.mInverseTransposeWorldMatrix
    },
    getInverseTransposeWorldViewMatrix: function() {
        return this.mInverseTransposeWorldViewMatrixDirty && (this.mInverseTransposeWorldViewMatrix = this.getInverseWorldViewMatrix().transpose(), this.mInverseTransposeWorldViewMatrixDirty = !1), this.mInverseTransposeWorldViewMatrix
    },
    setCurrentLightList: function(a) {
        this.mCurrentLightList = a;
        for (var b = 0; b < a.length && b < e3d.E3D_MAX_SIMULTANEOUS_LIGHTS; ++b) this.mSpotlightViewProjMatrixDirty[b] = !0, this.mSpotlightWorldViewProjMatrixDirty[b] = !0
    },
    getLight: function(a) {
        return 0 > a || a >= this.mCurrentLightList.length ? this.mBlankLight : this.mCurrentLightList[a]
    },
    getLightCount: function() {
        return this.mCurrentLightList.length
    },
    getLightDiffuseColourWithPower: function(a) {
        var b = this.getLight(a);
        power = b.getPowerScale();
        var c = b.getDiffuseColour();
        return c[0] *= power, c[1] *= power, c[2] *= power, c
    },
    getLightSpecularColourWithPower: function(a) {
        var b = this.getLight(a);
        power = b.getPowerScale();
        var c = b.getSpecularColour();
        return c[0] *= power, c[1] *= power, c[2] *= power, c
    },
    getLightAttenuation: function(a) {
        var b = this.getLight(a);
        return [b.getAttenuationRange(), b.getAttenuationConstant(), b.getAttenuationLinear(), b.getAttenuationQuadric()]
    },
    getSpotlightParams: function(a) {
        var b = this.getLight(a);
        return b.getType() == Light.LT_SPOTLIGHT ? [Math.cos(.5 * b.getSpotlightInnerAngle()), Math.cos(.5 * b.getSpotlightOuterAngle()), b.getSpotlightFalloff(), 1] : [1, 0, 0, 1]
    },
    getLightAs4DVector: function(a) {
        return this.getLight(a).getAs4DVector(!0)
    },
    getLightDirection: function(a) {
        return this.getLight(a).getDerivedDirection()
    },
    setAmbientLightColour: function(a) {
        a instanceof Array ? this.mAmbientLight = a : this.mAmbientLight = [a.r, a.g, a.b, a.a]
    },
    getAmbientLightColour: function() {
        return this.mAmbientLight
    },
    getDerivedAmbientLightColour: function() {
        var a = this.getAmbientLightColour(),
            b = this.getSurfaceAmbientColour();
        return [a[0] * b[0], a[1] * b[1], a[2] * b[2], a[3] * b[3]]
    },
    getSurfaceAmbientColour: function() {
        return this.mCurrentPass.getAmbient()
    },
    getSurfaceDiffuseColour: function() {
        return this.mCurrentPass.getDiffuse()
    },
    getSurfaceSpecularColour: function() {
        return this.mCurrentPass.getSpecular()
    },
    getSurfaceEmissiveColour: function() {
        return this.mCurrentPass.getEmissive()
    },
    getSurfaceShininess: function() {
        return this.mCurrentPass.getShininess()
    },
    getReflectionStrength: function() {
        return this.mCurrentPass.getReflectEnvStrength()
    }
};
var FrameStats = function() {
        this.lastFPS, this.avgFPS, this.bestFPS, this.worstFPS, this.bestFrameTime, this.worstFrameTime, this.triangleCount, this.batchCount
    },
    RTType = {
        RENDER_WINDOW: 0,
        RENDER_TEXTURE: 1
    },
    RenderTarget = function(a, b, c, d) {
        this.mRoot = a, this.viewPorts = null, this.mViewport = null, this.mName = d || "", this.mType = RTType.RENDER_WINDOW, this.mFboBuffer = null, this.mWidth = void 0 == b ? 1 : b, this.mHeight = void 0 == c ? 1 : c, this.mColourDepth, this.mDepthBuffer = 0, this.mStats = new FrameStats, this.mTimer, this.mLastSecond, this.mLastTime, this.mFrameCount, this.mActive = !0, this.mAutoUpdate, this.mHwGamma = !1, this.mFSAA = 0, this.mFSAAHint, this.mListeners = [], this.resetStatistics()
    };
RenderTarget.prototype = {
    constructor: RenderTarget,
    updateStats: function() {},
    getName: function() {
        return this.mName
    },
    setName: function(a) {
        this.mName = a
    },
    getMatrics: function(a, b, c) {
        a = this.mWidth, b = this.mHeight, c = this.mColourDepth
    },
    getWidth: function() {
        return this.mWidth
    },
    getHeight: function() {
        return this.mHeight
    },
    getColourDepth: function() {
        return this.mColourDepth
    },
    setDepthBufferPool: function(a) {
        this.mDepthBufferPoolId != a && (this.mDepthBufferPoolId = a, this.detachDepthBuffer())
    },
    getDepthBufferPool: function() {
        return this.mDepthBufferPoolId
    },
    getDepthBuffer: function() {
        return this.mDepthBuffer
    },
    attachDepthBuffer: function(a) {
        var b = !1;
        return (b = a.isCompatible(this)) && (this.detachDepthBuffer(), this.mDepthBuffer = a), b
    },
    detachDepthBuffer: function() {
        this.mDepthBuffer && (this.mDepthBuffer._notifyRenderTargetAttached(this), this.mDepthBuffer = 0)
    },
    _detachDepthBuffer: function() {
        this.mDepthBuffer = 0
    },
    resize: function(a, b) {
        this.mWidth = a, this.mHeight = b, this.mViewport._updateDimensions()
    },
    update: function() {},
    swapBuffers: function() {},
    addViewport: function() {},
    getNumViewports: function() {},
    getViewport: function() {
        return this.mViewport
    },
    getViewportByZOrder: function() {},
    hasViewportWithZOrder: function() {},
    removeViewport: function() {},
    removeAllViewports: function() {},
    getStatistics: function() {
        return this.mStats
    },
    getLastFPS: function() {
        return this.mStats.lastFPS
    },
    getAverageFPS: function() {
        return this.mStats.avgFPS
    },
    getBestFPS: function() {
        return this.mStats.bestFPS
    },
    getWorstFPS: function() {
        return this.mStats.worstFPS
    },
    getBestFrameTime: function() {
        return this.mStats.triangleCount
    },
    getWorstFrameTime: function() {
        return this.mStats.bestFrameTime
    },
    resetStatistics: function() {
        return this.mStats.worstFrameTime
    },
    getCustomAttribute: function() {},
    setPriority: function() {},
    getPriority: function() {},
    isActive: function() {
        return this.mActive
    },
    setActive: function(a) {
        this.mActive = a
    },
    setAutoUpdated: function() {},
    isAutoUpdated: function() {},
    copyContentsToMemory: function() {},
    suggestPixelFormat: function() {},
    writeContentsToFile: function() {},
    writeContentsToTimestampedFile: function() {},
    getTriangleCount: function() {},
    getBatchCount: function() {},
    _notifyCameraRemoved: function() {},
    isPrimary: function() {},
    isHardwareGammaEnabled: function() {},
    getFSAA: function() {},
    getFSAAHint: function() {},
    _beginUpdate: function() {},
    _updateViewport: function() {},
    _updateAutoUpdatedViewports: function() {},
    _endUpdate: function() {},
    bind: function() {
        this.fireBind();
        var a = this.mRoot.getRenderFunction().gl;
        a.bindFramebuffer(a.FRAMEBUFFER, this.mFboBuffer)
    },
    unbind: function() {
        this.fireUnbind();
        var a = this.mRoot.getRenderFunction().gl;
        a.bindFramebuffer(a.FRAMEBUFFER, null)
    },
    addListener: function(a) {
        this.mListeners.push(a)
    },
    fireBind: function() {
        for (var a in this.mListeners) this.mListeners[a].onRenderTargetBind()
    },
    fireUnbind: function() {
        for (var a in this.mListeners) this.mListeners[a].onRenderTargetUnbind()
    },
    firePreUpdate: function() {},
    firePostUpdate: function() {},
    fireViewportPostUpdate: function() {},
    fireViewportPreUpdate: function() {},
    fireViewportAdded: function() {},
    fireViewportRemoved: function() {},
    updateImpl: function() {}
};
var SF_NONE = 0,
    SF_FPS = 1,
    SF_AVG_FPS = 2,
    SF_BEST_FPS = 4,
    SF_WORST_FPS = 8,
    SF_TRIANGLE_COUNT = 16,
    SF_ALL = 65535,
    FB_FRONT = 0,
    FB_BACK = 1,
    FB_AUTO = 2,
    Viewport = function(a, b, c, d, e) {
        this.name = "main_viewport", this.mBackColor = [0, 0, 0, 0], this.mClearEveryFrame = !0, this.mCamera = null, this.mTarget = a, this.mRelLeft = b, this.mRelTop = c, this.mRelWidth = d, this.mRelHeight = e, this.mActLeft = -1, this.mActTop = -1, this.mActWidth = -1, this.mActHeight = -1
    };
Viewport.prototype = {
    constructor: Viewport,
    _updateDimensions: function() {
        var a = this.mTarget.getHeight(),
            b = this.mTarget.getWidth();
        this.mActLeft = this.mRelLeft * b, this.mActTop = this.mRelTop * a, this.mActWidth = this.mRelWidth * b, this.mActHeight = this.mRelHeight * a, this.mCamera && this.mCamera.reSize(b, a)
    },
    getCamera: function() {
        return this.mCamera
    },
    setCamera: function(a) {
        a && (this.mCamera = a)
    },
    getActualLeft: function() {
        return this.mActLeft
    },
    getActualTop: function() {
        return this.mActTop
    },
    getActualWidth: function() {
        return this.mActWidth
    },
    getActualHeight: function() {
        return this.mActHeight
    },
    getClearEveryFrame: function() {
        return this.mClearEveryFrame
    },
    pointOrientedToScreen: function() {}
};
var Program = function(a, b) {
    Resource.call(this), this.mRoot = a, this.type = b || VERTEX_SHADER, this.name = "", this.source = null, this.default_params = [], this.mGLHandle = null, this.mCompiled = !1
};
extend(Program, Resource), Program.prototype = {
    constructor: Program,
    load: function(a, b) {
        var c = this;
        this.mRoot.mArchive.textLoad(a, function(a, b) {
            c._loadImpl(a)
        }, b.mPrefix, b)
    },
    _loadImpl: function(a) {
        this.source = a
    },
    compile: function() {
        if (this.mCompiled) return !0;
        var a = this.mRoot.getRenderFunction().gl,
            b = 0;
        if (this.type == VERTEX_SHADER ? b = a.VERTEX_SHADER : this.type == FRAGMENT_SHADER && (b = a.FRAGMENT_SHADER), this.mGLHandle = a.createShader(b), a.shaderSource(this.mGLHandle, this.source), a.compileShader(this.mGLHandle), !a.getShaderParameter(this.mGLHandle, a.COMPILE_STATUS)) {
            var c = a.getShaderInfoLog(this.mGLHandle);
            return console.log("compile error : ", this.name), console.log(c), !1
        }
        return this.mCompiled = !0, !0
    },
    attachToProgramObject: function(a) {
        var b = this.mRoot.getRenderFunction().gl;
        b.attachShader(a, this.mGLHandle)
    },
    bindProgram: function() {},
    unbindProgram: function() {},
    isLoaded: function() {
        return null == this.source ? !1 : !0
    }
};
var Default_param = function() {
    this.pn_type = "", this.name = "", this.value = "", this.type = "", this.extra_info = ""
};
Default_param.prototype = {
    constructor: Default_param
};
var VERTEX_SHADER = 35633,
    FRAGMENT_SHADER = 35632,
    LinkProgram = function(a, b, c) {
        if (Resource.call(this), this.mRoot = a, b.mGroupId != c.mGroupId) throw new Error("vertexProgram and fragmentProgram must belong to the same group");
        this.mGroupId = b.mGroupId, this.mVertexProgram = b, this.mFragmentProgram = c, this.mLinked = !1, this.mGLHandle = null, this.mValidAttributes = {}, this.mCustomAttributes = [
            ["inPosition", VES_POSITION, -1],
            ["inNormal", VES_NORMAL, -1],
            ["inColor", VES_DIFFUSE, -1],
            ["inTexCoord", VES_TEXTURE_COORDINATES, -1],
            ["inTangent", VES_TANGENT, -1],
            ["inBinormal", VES_BINORMAL, -1],
            ["inBoneIndex", VES_BLEND_INDICES, -1],
            ["inBoneWeight", VES_BLEND_WEIGHTS, -1]
        ], this.GLAutoUniformReferenceList = [], this.GLUniformReferenceList = []
    };
extend(LinkProgram, Resource), LinkProgram.prototype = {
    constructor: LinkProgram,
    activate: function() {
        if (!this.mLinked) {
            var a = this.mRoot.getRenderFunction().gl;
            this.mGLHandle = a.createProgram(), this.compileAndLink(), this.extractAttributes(), this.buildGLUniformReferences()
        }
        this.useProgram()
    },
    compileAndLink: function() {
        this.mVertexProgram.compile(), this.mVertexProgram.attachToProgramObject(this.mGLHandle), this.mFragmentProgram.compile(), this.mFragmentProgram.attachToProgramObject(this.mGLHandle);
        var a = this.mRoot.getRenderFunction().gl;
        if (a.linkProgram(this.mGLHandle), !a.getProgramParameter(this.mGLHandle, a.LINK_STATUS)) {
            var b = a.getProgramInfoLog(this.mGLHandle);
            return void console.log(b)
        }
        this.mLinked = !0, a.isProgram(this.mGLHandle) && a.validateProgram(this.mGLHandle)
    },
    extractAttributes: function() {
        for (var a = this.mRoot.getRenderFunction().gl, b = this.mCustomAttributes.length, c = 0; b > c; c++) {
            var d = this.mCustomAttributes[c],
                e = -1;
            e = a.getAttribLocation(this.mGLHandle, d[0]), -1 != e && (this.mValidAttributes[d[1]] = e)
        }
    },
    buildGLUniformReferences: function() {
        for (var a = this.mRoot.getRenderFunction().gl, b = a.getProgramParameter(this.mGLHandle, a.ACTIVE_UNIFORMS), c = 0; b > c; c++) {
            var d = a.getActiveUniform(this.mGLHandle, c),
                e = a.getUniformLocation(this.mGLHandle, d.name),
                f = d.name;
            if ("[0]" === f.substring(f.length - 3, f.length)) {
                var g = f.substring(0, d.name.length - 3);
                f = g
            }
            var h = this.getDefaultParam(f);
            if (null != h)
                if ("param_named_auto" == h.pn_type) {
                    var i = this.getACTTypeInt(h.value);
                    "" !== h.extra_info ? this.GLAutoUniformReferenceList.push([e, i, f, parseInt(h.extra_info)]) : this.GLAutoUniformReferenceList.push([e, i, f])
                } else "param_named" == h.pn_type && this.GLUniformReferenceList.push([e, h.type, this.toArray(h.value), f])
        }
    },
    updateAutoUniforms: function() {
        for (var a = this.mRoot.getRenderFunction().gl, b = 0; b < this.GLAutoUniformReferenceList.length; b++) {
            var c = this.GLAutoUniformReferenceList[b],
                d = null;
            switch (4 == c.length && (d = c[3]), c[1]) {
                case ACT_WORLDVIEWPROJ_MATRIX:
                    a.uniformMatrix4fv(c[0], !1, this.mRoot.getRenderFunction().getWorldViewProjMatrix().transpose().m);
                    break;
                case ACT_WORLD_MATRIX:
                    a.uniformMatrix4fv(c[0], !1, this.mRoot.getRenderFunction().getWorldMatrix().transpose().m);
                    break;
                case ACT_VIEWPROJ_MATRIX:
                case ACT_WORLDVIEW_MATRIX:
                    a.uniformMatrix4fv(c[0], !1, this.mRoot.getRenderFunction().getWorldViewMatrix().transpose().m);
                    break;
                case ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX:
                    a.uniformMatrix4fv(c[0], !1, this.mRoot.getRenderFunction().getInverseTransposeWorldViewMatrix().transpose().m);
                    break;
                case ACT_INVERSE_WORLDVIEW_MATRIX:
                    a.uniformMatrix4fv(c[0], !1, this.mRoot.getRenderFunction().getInverseWorldViewMatrix().transpose().m);
                    break;
                case ACT_LIGHT_COUNT:
                    a.uniform1f(c[0], this.mRoot.getRenderFunction().getLightCount());
                    break;
                case ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY:
                    null == d && (d = 1);
                    for (var e = this.mRoot.getRenderFunction().getViewMatrix(), f = [], g = 0; d > g; ++g) {
                        var h = e.transformAffine(this.mRoot.getRenderFunction().getLightAs4DVector(g));
                        f = f.concat([h.x, h.y, h.z, h.w])
                    }
                    a.uniform4fv(c[0], f);
                    break;
                case ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY:
                    null == d && (d = 1);
                    for (var i = this.mRoot.getRenderFunction().getInverseTransposeViewMatrix().extract3x3Matrix(), f = [], g = 0; d > g; ++g) {
                        var j = i.multiply(this.mRoot.getRenderFunction().getLightDirection(g));
                        j.normalise(), f = f.concat([j.x, j.y, j.z, 0])
                    }
                    a.uniform4fv(c[0], f);
                    break;
                case ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY:
                    null == d && (d = 1);
                    for (var k = this.mRoot.getRenderFunction().getSurfaceDiffuseColour(), f = [], g = 0; d > g; ++g) {
                        var l = this.mRoot.getRenderFunction().getLightDiffuseColourWithPower(g),
                            m = [l[0] * k[0], l[1] * k[1], l[2] * k[2], l[3] * k[3]];
                        f = f.concat(m)
                    }
                    a.uniform4fv(c[0], f);
                    break;
                case ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY:
                    null == d && (d = 1);
                    for (var n = this.mRoot.getRenderFunction().getSurfaceSpecularColour(), f = [], g = 0; d > g; ++g) {
                        var o = this.mRoot.getRenderFunction().getLightSpecularColourWithPower(g),
                            p = [o[0] * n[0], o[1] * n[1], o[2] * n[2], o[3] * n[3]];
                        f = f.concat(p)
                    }
                    a.uniform4fv(c[0], f);
                    break;
                case ACT_LIGHT_ATTENUATION_ARRAY:
                    null == d && (d = 1);
                    for (var f = [], g = 0; d > g; ++g) {
                        var q = this.mRoot.getRenderFunction().getLightAttenuation(g);
                        f = f.concat(q)
                    }
                    a.uniform4fv(c[0], f);
                    break;
                case ACT_SPOTLIGHT_PARAMS_ARRAY:
                    null == d && (d = 1);
                    for (var f = [], g = 0; d > g; ++g) {
                        var q = this.mRoot.getRenderFunction().getSpotlightParams(g);
                        f = f.concat(q)
                    }
                    a.uniform4fv(c[0], f);
                    break;
                case ACT_AMBIENT_LIGHT_COLOUR:
                    a.uniform4fv(c[0], this.mRoot.getRenderFunction().getAmbientLightColour());
                    break;
                case ACT_DERIVED_AMBIENT_LIGHT_COLOUR:
                    a.uniform4fv(c[0], this.mRoot.getRenderFunction().getDerivedAmbientLightColour());
                    break;
                case ACT_SURFACE_SHININESS:
                    a.uniform1f(c[0], this.mRoot.getRenderFunction().getSurfaceShininess());
                    break;
                case ACT_REF_STRENGTH:
                    a.uniform1f(c[0], this.mRoot.getRenderFunction().getReflectionStrength());
                    break;
                case ACT_TEXTURE_MATRIX:
                    if (this.mRoot.getRenderFunction().mCurrentPass.getTextureUnitState(0)) {
                        var r = this.mRoot.getRenderFunction().mCurrentPass.getTextureUnitState(0).getTextureTransform();
                        a.uniformMatrix4fv(c[0], !1, r.transpose().m)
                    }
                    break;
                case ACT_INVERSE_VIEWPORT_WIDTH:
                    a.uniform1f(c[0], 1 / this.mRoot.getRenderFunction().mCurrentViewport.getActualWidth());
                    break;
                case ACT_INVERSE_VIEWPORT_HEIGHT:
                    a.uniform1f(c[0], 1 / this.mRoot.getRenderFunction().mCurrentViewport.getActualHeight());
                    break;
                case ACT_COLOR_MODIFIER:
                    a.uniform4fv(c[0], this.mRoot.getRenderFunction().mCurrentPass.getColorModifier());
                    break;
                case ACT_UV_REPEAT:
                    a.uniform2fv(c[0], this.mRoot.getRenderFunction().mCurrentPass.getUVRepeat())
            }
        }
    },
    toArray: function(a) {
        a = a.replace(/^\s+|\s+$/g, ""), a = a.replace(/[ ;]+/, " ");
        for (var b = a.split(" "), c = new Array, d = 0; d < b.length; d++) c.push(parseFloat(b[d]));
        return c
    },
    updateUniforms: function() {
        for (var a = 0; a < this.GLUniformReferenceList.length; a++) {
            var b = this.GLUniformReferenceList[a],
                c = b[1],
                d = this.mRoot.getRenderFunction().gl;
            if ("matrix4x4Array" == c && b[2]) {
                for (var e = b[2].length, f = [], g = 0; e > g; ++g) {
                    var h = b[2][g];
                    if (h) {
                        h = h.m;
                        for (var i = 0; 16 > i; i++) f.push(h[i])
                    }
                }
                e > 0 && f.length > 0 && d.uniformMatrix4fv(b[0], !1, f)
            } else if ("matrix3x3Array" == c && b[2]) {
                for (var e = b[2].length, f = [], g = 0; e > g; ++g) {
                    var h = b[2][g];
                    if (h) {
                        h = h.m;
                        for (var i = 0; 9 > i; i++) f.push(h[i])
                    }
                }
                e > 0 && f.length > 0 && d.uniformMatrix3fv(b[0], !1, f)
            } else "float4" == c ? d.uniform4f(b[0], b[2][0], b[2][1], b[2][2], b[2][3]) : "float3" == c ? d.uniform3f(b[0], b[2][0], b[2][1], b[2][2]) : "float2" == c ? d.uniform2f(b[0], b[2][0], b[2][1]) : "float" == c ? d.uniform1f(b[0], b[2][0]) : "int" == c && d.uniform1i(b[0], parseInt(b[2][0]))
        }
    },
    useProgram: function() {
        if (this.mLinked) {
            var a = this.mRoot.getRenderFunction().gl;
            a.useProgram(this.mGLHandle)
        }
    },
    getAttributeIndex: function(a, b) {
        var c = this.mValidAttributes[a];
        return void 0 == c ? -1 : c
    },
    getDefaultParam: function(a) {
        var b = this.getDefaultParamInVertexProgram(a);
        return b || (b = this.getDefaultParamInFragmentProgram(a)), b
    },
    getDefaultParamInVertexProgram: function(a) {
        for (var b = 0; b < this.mVertexProgram.default_params.length; b++) {
            var c = this.mVertexProgram.default_params[b];
            if (c.name == a) return c
        }
        return null
    },
    getDefaultParamInFragmentProgram: function(a) {
        for (var b = 0; b < this.mFragmentProgram.default_params.length; b++) {
            var c = this.mFragmentProgram.default_params[b];
            if (c.name == a) return c
        }
        return null
    },
    getACTType: function(a) {
        var b = this._getACTType(this.mVertexProgram, a);
        return b || (b = this._getACTType(this.mFragmentProgram, a)), b
    },
    _getACTType: function(a, b) {
        for (var c = 0; c < a.default_params.length; c++) {
            var d = a.default_params[c];
            if ("param_named_auto" == d.pn_type) {
                if (d.name == b) return this.getACTTypeInt(d.value)
            } else if ("param_named" == d.pn_type && d.name == b) return [d.type, this.toArray(d.value)]
        }
        return null
    },
    getACTTypeInt: function(a) {
        for (var b = 0; b < AutoConstantDictionary.length; b++) {
            var c = AutoConstantDictionary[b];
            if (c[1] == a) return c[0]
        }
        return -1
    }
};
var GCT_FLOAT1 = 1,
    GCT_FLOAT2 = 2,
    GCT_FLOAT3 = 3,
    GCT_FLOAT4 = 4,
    GCT_SAMPLER1D = 5,
    GCT_SAMPLER2D = 6,
    GCT_SAMPLER3D = 7,
    GCT_SAMPLERCUBE = 8,
    GCT_SAMPLER1DSHADOW = 9,
    GCT_SAMPLER2DSHADOW = 10,
    GCT_MATRIX_2X2 = 11,
    GCT_MATRIX_2X3 = 12,
    GCT_MATRIX_2X4 = 13,
    GCT_MATRIX_3X2 = 14,
    GCT_MATRIX_3X3 = 15,
    GCT_MATRIX_3X4 = 16,
    GCT_MATRIX_4X2 = 17,
    GCT_MATRIX_4X3 = 18,
    GCT_MATRIX_4X4 = 19,
    GCT_INT1 = 20,
    GCT_INT2 = 21,
    GCT_INT3 = 22,
    GCT_INT4 = 23,
    GCT_UNKNOWN = 99,
    ACT_INDEX_TMP = 1,
    ACT_WORLD_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_WORLD_MATRIX = ACT_INDEX_TMP++,
    ACT_TRANSPOSE_WORLD_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_TRANSPOSE_WORLD_MATRIX = ACT_INDEX_TMP++,
    ACT_WORLD_MATRIX_ARRAY_3x4 = ACT_INDEX_TMP++,
    ACT_WORLD_MATRIX_ARRAY = ACT_INDEX_TMP++,
    ACT_VIEW_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_VIEW_MATRIX = ACT_INDEX_TMP++,
    ACT_TRANSPOSE_VIEW_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_TRANSPOSE_VIEW_MATRIX = ACT_INDEX_TMP++,
    ACT_PROJECTION_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_PROJECTION_MATRIX = ACT_INDEX_TMP++,
    ACT_TRANSPOSE_PROJECTION_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX = ACT_INDEX_TMP++,
    ACT_VIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_VIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_TRANSPOSE_VIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_WORLDVIEW_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_WORLDVIEW_MATRIX = ACT_INDEX_TMP++,
    ACT_TRANSPOSE_WORLDVIEW_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX = ACT_INDEX_TMP++,
    ACT_WORLDVIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_WORLDVIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_RENDER_TARGET_FLIPPING = ACT_INDEX_TMP++,
    ACT_VERTEX_WINDING = ACT_INDEX_TMP++,
    ACT_FOG_COLOUR = ACT_INDEX_TMP++,
    ACT_FOG_PARAMS = ACT_INDEX_TMP++,
    ACT_SURFACE_AMBIENT_COLOUR = ACT_INDEX_TMP++,
    ACT_SURFACE_DIFFUSE_COLOUR = ACT_INDEX_TMP++,
    ACT_SURFACE_SPECULAR_COLOUR = ACT_INDEX_TMP++,
    ACT_SURFACE_EMISSIVE_COLOUR = ACT_INDEX_TMP++,
    ACT_SURFACE_SHININESS = ACT_INDEX_TMP++,
    ACT_REF_STRENGTH = ACT_INDEX_TMP++,
    ACT_LIGHT_COUNT = ACT_INDEX_TMP++,
    ACT_AMBIENT_LIGHT_COLOUR = ACT_INDEX_TMP++,
    ACT_LIGHT_DIFFUSE_COLOUR = ACT_INDEX_TMP++,
    ACT_LIGHT_SPECULAR_COLOUR = ACT_INDEX_TMP++,
    ACT_LIGHT_ATTENUATION = ACT_INDEX_TMP++,
    ACT_SPOTLIGHT_PARAMS = ACT_INDEX_TMP++,
    ACT_LIGHT_POSITION = ACT_INDEX_TMP++,
    ACT_LIGHT_POSITION_OBJECT_SPACE = ACT_INDEX_TMP++,
    ACT_LIGHT_POSITION_VIEW_SPACE = ACT_INDEX_TMP++,
    ACT_LIGHT_DIRECTION = ACT_INDEX_TMP++,
    ACT_LIGHT_DIRECTION_OBJECT_SPACE = ACT_INDEX_TMP++,
    ACT_LIGHT_DIRECTION_VIEW_SPACE = ACT_INDEX_TMP++,
    ACT_LIGHT_DISTANCE_OBJECT_SPACE = ACT_INDEX_TMP++,
    ACT_LIGHT_POWER_SCALE = ACT_INDEX_TMP++,
    ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED = ACT_INDEX_TMP++,
    ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED = ACT_INDEX_TMP++,
    ACT_LIGHT_DIFFUSE_COLOUR_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_SPECULAR_COLOUR_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_ATTENUATION_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_POSITION_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_DIRECTION_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_POWER_SCALE_ARRAY = ACT_INDEX_TMP++,
    ACT_SPOTLIGHT_PARAMS_ARRAY = ACT_INDEX_TMP++,
    ACT_DERIVED_AMBIENT_LIGHT_COLOUR = ACT_INDEX_TMP++,
    ACT_DERIVED_SCENE_COLOUR = ACT_INDEX_TMP++,
    ACT_DERIVED_LIGHT_DIFFUSE_COLOUR = ACT_INDEX_TMP++,
    ACT_DERIVED_LIGHT_SPECULAR_COLOUR = ACT_INDEX_TMP++,
    ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY = ACT_INDEX_TMP++,
    ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY = ACT_INDEX_TMP++,
    ACT_LIGHT_NUMBER = ACT_INDEX_TMP++,
    ACT_LIGHT_CASTS_SHADOWS = ACT_INDEX_TMP++,
    ACT_SHADOW_EXTRUSION_DISTANCE = ACT_INDEX_TMP++,
    ACT_CAMERA_POSITION = ACT_INDEX_TMP++,
    ACT_CAMERA_POSITION_OBJECT_SPACE = ACT_INDEX_TMP++,
    ACT_TEXTURE_VIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY = ACT_INDEX_TMP++,
    ACT_TEXTURE_WORLDVIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY = ACT_INDEX_TMP++,
    ACT_SPOTLIGHT_VIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_SPOTLIGHT_VIEWPROJ_MATRIX_ARRAY = ACT_INDEX_TMP++,
    ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX = ACT_INDEX_TMP++,
    ACT_CUSTOM = ACT_INDEX_TMP++,
    ACT_TIME = ACT_INDEX_TMP++,
    ACT_TIME_0_X = ACT_INDEX_TMP++,
    ACT_COSTIME_0_X = ACT_INDEX_TMP++,
    ACT_SINTIME_0_X = ACT_INDEX_TMP++,
    ACT_TANTIME_0_X = ACT_INDEX_TMP++,
    ACT_TIME_0_X_PACKED = ACT_INDEX_TMP++,
    ACT_TIME_0_1 = ACT_INDEX_TMP++,
    ACT_COSTIME_0_1 = ACT_INDEX_TMP++,
    ACT_SINTIME_0_1 = ACT_INDEX_TMP++,
    ACT_TANTIME_0_1 = ACT_INDEX_TMP++,
    ACT_TIME_0_1_PACKED = ACT_INDEX_TMP++,
    ACT_TIME_0_2PI = ACT_INDEX_TMP++,
    ACT_COSTIME_0_2PI = ACT_INDEX_TMP++,
    ACT_SINTIME_0_2PI = ACT_INDEX_TMP++,
    ACT_TANTIME_0_2PI = ACT_INDEX_TMP++,
    ACT_TIME_0_2PI_PACKED = ACT_INDEX_TMP++,
    ACT_FRAME_TIME = ACT_INDEX_TMP++,
    ACT_FPS = ACT_INDEX_TMP++,
    ACT_VIEWPORT_WIDTH = ACT_INDEX_TMP++,
    ACT_VIEWPORT_HEIGHT = ACT_INDEX_TMP++,
    ACT_INVERSE_VIEWPORT_WIDTH = ACT_INDEX_TMP++,
    ACT_INVERSE_VIEWPORT_HEIGHT = ACT_INDEX_TMP++,
    ACT_VIEWPORT_SIZE = ACT_INDEX_TMP++,
    ACT_VIEW_DIRECTION = ACT_INDEX_TMP++,
    ACT_VIEW_SIDE_VECTOR = ACT_INDEX_TMP++,
    ACT_VIEW_UP_VECTOR = ACT_INDEX_TMP++,
    ACT_FOV = ACT_INDEX_TMP++,
    ACT_NEAR_CLIP_DISTANCE = ACT_INDEX_TMP++,
    ACT_FAR_CLIP_DISTANCE = ACT_INDEX_TMP++,
    ACT_PASS_NUMBER = ACT_INDEX_TMP++,
    ACT_PASS_ITERATION_NUMBER = ACT_INDEX_TMP++,
    ACT_ANIMATION_PARAMETRIC = ACT_INDEX_TMP++,
    ACT_TEXEL_OFFSETS = ACT_INDEX_TMP++,
    ACT_SCENE_DEPTH_RANGE = ACT_INDEX_TMP++,
    ACT_SHADOW_SCENE_DEPTH_RANGE = ACT_INDEX_TMP++,
    ACT_SHADOW_COLOUR = ACT_INDEX_TMP++,
    ACT_TEXTURE_SIZE = ACT_INDEX_TMP++,
    ACT_INVERSE_TEXTURE_SIZE = ACT_INDEX_TMP++,
    ACT_PACKED_TEXTURE_SIZE = ACT_INDEX_TMP++,
    ACT_TEXTURE_MATRIX = ACT_INDEX_TMP++,
    ACT_LOD_CAMERA_POSITION = ACT_INDEX_TMP++,
    ACT_LOD_CAMERA_POSITION_OBJECT_SPACE = ACT_INDEX_TMP++,
    ACT_LIGHT_CUSTOM = ACT_INDEX_TMP++,
    ACT_COLOR_MODIFIER = ACT_INDEX_TMP++;
ACT_UV_REPEAT = ACT_INDEX_TMP++;
var ACDT_NONE = 1,
    ACDT_INT = 2,
    ACDT_REAL = 3,
    ET_INT = 1,
    ET_REAL = 2,
    AutoConstantDictionary = [
        [ACT_WORLD_MATRIX, "world_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_WORLD_MATRIX, "inverse_world_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_TRANSPOSE_WORLD_MATRIX, "transpose_world_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_TRANSPOSE_WORLD_MATRIX, "inverse_transpose_world_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_WORLD_MATRIX_ARRAY_3x4, "world_matrix_array_3x4", 12, ET_REAL, ACDT_NONE],
        [ACT_WORLD_MATRIX_ARRAY, "world_matrix_array", 16, ET_REAL, ACDT_NONE],
        [ACT_VIEW_MATRIX, "view_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_VIEW_MATRIX, "inverse_view_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_TRANSPOSE_VIEW_MATRIX, "transpose_view_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_TRANSPOSE_VIEW_MATRIX, "inverse_transpose_view_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_PROJECTION_MATRIX, "projection_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_PROJECTION_MATRIX, "inverse_projection_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_TRANSPOSE_PROJECTION_MATRIX, "transpose_projection_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX, "inverse_transpose_projection_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_VIEWPROJ_MATRIX, "viewproj_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_VIEWPROJ_MATRIX, "inverse_viewproj_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_TRANSPOSE_VIEWPROJ_MATRIX, "transpose_viewproj_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX, "inverse_transpose_viewproj_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_WORLDVIEW_MATRIX, "worldview_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_WORLDVIEW_MATRIX, "inverse_worldview_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_TRANSPOSE_WORLDVIEW_MATRIX, "transpose_worldview_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX, "inverse_transpose_worldview_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_WORLDVIEWPROJ_MATRIX, "worldviewproj_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_WORLDVIEWPROJ_MATRIX, "inverse_worldviewproj_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX, "transpose_worldviewproj_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX, "inverse_transpose_worldviewproj_matrix", 16, ET_REAL, ACDT_NONE],
        [ACT_RENDER_TARGET_FLIPPING, "render_target_flipping", 1, ET_REAL, ACDT_NONE],
        [ACT_VERTEX_WINDING, "vertex_winding", 1, ET_REAL, ACDT_NONE],
        [ACT_FOG_COLOUR, "fog_colour", 4, ET_REAL, ACDT_NONE],
        [ACT_FOG_PARAMS, "fog_params", 4, ET_REAL, ACDT_NONE],
        [ACT_SURFACE_AMBIENT_COLOUR, "surface_ambient_colour", 4, ET_REAL, ACDT_NONE],
        [ACT_SURFACE_DIFFUSE_COLOUR, "surface_diffuse_colour", 4, ET_REAL, ACDT_NONE],
        [ACT_SURFACE_SPECULAR_COLOUR, "surface_specular_colour", 4, ET_REAL, ACDT_NONE],
        [ACT_SURFACE_EMISSIVE_COLOUR, "surface_emissive_colour", 4, ET_REAL, ACDT_NONE],
        [ACT_SURFACE_SHININESS, "surface_shininess", 1, ET_REAL, ACDT_NONE],
        [ACT_REF_STRENGTH, "ref_strength", 1, ET_REAL, ACDT_NONE],
        [ACT_LIGHT_COUNT, "light_count", 1, ET_REAL, ACDT_NONE],
        [ACT_AMBIENT_LIGHT_COLOUR, "ambient_light_colour", 4, ET_REAL, ACDT_NONE],
        [ACT_LIGHT_DIFFUSE_COLOUR, "light_diffuse_colour", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_SPECULAR_COLOUR, "light_specular_colour", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_ATTENUATION, "light_attenuation", 4, ET_REAL, ACDT_INT],
        [ACT_SPOTLIGHT_PARAMS, "spotlight_params", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_POSITION, "light_position", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_POSITION_OBJECT_SPACE, "light_position_object_space", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_POSITION_VIEW_SPACE, "light_position_view_space", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DIRECTION, "light_direction", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DIRECTION_OBJECT_SPACE, "light_direction_object_space", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DIRECTION_VIEW_SPACE, "light_direction_view_space", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DISTANCE_OBJECT_SPACE, "light_distance_object_space", 1, ET_REAL, ACDT_INT],
        [ACT_LIGHT_POWER_SCALE, "light_power", 1, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED, "light_diffuse_colour_power_scaled", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED, "light_specular_colour_power_scaled", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DIFFUSE_COLOUR_ARRAY, "light_diffuse_colour_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_SPECULAR_COLOUR_ARRAY, "light_specular_colour_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY, "light_diffuse_colour_power_scaled_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY, "light_specular_colour_power_scaled_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_ATTENUATION_ARRAY, "light_attenuation_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_POSITION_ARRAY, "light_position_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY, "light_position_object_space_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY, "light_position_view_space_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DIRECTION_ARRAY, "light_direction_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY, "light_direction_object_space_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY, "light_direction_view_space_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY, "light_distance_object_space_array", 1, ET_REAL, ACDT_INT],
        [ACT_LIGHT_POWER_SCALE_ARRAY, "light_power_array", 1, ET_REAL, ACDT_INT],
        [ACT_SPOTLIGHT_PARAMS_ARRAY, "spotlight_params_array", 4, ET_REAL, ACDT_INT],
        [ACT_DERIVED_AMBIENT_LIGHT_COLOUR, "derived_ambient_light_colour", 4, ET_REAL, ACDT_NONE],
        [ACT_DERIVED_SCENE_COLOUR, "derived_scene_colour", 4, ET_REAL, ACDT_NONE],
        [ACT_DERIVED_LIGHT_DIFFUSE_COLOUR, "derived_light_diffuse_colour", 4, ET_REAL, ACDT_INT],
        [ACT_DERIVED_LIGHT_SPECULAR_COLOUR, "derived_light_specular_colour", 4, ET_REAL, ACDT_INT],
        [ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY, "derived_light_diffuse_colour_array", 4, ET_REAL, ACDT_INT],
        [ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY, "derived_light_specular_colour_array", 4, ET_REAL, ACDT_INT],
        [ACT_LIGHT_NUMBER, "light_number", 1, ET_REAL, ACDT_INT],
        [ACT_LIGHT_CASTS_SHADOWS, "light_casts_shadows", 1, ET_REAL, ACDT_INT],
        [ACT_SHADOW_EXTRUSION_DISTANCE, "shadow_extrusion_distance", 1, ET_REAL, ACDT_INT],
        [ACT_CAMERA_POSITION, "camera_position", 3, ET_REAL, ACDT_NONE],
        [ACT_CAMERA_POSITION_OBJECT_SPACE, "camera_position_object_space", 3, ET_REAL, ACDT_NONE],
        [ACT_TEXTURE_VIEWPROJ_MATRIX, "texture_viewproj_matrix", 16, ET_REAL, ACDT_INT],
        [ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY, "texture_viewproj_matrix_array", 16, ET_REAL, ACDT_INT],
        [ACT_TEXTURE_WORLDVIEWPROJ_MATRIX, "texture_worldviewproj_matrix", 16, ET_REAL, ACDT_INT],
        [ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY, "texture_worldviewproj_matrix_array", 16, ET_REAL, ACDT_INT],
        [ACT_SPOTLIGHT_VIEWPROJ_MATRIX, "spotlight_viewproj_matrix", 16, ET_REAL, ACDT_INT],
        [ACT_SPOTLIGHT_VIEWPROJ_MATRIX_ARRAY, "spotlight_viewproj_matrix_array", 16, ET_REAL, ACDT_INT],
        [ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX, "spotlight_worldviewproj_matrix", 16, ET_REAL, ACDT_INT],
        [ACT_CUSTOM, "custom", 4, ET_REAL, ACDT_INT],
        [ACT_TIME, "time", 1, ET_REAL, ACDT_REAL],
        [ACT_TIME_0_X, "time_0_x", 4, ET_REAL, ACDT_REAL],
        [ACT_COSTIME_0_X, "costime_0_x", 4, ET_REAL, ACDT_REAL],
        [ACT_SINTIME_0_X, "sintime_0_x", 4, ET_REAL, ACDT_REAL],
        [ACT_TANTIME_0_X, "tantime_0_x", 4, ET_REAL, ACDT_REAL],
        [ACT_TIME_0_X_PACKED, "time_0_x_packed", 4, ET_REAL, ACDT_REAL],
        [ACT_TIME_0_1, "time_0_1", 4, ET_REAL, ACDT_REAL],
        [ACT_COSTIME_0_1, "costime_0_1", 4, ET_REAL, ACDT_REAL],
        [ACT_SINTIME_0_1, "sintime_0_1", 4, ET_REAL, ACDT_REAL],
        [ACT_TANTIME_0_1, "tantime_0_1", 4, ET_REAL, ACDT_REAL],
        [ACT_TIME_0_1_PACKED, "time_0_1_packed", 4, ET_REAL, ACDT_REAL],
        [ACT_TIME_0_2PI, "time_0_2pi", 4, ET_REAL, ACDT_REAL],
        [ACT_COSTIME_0_2PI, "costime_0_2pi", 4, ET_REAL, ACDT_REAL],
        [ACT_SINTIME_0_2PI, "sintime_0_2pi", 4, ET_REAL, ACDT_REAL],
        [ACT_TANTIME_0_2PI, "tantime_0_2pi", 4, ET_REAL, ACDT_REAL],
        [ACT_TIME_0_2PI_PACKED, "time_0_2pi_packed", 4, ET_REAL, ACDT_REAL],
        [ACT_FRAME_TIME, "frame_time", 1, ET_REAL, ACDT_REAL],
        [ACT_FPS, "fps", 1, ET_REAL, ACDT_NONE],
        [ACT_VIEWPORT_WIDTH, "viewport_width", 1, ET_REAL, ACDT_NONE],
        [ACT_VIEWPORT_HEIGHT, "viewport_height", 1, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_VIEWPORT_WIDTH, "inverse_viewport_width", 1, ET_REAL, ACDT_NONE],
        [ACT_INVERSE_VIEWPORT_HEIGHT, "inverse_viewport_height", 1, ET_REAL, ACDT_NONE],
        [ACT_VIEWPORT_SIZE, "viewport_size", 4, ET_REAL, ACDT_NONE],
        [ACT_VIEW_DIRECTION, "view_direction", 3, ET_REAL, ACDT_NONE],
        [ACT_VIEW_SIDE_VECTOR, "view_side_vector", 3, ET_REAL, ACDT_NONE],
        [ACT_VIEW_UP_VECTOR, "view_up_vector", 3, ET_REAL, ACDT_NONE],
        [ACT_FOV, "fov", 1, ET_REAL, ACDT_NONE],
        [ACT_NEAR_CLIP_DISTANCE, "near_clip_distance", 1, ET_REAL, ACDT_NONE],
        [ACT_FAR_CLIP_DISTANCE, "far_clip_distance", 1, ET_REAL, ACDT_NONE],
        [ACT_PASS_NUMBER, "pass_number", 1, ET_REAL, ACDT_NONE],
        [ACT_PASS_ITERATION_NUMBER, "pass_iteration_number", 1, ET_REAL, ACDT_NONE],
        [ACT_ANIMATION_PARAMETRIC, "animation_parametric", 4, ET_REAL, ACDT_INT],
        [ACT_TEXEL_OFFSETS, "texel_offsets", 4, ET_REAL, ACDT_NONE],
        [ACT_SCENE_DEPTH_RANGE, "scene_depth_range", 4, ET_REAL, ACDT_NONE],
        [ACT_SHADOW_SCENE_DEPTH_RANGE, "shadow_scene_depth_range", 4, ET_REAL, ACDT_INT],
        [ACT_SHADOW_COLOUR, "shadow_colour", 4, ET_REAL, ACDT_NONE],
        [ACT_TEXTURE_SIZE, "texture_size", 4, ET_REAL, ACDT_INT],
        [ACT_INVERSE_TEXTURE_SIZE, "inverse_texture_size", 4, ET_REAL, ACDT_INT],
        [ACT_PACKED_TEXTURE_SIZE, "packed_texture_size", 4, ET_REAL, ACDT_INT],
        [ACT_TEXTURE_MATRIX, "texture_matrix", 16, ET_REAL, ACDT_INT],
        [ACT_LOD_CAMERA_POSITION, "lod_camera_position", 3, ET_REAL, ACDT_NONE],
        [ACT_LOD_CAMERA_POSITION_OBJECT_SPACE, "lod_camera_position_object_space", 3, ET_REAL, ACDT_NONE],
        [ACT_LIGHT_CUSTOM, "light_custom", 4, ET_REAL, ACDT_INT],
        [ACT_COLOR_MODIFIER, "color_modifier", 4, ET_REAL, ACDT_NONE],
        [ACT_UV_REPEAT, "uv_repeat", 2, ET_REAL, ACDT_NONE]
    ],
    Material = function(a) {
        this.mRoot = a, Resource.call(this), this.name = "", this.pass = new Pass(a, this), this.mRequireSkinNormal = !1, this.doubleRender = !1, this.mForbidden = !1
    };
extend(Material, Resource), Material.prototype = {
    constructor: Material,
    load: function(a, b) {
        this.pass.load(a, b)
    },
    isSkinNormalCal: function() {
        return this.mRequireSkinNormal
    },
    getPass: function() {
        return this.pass
    },
    updateDoubleRender: function(a) {
        this.doubleRender && (1 == a ? this.pass.getFragmentProgramParameters().setNamedConstant("doubleRender", 1) : 2 == a && this.pass.getFragmentProgramParameters().setNamedConstant("doubleRender", 0))
    }
};
var Frustum = function(a, b, c, d, e, f) {
    this.left = a, this.right = b, this.bottom = c, this.top = d, this.near = e, this.far = f, this.fov = 45, this.aspect = 1, this.mGameObject = null, this.mLastParentOrientation = new Quaternion, this.mLastParentPosition = new Vector3, this.mRecalcView = !0, this.mRecalcFrustum = !0, this.projMatrix = new Matrix4, this.viewMatrix = new Matrix4
};
Frustum.prototype = {
    constructor: Frustum,
    updateView: function() {
        this.isViewOutOfDate() && this.updateViewImpl()
    },
    getViewMatrix: function() {
        return this.updateView(), this.viewMatrix
    },
    getProjectionMatrix: function() {
        return this.updateFrustum(), this.projMatrix
    },
    updateViewImpl: function() {
        var a = this.getOrientationForViewUpdate(),
            b = this.getPositionForViewUpdate();
        this.viewMatrix = Math.makeViewMatrix(b, a), this.mRecalcView = !1
    },
    isViewOutOfDate: function() {
        return null !== this.mGameObject && (this.mRecalcView || this.mGameObject.getTransform()._getDerivedOrientation().notEquals(this.mLastParentOrientation) || this.mGameObject.getTransform()._getDerivedPosition().notEquals(this.mLastParentPosition)) && (this.mLastParentOrientation.copy(this.mGameObject.getTransform()._getDerivedOrientation()), this.mLastParentPosition.copy(this.mGameObject.getTransform()._getDerivedPosition()), this.mRecalcView = !0), this.mRecalcView
    },
    updateFrustum: function() {
        this.isFrustumOutOfDate() && this.updateFrustumImpl()
    },
    isFrustumOutOfDate: function() {
        return this.mRecalcFrustum
    },
    updateFrustumImpl: function() {
        var a, b, c, d, e = .5 * Math.radians(this.fov),
            f = Math.tan(e),
            g = f * this.aspect,
            h = 1,
            i = new Vector2(0, 0),
            j = this.near / h,
            k = i.x * j,
            l = i.y * j,
            m = g * this.near,
            n = f * this.near;
        a = -m + k, b = m + k, c = -n + l, d = n + l;
        var o, p, q = 1 / (b - a),
            r = 1 / (d - c),
            s = 1 / (this.far - this.near),
            t = 2 * this.near * q,
            u = 2 * this.near * r,
            v = (b + a) * q,
            w = (d + c) * r;
        0 == this.far ? (o = Frustum.INFINITE_FAR_PLANE_ADJUST - 1, p = this.near * (Frustum.INFINITE_FAR_PLANE_ADJUST - 2)) : (o = -(this.far - this.near) * s, p = -2 * (this.far * this.near) * s), this.projMatrix = new Matrix4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this.projMatrix.m[0] = t, this.projMatrix.m[2] = v, this.projMatrix.m[5] = u, this.projMatrix.m[6] = w, this.projMatrix.m[10] = o, this.projMatrix.m[11] = p, this.projMatrix.m[14] = -1, this.mRecalcFrustum = !1
    },
    invalidateView: function() {
        this.mRecalcView = !0
    },
    invalidateFrustum: function() {
        this.mRecalcFrustum = !0
    },
    getOrientationForViewUpdate: function() {
        return this.mLastParentOrientation
    },
    getPositionForViewUpdate: function() {
        return this.mLastParentPosition
    },
    setGameObject: function(a) {
        this.mGameObject = a
    }
}, Frustum.INFINITE_FAR_PLANE_ADJUST = 1e-5;
var Camera = function(a) {
    Frustum.call(this), this.mRoot = a, this.name = "", this.auto_screen_size = !0, this.mPosition = new Vector3, this.mOrientation = new Quaternion, this.mRealOrientation = new Quaternion, this.mRealPosition = new Vector3, this.mDerivedOrientation = new Quaternion, this.mDerivedPosition = new Vector3, this.mParent = null, this.mUpDirection = new Vector3(0, 1, 0), this.mDirection = new Vector3(0, 0, -1)
};
extend(Camera, Frustum), Camera.prototype.reSize = function(a, b) {
    this.mRoot.debug && console.log("auto_screen_size:", this.auto_screen_size), this.auto_screen_size ? this.calcProjection_View_Matrix(0, a, b, 0) : this.calcProjection_View_Matrix(a, b)
}, Camera.prototype.setPosition = function(a, b, c) {
    1 == arguments.length ? a instanceof Vector3 ? this.mPosition.copy(a) : this.mRoot.debug && console.error("Camera setPosition type error") : 3 == arguments.length && this.mPosition.set(a, b, c), this.invalidateView()
}, Camera.prototype.getName = function() {
    return this.name
}, Camera.prototype.lookAt = function(a, b, c) {
    this.updateView();
    var d = new Vector3;
    1 == arguments.length ? a instanceof Vector3 ? d.copy(a) : this.mRoot.debug && console.error("Camera lookAt type error") : 3 == arguments.length && d.set(a, b, c), this.setDirection(d.sub(this.mRealPosition))
}, Camera.prototype.setUpDirection = function(a, b, c) {
    this.mUpDirection.x = a, this.mUpDirection.y = b, this.mUpDirection.z = c, this.mUpDirection.normalise(), this.invalidateView()
}, Camera.prototype.setDirection = function(a, b, c) {
    var d = new Vector3;
    if (1 == arguments.length ? a instanceof Vector3 ? d.copy(a) : this.mRoot.debug && console.error("Camera lookAt type error") : 3 == arguments.length && d.set(a, b, c), !d.equals(Vector3.ZERO)) {
        var e = d.negate();
        e.normalise(), this.mDirection.x = e.x, this.mDirection.y = e.y, this.mDirection.z = e.z;
        var f = new Quaternion,
            g = this.mUpDirection.cross(e);
        g.normalise();
        var h = e.cross(g);
        h.normalise(), f.setFromVector3(g, h, e), null !== this.mGameObject ? this.mOrientation = this.mGameObject.getTransform()._getDerivedOrientation().inverse().multiply(f) : this.mOrientation = f, this.invalidateView()
    }
}, Camera.prototype.setFOVy = function(a) {
    this.fov = a, this.invalidateFrustum()
}, Camera.prototype.reset = function() {
    this.mOrientation.set(1, 0, 0, 0), this.mPosition.set(0, 0, 0), this.invalidateView(), this.updateView()
}, Camera.prototype.isViewOutOfDate = function() {
    return null !== this.mGameObject ? (this.mRecalcView || this.mGameObject.getTransform()._getDerivedOrientation().notEquals(this.mLastParentOrientation) || this.mGameObject.getTransform()._getDerivedPosition().notEquals(this.mLastParentPosition)) && (this.mLastParentOrientation.copy(this.mGameObject.getTransform()._getDerivedOrientation()), this.mLastParentPosition.copy(this.mGameObject.getTransform()._getDerivedPosition()), this.mRealOrientation = this.mLastParentOrientation.multiply(this.mOrientation), this.mRealPosition = this.mLastParentOrientation.multiply(this.mPosition).add(this.mLastParentPosition), this.mRecalcView = !0) : (this.mRealOrientation.copy(this.mOrientation), this.mRealPosition.copy(this.mPosition)), this.mRecalcView && (this.mDerivedOrientation.copy(this.mRealOrientation), this.mDerivedPosition.copy(this.mRealPosition)), this.mRecalcView
}, Camera.prototype.calcProjection_View_Matrix = function(a, b, c, d) {
    if (void 0 !== c && void 0 !== d) {
        var e = b - a,
            f = c - d,
            g = e / f,
            h = Math.radians(.5 * this.fov),
            i = -(f / 2 / Math.tan(h)),
            j = 3 * -i;
        this.near = .1, this.far = j, this.aspect = g, this.mPosition.set(e / 2, f / 2, i), this.mOrientation.setFromAxisAngle(0, new Vector3(1, 0, 0));
        var k = new Matrix3(1, 0, 0, 0, -1, 0, 0, 0, -1);
        this.mOrientation.setFromMatrix(k)
    } else {
        var e = a,
            f = b;
        this.aspect = e / f;
        var h = Math.radians(.5 * this.fov);
        this.near = .1;
        var i = -(f / 2 / Math.tan(h)),
            j = 3 * -i;
        this.far = j, this.mRoot.debug && console.log("!!!!!!!!!!!!!!!=========="), this.mRoot.debug && console.log(this.mRoot.mCamera)
    }
    this.invalidateView(), this.invalidateFrustum()
}, Camera.prototype.setNearClipDistance = function(a) {
    this.near = a, this.invalidateView(), this.invalidateFrustum()
}, Camera.prototype.getNearClipDistance = function() {
    return this.near
}, Camera.prototype.setFarClipDistance = function(a) {
    this.far = a, this.invalidateView(), this.invalidateFrustum()
}, Camera.prototype.roll = function(a) {
    var b = this.mOrientation.multiply(new Vector3(0, 0, 1));
    this.rotate(b, a), this.invalidateView()
}, Camera.prototype.yaw = function(a) {
    var b = new Vector3;
    b = this.mOrientation.multiply(new Vector3(0, 1, 0)), this.rotate(b, a), this.invalidateView()
}, Camera.prototype.pitch = function(a) {
    var b = this.mOrientation.multiply(new Vector3(1, 0, 0));
    this.rotate(b, a), this.invalidateView()
}, Camera.prototype.rotate = function(a, b) {
    if (1 == arguments.length) {
        var c = new Quaternion;
        c.copy(a), c.normalize(), this.mOrientation = c.multiply(this.mOrientation), this.invalidateView()
    } else {
        var d = new Quaternion;
        d.setFromAxisAngle(b, a), this.rotate(d)
    }
}, Camera.prototype.getOrientationForViewUpdate = function() {
    return this.mRealOrientation
}, Camera.prototype.getPositionForViewUpdate = function() {
    return this.mRealPosition
}, Camera.prototype.getDerivedOrientation = function() {
    return this.updateView(), this.mDerivedOrientation
}, Camera.prototype.getDerivedPosition = function() {
    return this.updateView(), this.mDerivedPosition
}, Camera.prototype.getCameraToViewportRay = function(a, b) {
    var c = new Ray,
        d = this.getProjectionMatrix().multiply(this.getViewMatrix(!0)).inverse(),
        e = 2 * a - 1,
        f = 1 - 2 * b,
        g = new Vector3(e, f, -1),
        h = new Vector3(e, f, 0),
        i = d.multiply(g),
        j = d.multiply(h),
        k = j.sub(i);
    return k.normalise(), c.setTargetInNearPlane(h), c.setOrigin(i), c.setDirection(k), c
}, Camera.prototype.getParentGameObject = function() {
    return this.mGameObject
}, Camera.prototype.setParentGameObject = function(a) {
    this.mGameObject = a
};
var GameObject = function(a, b, c) {
    if (null == c) throw new Error("groupId cannot be null");
    Resource.call(this, c), this.mRoot = a, this.name = b || "", this.children = [], this.parent = null, this.Transform = new Transform(this), this.Transform.addListener(this), this.Renderer = new Renderer, this.MeshFilter = new MeshFilter(this.mRoot), this.mRenderQueueGroupID = null, this.mVisible = !0, this.mPickable = !1, this.mTag = 0, this.mLights = [], this.mSceneManager = null, this.mEvent = 0, this.mEventData = {
        isDown: !1,
        touchDownPos: null,
        objDownPos: null,
        lastPickPosInPlane: null,
        pickPosInPlane: null,
        dragPlane: null
    }, this.mTapEventData = {
        action: null,
        id: null,
        screenx: null,
        screeny: null,
        pickDownPos: null
    }, this.mDragEventData = {
        action: null,
        id: null,
        screenx: null,
        screeny: null,
        translateVector: null
    }, this.mMeshSkeletonName = null, this.mMeshSkeleton = null, this.mTapCallback = null, this.mDragCallback = null, this.mDefaultDrag = !1
};
extend(GameObject, Resource), GameObject.prototype = {
    constructor: GameObject,
    getMaterial: function() {
        return this.Renderer.material
    },
    getParent: function() {
        return this.parent
    },
    getRenderer: function() {
        return this.Renderer
    },
    getMeshFilter: function() {
        return this.MeshFilter
    },
    findVisibleObject: function(a) {
        if (a && this.mVisible) {
            this.Transform._updateFromParent();
            var b = 0;
            if (this.getMeshFilter()) {
                var c = this.getMeshFilter().mesh;
                c && c.mBoneIdList && (b = c.mBoneIdList.length)
            }
            if (b > 0) {
                if (!this.mMeshSkeleton && (this.mMeshSkeleton = this.mRoot.getSkeletonManager().getSkeletonByName(this.getGroupID()), this.mMeshSkeleton || (this.mMeshSkeleton = this.mRoot.getSkeletonManager().createSkeleton(this.getGroupID())), !this.mMeshSkeleton)) return void console.log("error findvisible object skinmesh has no skeleton ,objname=" + this.getName());
                this.mMeshSkeletonName = this.mMeshSkeleton.mSkeletonName, this.mMeshSkeleton.updateBoneMatrix(this)
            }
            var d = !0;
            d && null == this.Renderer.material && (d = !1), d && null == this.MeshFilter.mesh && (d = !1), d && (this.Renderer.material.doubleRender ? (a.addRenderable(this, 1), a.addRenderable(this, 2)) : a.addRenderable(this, this.mRenderQueueGroupID));
            for (var e = 0; e < this.children.length; e++) this.children[e].findVisibleObject(a)
        }
    },
    setParentSceneManager: function(a) {
        this.mSceneManager = a
    },
    getParentSceneManager: function() {
        return this.mSceneManager
    },
    addGameObject: function(a) {
        a.parent = this, a.mParent = this, this.children.push(a), this.Transform.addChild(a.Transform)
    },
    removeGameObject: function(a) {
        for (var b = 0; b < this.children.length; b++)
            if (a == this.children[b]) {
                this.children[b].parent = null, this.children[b].mParent = null, this.children.splice(b, 1);
                break
            }
    },
    _notifyTransformChanged: function() {
        for (var a = 0; a < this.mLights.length; a++) this.mLights[a]._notifyTransformChanged()
    },
    getTransform: function() {
        return this.Transform
    },
    setName: function(a) {
        this.name = a
    },
    getName: function() {
        return this.name
    },
    getGroupID: function() {
        return this.mGroupId
    },
    setTag: function(a) {
        this.mTag = a
    },
    getTag: function() {
        return this.mTag
    },
    setVisible: function(a) {
        this.mVisible = a
    },
    getVisible: function() {
        return this.mVisible
    },
    isVisible: function() {
        return this.mVisible
    },
    setPickable: function(a) {
        this.mPickable = a
    },
    getPickable: function() {
        return this.mPickable
    },
    getRayInModelSpace: function(a, b, c) {
        var d = a.getCameraToViewportRay(b, c);
        return this.convertRayInModelSpace(d)
    },
    convertRayInModelSpace: function(a) {
        var b = this.Transform.convertWorldToLocalPosition(a.getOrigin()),
            c = this.Transform.convertWorldToLocalPosition(a.getPoint(1)),
            d = c.sub(b),
            e = new Ray;
        return e.setOrigin(b), d.normalise(), e.setDirection(d), e
    },
    pickTest: function(a) {
        var b = null,
            c = this.mRoot.getMesh(this.MeshFilter.mesh);
        if (c && c.mManipulator) {
            var d = new Vector3(a.getScreenXCoordinate(), a.getScreenYCoordinate(), 0);
            d = this.Transform.convertWorldToLocalPosition(d), b = c.mManipulator.hitTest(d.x, d.y)
        } else if (c) {
            var e = this.convertRayInModelSpace(a.getPickRay());
            b = c.hitTest(e)
        }
        return b
    },
    pickRecursive: function(a, b, c, d, e, f) {
        if (null == e && (e = !0), null == f && (f = -1), this.mVisible && (e && this.mPickable || !e) && (-1 != f ? this.getTag() == f : !0)) {
            var g = null;
            g = this.pickTest(a), g && b.addPickedObject(this, g.interSP, g.objDistance)
        }
        for (var h = 0; h < this.children.length; h++) this.children[h].pickRecursive(a, b, c, d, e, f)
    },
    getPosition: function() {
        return this.Transform.getPosition()
    },
    setPosition: function(a, b, c) {
        this.Transform.setPosition(a, b, c)
    },
    getScale: function() {
        return this.Transform._getDerviedScale()
    },
    getRotation: function() {
        return this.Transform._getDerivedOrientation()
    },
    onTouchEvent: function(a, b, c, d, e) {
        if (a == e3d.TOUCH_DOWN) {
            if (this.mEventData.isDown = !0, this.mTapCallback && (this.mTapEventData.action = a, this.mTapEventData.id = b, this.mTapEventData.screenx = c, this.mTapEventData.screeny = d, this.mTapEventData.pickDownPos = e.intersectionPoint, this.mTapCallback(this.mTapEventData)), this.mEvent & 0 != EVENT_DRAG) {
                var f = this.mRoot.getRenderFunction().getCamera().mDirection,
                    g = new Vector3(f.x, f.y, f.z),
                    h = this.Transform.convertLocalToWorldPosition(e.intersectionPoint);
                this.mEventData.dragPlane = new Plane(g, h);
                var i = this.mRoot.getRenderFunction().getCamera().getCameraToViewportRay(c / this.mRoot.mPhoneWidth, d / this.mRoot.mPhoneHeight),
                    j = i.intersectPlane(this.mEventData.dragPlane),
                    k = this.Transform.convertWorldToModelPosition(j.interSP);
                if (this.mEventData.touchDownPos = new Vector3(k.x, k.y, k.z), this.mEventData.pickPosInPlane = new Vector3(k.x, k.y, k.z), this.getTransform()) {
                    var l = this.getTransform().getPosition();
                    this.mEventData.objDownPos = new Vector3(l.x, l.y, l.z)
                }
                this.mDragCallback && (this.mDragEventData.action = a, this.mDragEventData.id = b, this.mDragEventData.screenx = c, this.mDragEventData.screeny = d, this.mDragEventData.translateVector = new Vector3(0, 0, 0), this.mDragCallback(this.mDragEventData)), this.mEventData.lastPickPosInPlane = new Vector3(k.x, k.y, k.z)
            }
        } else if (a == e3d.TOUCH_UP) this.mEventData.isDown && (this.mTapCallback && (this.mTapEventData.action = a, this.mTapEventData.id = b, this.mTapEventData.screenx = c, this.mTapEventData.screeny = d, this.mTapEventData.pickDownPos = e.intersectionPoint, this.mTapCallback(this.mTapEventData)), this.mEventData.isDown = !1);
        else if (a == e3d.TOUCH_MOVE && this.mEvent & 0 != EVENT_DRAG && this.mEventData.isDown) {
            var m = this.getTransform(),
                i = (c / this.mRoot.mPhoneWidth, d / this.mRoot.mPhoneHeight, this.mRoot.getRenderFunction().getCamera().getCameraToViewportRay(c / this.mRoot.mPhoneWidth, d / this.mRoot.mPhoneHeight)),
                j = i.intersectPlane(this.mEventData.dragPlane);
            if (j) {
                this.mEventData.pickPosInPlane = this.Transform.convertWorldToModelPosition(j.interSP);
                var n = this.mEventData.pickPosInPlane.sub(this.mEventData.lastPickPosInPlane);
                if (this.mDragCallback && (this.mDragEventData.action = a, this.mDragEventData.id = b, this.mDragEventData.screenx = c, this.mDragEventData.screeny = d, this.mDragEventData.translateVector = n, this.mDragCallback(this.mDragEventData)), this.mDefaultDrag) {
                    var l = n.add(m.getPosition());
                    if (m.setPosition(l.x, l.y, l.z), this.mRoot.debug) {
                        console.log("DebugSySLog::: gameobject name =" + this.name + " position=" + l.x + " " + l.y + " " + l.z);
                        var o = this.getTransform().mPositionPercentage;
                        console.log("DebugSySLog::: percentage mode=" + this.getTransform().mTMode + " percentagePosition=" + o.x + " " + o.y + " " + o.z)
                    }
                }
            }
            this.mEventData.lastPickPosInPlane.x = this.mEventData.pickPosInPlane.x, this.mEventData.lastPickPosInPlane.y = this.mEventData.pickPosInPlane.y, this.mEventData.lastPickPosInPlane.z = this.mEventData.pickPosInPlane.z
        }
    },
    getChildrenAmount: function() {
        return this.children.length
    },
    getChild: function(a) {
        if ("number" == typeof a) return this.children[a];
        for (var b = 0; b < this.children.length; b++)
            if (this.children[b].getName() == a) return this.children[b]
    },
    eraseChildrenByGroupID: function(a) {
        for (var b = 0; b < this.children.length;) this.children[b].mGroupId == a ? this.children.splice(b, 1) : b++
    },
    setTapCallback: function(a) {
        this.mPickable = !0, this.mTapCallback = a
    },
    setDragCallback: function(a) {
        this.mPickable = !0, this.mDragCallback = a, this.mEvent += EVENT_DRAG
    },
    enableDefaultAutoDrag: function() {
        this.mPickable = !0, this.mEvent += EVENT_DRAG, this.mDefaultDrag = !0
    },
    enableDragGesture: function() {
        this.mPickable = !0, this.mEvent += EVENT_DRAG
    },
    disableDragGesture: function() {
        this.mEvent -= EVENT_DRAG
    },
    isGestureAllowed: function(a) {
        return this.mEvent & 0 != EVENT_DRAG ? !0 : !1
    },
    setGestureEventDelegate: function() {},
    setMaterial: function(a, b) {
        var c = this.mRoot.getMaterialManager().getByName(a, b);
        return c ? (this.getRenderer().setMaterial(c), !0) : !1
    },
    findLightByName: function(a) {
        for (var b in this.mLights) {
            var c = this.mLights[b];
            if (0 == c.name.localeCompare(a)) return c
        }
        return null
    }
};
var Component = function() {
    this.gameObjet = null
};
Component.prototype = {
    constructor: Component,
    _notifyTransformChanged: function() {},
    _notifyAttached: function(a) {},
    setGameObject: function(a) {
        this.gameObject = a
    },
    getGameObject: function(a) {
        return thi.gameObject
    }
};
var Light = function(a) {
    this.name = a, this.gameObject = null, this.mLightType = Light.LT_POINT, this.mDiffuse = [1, 1, 1, 1], this.mSpecular = [0, 0, 0, 1], this.mSpotInner = Math.radians(30), this.mSpotOuter = Math.radians(40), this.mSpotFalloff = 1, this.mRange = 1e5, this.mAttenuationConst = 1, this.mAttenuationLinear = 0, this.mAttenuationQuad = 0, this.mPowerScale = 1, this.mPosition = new Vector3(0, 0, 0), this.mDirection = new Vector3(0, 0, 1), this.mDerivedPosition = new Vector3(0, 0, 0), this.mDerivedDirection = new Vector3(0, 0, 1), this.mDerivedTransformDirty = !1
};
extend(Light, Component), Light.LT_POINT = 0, Light.LT_DIRECTIONAL = 1, Light.LT_SPOTLIGHT = 2, Light.prototype.setVisible = function(a) {
    this.gameObject.setVisible(a)
}, Light.prototype.setType = function(a) {
    this.mLightType = a
}, Light.prototype.getType = function() {
    return this.mLightType
}, Light.prototype._notifyTransformChanged = function() {
    this.mDerivedTransformDirty = !0
}, Light.prototype.update = function() {
    if (this.mDerivedTransformDirty) {
        if (this.gameObject) {
            var a = this.gameObject.getTransform()._getDerivedOrientation(),
                b = this.gameObject.getTransform()._getDerivedPosition();
            this.mDerivedDirection = a.multiply(this.mDirection), this.mDerivedPosition = a.multiply(this.mPosition).add(b)
        } else this.mDerivedPosition = this.mPosition, this.mDerivedDirection = this.mDirection;
        this.mDerivedTransformDirty = !1
    }
}, Light.prototype.setPosition = function(a) {
    this.mPosition = a, this.mDerivedTransformDirty = !0
}, Light.prototype.getPosition = function() {
    return this.mPosition
}, Light.prototype.setDirection = function(a) {
    this.mDirection = a, this.mDerivedTransformDirty = !0
}, Light.prototype.getDirection = function() {
    return this.mDirection
}, Light.prototype.getDerivedPosition = function(a) {
    return this.update(), this.mDerivedPosition
}, Light.prototype.getDerivedDirection = function() {
    return this.update(), this.mDerivedDirection
}, Light.prototype.getAs4DVector = function(a) {
    null == a && (a = !1);
    var b = new Vector4;
    if (this.mLightType == Light.LT_DIRECTIONAL) {
        var c = this.getDerivedDirection().multiply(-1);
        b.x = c.x, b.y = c.y, b.z = c.z, b.w = 0
    } else {
        var c = this.getDerivedPosition(a);
        b.x = c.x, b.y = c.y, b.z = c.z, b.w = 1
    }
    return b
}, Light.prototype.setPowerScale = function(a) {
    this.mPowerScale = a
}, Light.prototype.getPowerScale = function() {
    return this.mPowerScale
}, Light.prototype.setDiffuseColour = function(a) {
    this.mDiffuse = a
}, Light.prototype.setDiffuseColourRGB = function(a, b, c) {
    this.mDiffuse[0] = a, this.mDiffuse[1] = b, this.mDiffuse[2] = c
}, Light.prototype.getDiffuseColour = function() {
    return this.mDiffuse
}, Light.prototype.setSpecularColour = function(a) {
    this.mSpecular = a
}, Light.prototype.getSpecularColour = function() {
    return this.mSpecular
}, Light.prototype.setAttenuation = function(a, b, c, d) {
    this.mRange = a, this.mAttenuationConst = b, this.mAttenuationLinear = c, this.mAttenuationQuad = d
}, Light.prototype.setAttenuationRange = function(a) {
    this.mRange = a
}, Light.prototype.setAttenuationConstant = function(a) {
    this.mAttenuationConst = a
}, Light.prototype.setAttenuationLinear = function(a) {
    this.mAttenuationLinear = a
}, Light.prototype.setAttenuationQuadric = function(a) {
    this.mAttenuationQuad = a
}, Light.prototype.getAttenuationRange = function() {
    return this.mRange
}, Light.prototype.getAttenuationConstant = function() {
    return this.mAttenuationConst
}, Light.prototype.getAttenuationLinear = function() {
    return this.mAttenuationLinear
}, Light.prototype.getAttenuationQuadric = function() {
    return this.mAttenuationQuad
}, Light.prototype.getSpotlightInnerAngle = function() {
    return this.mSpotInner
}, Light.prototype.getSpotlightOuterAngle = function() {
    return this.mSpotOuter
}, Light.prototype.getSpotlightFalloff = function() {
    return this.mSpotFalloff
}, Light.prototype.setSpotlightRange = function(a, b, c) {
    this.mSpotInner = a, this.mSpotOuter = b, this.mSpotFalloff = c
}, Light.prototype.setSpotlightInnerAngle = function(a) {
    this.mSpotInner = a
}, Light.prototype.setSpotlightOuterAngle = function(a) {
    this.mSpotOuter = a
}, Light.prototype.setSpotlightFalloff = function(a) {
    this.mSpotFalloff = a
};
var Transform = function(a) {
    this.mGameObject = a, this.mParent = a.Transform, this.mChildren = [], this.mListeners = [], this.mOrientation = new Quaternion(1, 0, 0, 0), this.mScale = new Vector3(1, 1, 1), this.mPosition = new Vector3(0, 0, 0), this.mPositionPercentage = new Vector3(0, 0, 0), this.mTMode = LayoutMode.NONE, this.mPositionOffset = new Vector3(0, 0, 0), this.mCachedTransform = new Matrix4, this.mCachedInverseTransform = new Matrix4, this.mDerivedOrientation = new Quaternion(1, 0, 0, 0), this.mDerivedPosition = new Vector3(0, 0, 0), this.mDerivedScale = new Vector3(1, 1, 1), this.mInheritOrientation = !0, this.mInheritScale = !0, this.mInverseTransformOutOfDate = !0, this.flag = 0, this.mWorldTransformOriginInvTpCache = null, this.mWorldTransformOriginCache = null, this.needUpdate()
};
Transform.prototype = {
    constructor: Transform,
    updateMatrixWorld: function() {
        if (null != this.mParent) {
            var a = this.mParent._getDerivedOrientation();
            this.mDerivedOrientation = this.mOrientation.multiply(a), this.mDerivedPosition = this.mPosition.add(this.mParent._getDerivedPosition()), this.mDerivedScale = this.mScale.multiply(this.mParent._getDerivedScale())
        } else this.mDerivedOrientation = this.mOrientation, this.mDerivedPosition = this.mPosition, this.mDerivedScale = this.mScale;
        this.mCachedTransform.makeTransform(this.mDerivedPosition, this.mDerivedOrientation, this.mDerivedScale), 0 == this.flag && this.flag++
    },
    addListener: function(a) {
        this.mListeners.push(a)
    },
    getTransform: function() {
        return this.mCachedTransform
    },
    roll: function(a, b) {
        this.rotate(new Vector3(0, 0, 1), a, b)
    },
    pitch: function(a, b) {
        this.rotate(new Vector3(1, 0, 0), a, b)
    },
    yaw: function(a, b) {
        this.rotate(new Vector3(0, 1, 0), a, b)
    },
    scale: function(a) {
        this.mScale = this.mScale.multiply(a), this.needUpdate()
    },
    _rotate: function(a, b) {
        null == b && (b = TS_LOCAL);
        var c = new Quaternion;
        switch (c.copy(a), c.normalize(), b) {
            case TS_LOCAL:
                this.mOrientation = c.multiply(this.mOrientation);
                break;
            case TS_WORLD:
                this.mOrientation = this.mOrientation.multiply(this._getDerivedOrientation()).inverse().multiply(c).multiply(this._getDerivedOrientation());
                break;
            case TS_LOCAL:
                this.mOrientation = this.mOrientation.multiply(c);
                break;
            case TS_NOT_ADD:
                this.mOrientation = c
        }
        this.needUpdate()
    },
    rotate: function(a, b, c) {
        if (3 == arguments.length) {
            var d = new Quaternion;
            d.setFromAngleAxis(b, a), this._rotate(d, c)
        } else if (2 === arguments.length) {
            var e = new Quaternion;
            switch (e.copy(arguments[0]), e.normalize(), arguments[1]) {
                case TS_LOCAL:
                    this.mOrientation = e.multiply(this.mOrientation);
                    break;
                case TS_WORLD:
                    this.mOrientation = this.mOrientation.multiply(this._getDerivedOrientation().inverse()).multiply(e).multiply(this._getDerivedOrientation());
                    break;
                case TS_LOCAL:
                    this.mOrientation = this.mOrientation.multiply(e);
                    break;
                case TS_NOT_ADD:
                    this.mOrientation = e
            }
            this.needUpdate()
        }
    },
    getGameObject: function() {
        return this.mGameObject
    },
    setParent: function(a) {
        this.mParent = a, this.needUpdate()
    },
    getParent: function() {
        return this.mParent
    },
    _getFullTransform: function() {
        return this.mCachedTransformOutOfDate && (this.mCachedTransform.makeTransform(this._getDerivedPosition(), this._getDerivedOrientation(), this._getDerivedScale()), this.mCachedTransformOutOfDate = !1), this.mCachedTransform
    },
    _getInverseTransform: function() {
        return this.mInverseTransformOutOfDate && (this.mCachedInverseTransform.makeInverseTransform(this._getDerivedPosition(), this._getDerivedOrientation(), this._getDerivedScale()), this.mInverseTransformOutOfDate = !1), this.mCachedInverseTransform
    },
    _updateFromParent: function() {
        if (this.mParent) {
            var a = this.mParent._getDerivedOrientation();
            this.mInheritOrientation ? this.mDerivedOrientation = a.multiply(this.mOrientation) : this.mDerivedOrientation = this.mOrientation;
            var b = this.mParent._getDerivedScale();
            this.mInheritScale ? this.mDerivedScale = b.multiply(this.mScale) : this.mDerivedScale = this.mScale, this.mDerivedPosition = a.multiply(b.multiply(this.mPosition)), this.mDerivedPosition = this.mDerivedPosition.add(this.mParent._getDerivedPosition())
        } else this.mDerivedOrientation = this.mOrientation, this.mDerivedPosition = this.mPosition, this.mDerivedScale = this.mScale;
        this.mCachedTransformOutOfDate = !0, this.mInverseTransformOutOfDate = !0, this.mNeedParentUpdate = !1
    },
    _setDerivedPosition: function(a) {
        this.setPosition(this.mParent.convertWorldToLocalPosition(a))
    },
    _getDerivedOrientation: function() {
        return this.mNeedParentUpdate && this._updateFromParent(), this.mDerivedOrientation
    },
    _getDerivedPosition: function() {
        return this.mNeedParentUpdate && this._updateFromParent(), this.mDerivedPosition
    },
    _getDerivedScale: function() {
        return this.mNeedParentUpdate && this._updateFromParent(), this.mDerivedScale
    },
    translate: function(a, b) {
        switch (null == b && (b = TS_PARENT), b) {
            case TS_LOCAL:
                this.mPosition = this.mPosition.add(this.mOrientation.multiply(a));
                break;
            case TS_WORLD:
                this.mParent ? this.mPosition = this.mPosition.add(this.mParent._getDerivedOrientation().Inverse().multiply(a).div(this.mParent._getDerivedScale())) : this.mPosition = this.mPosition.add(a);
                break;
            case TS_PARENT:
                this.mPosition = this.mPosition.add(a)
        }
        this.needUpdate()
    },
    setPositionPercentage: function(a, b, c, d) {
        null == d ? d = this.mTMode : this.mTMode = d, this.mPositionPercentage.x = a, this.mPositionPercentage.y = b, this.mPositionPercentage.z = c;
        var e = this.mGameObject.mRoot.mPhoneWidth,
            f = this.mGameObject.mRoot.mPhoneHeight;
        switch (d) {
            case LayoutMode.NONE:
                this.setPosition(a, b, c, !1);
                break;
            case LayoutMode.SHORTSIDE_OLD:
            case LayoutMode.STRETCH_OLD:
                this.mPosition.x = e * a + this.mPositionOffset.x, this.mPosition.y = f * b + this.mPositionOffset.y, this.mPosition.z = e * c + this.mPositionOffset.z;
                break;
            case LayoutMode.SHORTSIDE:
                var g = e > f ? f : e;
                this.mPosition.x = g * a + this.mPositionOffset.x, this.mPosition.y = g * b + this.mPositionOffset.y, this.mPosition.z = g * c + this.mPositionOffset.z;
                break;
            case LayoutMode.STRETCH:
                this.mPosition.x = e * a + this.mPositionOffset.x, this.mPosition.y = f * b + this.mPositionOffset.y, this.mPosition.z = e * c + this.mPositionOffset.z;
                break;
            case LayoutMode.LONGSIDE:
                var g = e > f ? e : f;
                this.mPosition.x = g * a + this.mPositionOffset.x, this.mPosition.y = g * b + this.mPositionOffset.y, this.mPosition.z = g * c + this.mPositionOffset.z
        }
    },
    getPositionPercentage: function() {
        return this.mPositionPercentage
    },
    setPosition: function(a, b, c, d) {
        if (null == d && (d = !0), a instanceof Vector3) this.mPosition.copy(a);
        else {
            var e = new Vector3(a, b, c);
            this.mPosition.copy(e)
        }
        d && this._calculatePositionPercentage(), this.needUpdate()
    },
    _calculatePositionPercentage: function() {
        var a = this.mGameObject.mRoot.mPhoneWidth,
            b = this.mGameObject.mRoot.mPhoneHeight;
        switch (this.mTMode) {
            case LayoutMode.NONE:
                break;
            case LayoutMode.SHORTSIDE_OLD:
            case LayoutMode.STRETCH_OLD:
                this.mPositionPercentage.x = (this.mPosition.x - this.mPositionOffset.x) / a, this.mPositionPercentage.y = (this.mPosition.y - this.mPositionOffset.y) / b, this.mPositionPercentage.z = (this.mPosition.z - this.mPositionOffset.z) / a;
                break;
            case LayoutMode.SHORTSIDE:
                var c = a > b ? b : a;
                this.mPositionPercentage.x = (this.mPosition.x - this.mPositionOffset.x) / c, this.mPositionPercentage.y = (this.mPosition.y - this.mPositionOffset.y) / c, this.mPositionPercentage.z = (this.mPosition.z - this.mPositionOffset.z) / c;
                break;
            case LayoutMode.STRETCH:
                this.mPositionPercentage.x = (this.mPosition.x - this.mPositionOffset.x) / a, this.mPositionPercentage.y = (this.mPosition.y - this.mPositionOffset.y) / b, this.mPositionPercentage.z = (this.mPosition.z - this.mPositionOffset.z) / a;
                break;
            case LayoutMode.LONGSIDE:
                var c = a > b ? a : b;
                this.mPositionPercentage.x = (this.mPosition.x - this.mPositionOffset.x) / c, this.mPositionPercentage.y = (this.mPosition.y - this.mPositionOffset.y) / c, this.mPositionPercentage.z = (this.mPosition.z - this.mPositionOffset.z) / c
        }
    },
    getPosition: function() {
        return this.mPosition
    },
    setOrientation: function(a) {
        this.mOrientation.copy(a), this.mOrientation.normalize(), this.needUpdate()
    },
    getOrientation: function() {
        return this.mOrientation
    },
    resetOrientation: function() {
        this.mOrientation.copy(new Quaternion(1, 0, 0, 0)), this.needUpdate()
    },
    setScale: function(a, b, c) {
        if (a instanceof Vector3) this.mScale.copy(a), this.needUpdate();
        else {
            if (3 !== arguments.length) throw new Error("value is not a number");
            var d = new Vector3(a, b, c);
            this.mScale.copy(d), this.needUpdate()
        }
    },
    getScale: function() {
        return this.mScale
    },
    needUpdate: function(a) {
        this.mNeedParentUpdate = !0, this.mNeedChildUpdate = !0, this.mCachedTransformOutOfDate = !0, this.mInverseTransformOutOfDate = !0;
        for (var b = 0; b < this.mListeners.length; b++) this.mListeners[b]._notifyTransformChanged()
    },
    setInheritOrientation: function(a) {
        this.mInheritOrientation = a, this.needUpdate()
    },
    getInheritOrientation: function() {
        return this.mInheritOrientation
    },
    setInheritScale: function(a) {
        this.mInheritScale = a, this.needUpdate()
    },
    getInheritScale: function() {
        return this.mInheritScale
    },
    removeChild: function(a) {
        a.setParent(null);
        for (var b in this.mChildren) a == this.mChildren[b] && (this.mChildren[b] = null)
    },
    addChild: function(a) {
        a.setParent(this), this.mChildren.push(a)
    },
    convertWorldToModelPosition: function(a) {
        return this.mNeedParentUpdate && this._updateFromParent(), this.mParent.mDerivedOrientation.inverse().multiply(a.sub(this.mParent.mDerivedPosition).div(this.mParent.mDerivedScale))
    },
    convertWorldToLocalPosition: function(a) {
        return this.mNeedParentUpdate && this._updateFromParent(), this.mDerivedOrientation.inverse().multiply(a.sub(this.mDerivedPosition).div(this.mDerivedScale))
    },
    convertLocalToWorldPosition: function(a) {
        return this.mNeedParentUpdate && this._updateFromParent(), this.mDerivedOrientation.multiply(a).multiply(this.mDerivedScale).add(this.mDerivedPosition)
    },
    convertWorldToLocalOrientation: function(a) {
        return this.mNeedParentUpdate && this._updateFromParent(), this.mDerivedOrientation.inverse().multiply(a)
    },
    convertLocalToWorldOrientation: function(a) {
        return this.mNeedParentUpdate && this._updateFromParent(), this.mDerivedOrientation.multiply(a)
    },
    _update: function(a, b) {
        if (this.mParentNotified = !1, a || this.mNeedChildUpdate || this.mNeedChildUpdate || b) {
            if ((this.mNeedParentUpdate || b) && this._updateFromParent(), this.mNeedChildUpdate || b)
                for (var c = 0; c < this.mChildren.length; c++) this.mChildren[c]._update(!0, !0);
            this.mNeedChildUpdate = !1
        }
    },
    getOriginWorldTransform: function() {
        return this.mWorldTransformOriginCache
    },
    getOriginWorldInvTpTransform: function() {
        return this.mWorldTransformOriginInvTpCache
    },
    setOriginWorldTransform: function() {
        this.mWorldTransformOriginCache = this._getFullTransform(), this.mWorldTransformOriginInvTpCache = this.mWorldTransformOriginCache.inverse().transpose()
    }
};
var TS_LOCAL = 0,
    TS_PARENT = 1,
    TS_WORLD = 2,
    TS_NOT_ADD = 3,
    Renderer = function() {
        this.material = null
    };
Renderer.prototype = {
    constructor: Renderer,
    getMaterial: function() {
        return this.material
    },
    setMaterial: function(a) {
        this.material = a
    }
};
var MeshFilter = function(a) {
    this.mRoot = a, this.mesh = null
};
MeshFilter.prototype = {
    constructor: MeshFilter,
    getMesh: function() {
        return this.mRoot.getMesh(this.mesh)
    }
};
var Pass = function(a, b) {
    this.mRoot = a, this.mParentMaterial = b, this.vertex_program_ref = "", this.fragment_program_ref = "", this.TextureUnitStates = [], this.vertexProgram = null, this.fragmentProgram = null, this.mSourceBlendFactor = SBF_ONE, this.mDestBlendFactor = SBF_ZERO, this.mBlendOperation = SBO_ADD, this.mScissorCheck = !1, this.mDepthCheck = !0, this.mDepthWrite = !0, this.mCullMode = CULL_ANTICLOCKWISE, this.mAmbient = [1, 1, 1, 1], this.mDiffuse = [1, 1, 1, 1], this.mSpecular = [0, 0, 0, 1], this.mEmissive = [0, 0, 0, 1], this.mShininess = 1, this.mColorModifier = [1, 1, 1, 1], this.mSeparateBlend = !1, this.mRefStrength = 0, this.muv_repeat = [1, 1]
};
Pass.prototype = {
    constructor: Pass,
    load: function(a, b) {
        for (var c in this.TextureUnitStates) {
            var d = this.TextureUnitStates[c];
            d.load(a, b)
        }
    },
    setAmbient: function(a) {
        a instanceof Array ? this.mAmbient = a : this.mAmbient = [a.r, a.g, a.b, a.a];
    },
    getAmbient: function() {
        return this.mAmbient
    },
    setDiffuse: function(a) {
        a instanceof Array ? this.mDiffuse = a : this.mDiffuse = [a.r, a.g, a.b, a.a]
    },
    getDiffuse: function() {
        return this.mDiffuse
    },
    setSpecular: function(a) {
        a instanceof Array ? this.mSpecular = a : this.mSpecular = [a.r, a.g, a.b, a.a]
    },
    getSpecular: function() {
        return this.mSpecular
    },
    setEmissive: function(a) {
        a instanceof Array ? this.mEmissive = a : this.mEmissive = [a.r, a.g, a.b, a.a]
    },
    getEmissive: function() {
        return this.mEmissive
    },
    setShininess: function(a) {
        this.mShininess = a
    },
    getShininess: function() {
        return this.mShininess
    },
    getReflectEnvStrength: function() {
        return this.mRefStrength
    },
    setReflectEnvStrength: function(a) {
        this.mRefStrength = a
    },
    setColorModifier: function(a) {
        a instanceof Array ? this.mColorModifier = a : this.mColorModifier = [a.r, a.g, a.b, a.a]
    },
    setColorModifierAlpha: function(a) {
        this.mColorModifier[3] = a
    },
    getColorModifier: function() {
        return this.mColorModifier
    },
    buildProgram: function() {
        if (!this.vertexProgram || !this.fragmentProgram) {
            for (var a in this.mRoot.mVertexProgram) {
                var b = this.mRoot.mVertexProgram[a];
                if (b.name == this.vertex_program_ref) {
                    this.vertexProgram = this.mRoot.mVertexProgram[a];
                    break
                }
            }
            for (var a in this.mRoot.mFragmentProgram) {
                var b = this.mRoot.mFragmentProgram[a];
                if (b.name == this.fragment_program_ref) {
                    this.fragmentProgram = this.mRoot.mFragmentProgram[a];
                    break
                }
            }
        }
    },
    setSceneBlending: function(a, b) {
        this.mSourceBlendFactor = a, this.mDestBlendFactor = b, this.mSeparateBlend = !1
    },
    setReflectionStrength: function(a) {
        this.mRefStrength = a
    },
    setUVRepeat: function(a) {
        this.muv_repeat[0] = a.x, this.muv_repeat[1] = a.y
    },
    getUVRepeat: function() {
        return this.muv_repeat
    },
    getTextureUnitState: function(a) {
        return this.TextureUnitStates.length <= a || 0 > a ? null : this.TextureUnitStates[a]
    },
    getFragmentProgramParameters: function() {
        this.buildProgram();
        var a = this.vertex_program_ref + "-" + this.fragment_program_ref,
            b = this.mRoot.getRenderFunction().mLinkProgramMap[a];
        null == b && (b = new LinkProgram(this.mRoot, this.vertexProgram, this.fragmentProgram), this.mRoot.getRenderFunction().mLinkProgramMap[a] = b), b.activate();
        for (var c = {}, d = 0; d < b.GLUniformReferenceList.length; d++) {
            var e = b.GLUniformReferenceList[d];
            c[e[3]] = e
        }
        return c.setNamedConstant = function(a, b, d, e) {
            if ("number" == typeof b) b = [b];
            else if (b instanceof Vector2) b = [b.x, b.y];
            else if (b instanceof Vector3) b = [b.x, b.y, b.z];
            else if (b instanceof Vector4) b = [b.x, b.y, b.z, b.w];
            else if ("object" == typeof b && !(b instanceof Array)) {
                var f = new Array;
                for (var g in b) f.push(b[g]);
                b = f
            }
            var h = c[a];
            null != h && (d && (h.type = d), e && (h.extra_info = e), c[a][2] = b)
        }, c
    }
};
var Archive = function(a) {
        this.mRoot = a
    },
    postCreateScene;
Archive.prototype = {
    constructor: Archive,
    imageLoad: function(a, b, c) {
        null == c && (c = "");
        var d = document.createElement("img");
        d.crossOrigin = "Anonymous", d.onload = function() {
            b && b(this)
        };
        var e = this;
        d.onerror = function() {
            return "number" == typeof c ? c++ : c = 0, c > e3d.searchPaths.length - 1 ? void console.error("Cannot find image", a) : void e.imageLoad(a, b, c)
        }, "string" == typeof c ? e3d.isUrl(a) || "" === c ? d.src = a : d.src = c + "/" + a : d.src = e3d.searchPaths[c] + "/" + a
    },
    audioLoad: function(a, b, c) {
        null == c && (c = "");
        var d = document.createElement("Audio");
        b && b(d), d.onload = function() {}, d.onerror = function() {}, "string" == typeof c ? e3d.isUrl(a) || "" === c ? d.src = a : d.src = c + "/" + a : d.src = e3d.searchPaths[c] + "/" + a
    },
    binaryLoad: function(a, b, c, d) {
        null == c && (c = "");
        var e;
        e = e3d.isUrl(a) || "" === c ? a : c + "/" + a;
        var f = new XMLHttpRequest;
        f.open("GET", e), f.withCredentials = !0, f.responseType = "arraybuffer", f.onreadystatechange = function() {
            4 == f.readyState && (200 == f.status && f.response ? b(f.response, d) : console.log("Failed to download:" + f.status + " " + f.statusText))
        }, f.send()
    },
    textLoad: function(a, b, c, d) {
        null == c && (c = "");
        var e;
        e = e3d.isUrl(a) || "" === c ? a : c + "/" + a;
        var f = new XMLHttpRequest;
        f.open("GET", e), f.withCredentials = !0, f.overrideMimeType("text/plain; charset=x-user-defined");
        var g = !1;
        "aes" === StringConverter.getSuffix(a) && (g = !0, f.responseType = "arraybuffer"), f.onreadystatechange = function() {
            4 == f.readyState && (g ? b(CryptoJS.enc.Utf8.stringify(CryptoJS.AES.decrypt(e3d.arrayBufferToBase64(f.response), CryptoJS.enc.Utf8.parse(e3d._drowssap_sea), {
                mode: CryptoJS.mode.ECB
            })).toString(), d) : b(f.responseText, d))
        }, f.send()
    },
    videoLoad: function(a, b, c) {
        if ("null" == a) return void console.log("null video");
        var d = null;
        d = "string" == typeof c ? e3d.isUrl(a) || "" === c ? a : c + "/" + a : e3d.searchPaths[c] + "/" + a;
        var e = StringConverter.getSuffix(a);
        "mp4" == e || "ogg" == e ? this.defaultVideoLoad(b, d) : "mpg" == e && this.mPegVideoLoad(b, d)
    },
    defaultVideoLoad: function(a, b) {
        var c = (this.mRoot.getBrowserInfo(), null);
        c = document.createElement("video"), document.body.appendChild(c), c.style.display = "none", c.crossOrigin = "Anonymous";
        var d = this;
        c.addEventListener("error", function() {
            console.log("video loadError filename=+" + b)
        }), c.addEventListener("play", function() {}), c.onload = function() {}, c.preload = !0, c.src = b, c.autoplay = !0, c.type = "video/mp4", c.loop = !0, c.setAttribute("webkit-playsinline", "webkit-playsinline");
        var d = this;
        c.addEventListener("canplay", function() {
            if (a) {
                var b = new VideoTexture(d.mRoot, this);
                this.play(), a(b), a = null
            }
        })
    },
    mPegVideoLoad: function(a, b) {
        var c = document.createElement("canvas"),
            d = this,
            e = new jsmpeg(b, {
                canvas: c,
                autoplay: !0,
                loop: !0,
                onload: function() {
                    var b = new MpegTexture(d.mRoot, c, e);
                    a(b)
                }
            })
    },
    mPegProfileLoad: function(a, b) {
        var c = this,
            d = new jsmpeg(b, {
                onload: function() {
                    var b = new MpegProfileTexture(c.mRoot, d);
                    a(b)
                }
            })
    },
    arrayBufferTextureLoad: function(a, b, c, d, e) {
        var e = this,
            f = new XMLHttpRequest,
            g = e.mPrefix + "/" + a;
        this.mRoot.debug && console.log("text:" + g), e.mPrefix || (g = a), f.open("GET", g, !0), f.withCredentials = !0, f.addEventListener("load", function() {
            b && b(this.response)
        }, !1), void 0 !== c && f.addEventListener("progress", function(a) {
            c(a)
        }, !1), null !== this.responseType && (f.responseType = "arraybuffer"), f.send(null)
    },
    scriptLoad: function(a, b, c) {
        var d = c.mPrefix + "/" + a;
        e3d.isUrl(a) && (d = a), this.mRoot.debug && console.log("text:" + d), c.mPrefix || (d = a);
        var e = document.getElementsByTagName("head").item(0),
            f = document.createElement("script");
        f.type = "text/javascript", this.mRoot.mCurrentSceneGroupID = c.mGroupId, f.onload = f.onreadystatechange = function() {
            f.onload = f.onreadystatechange = null, e3d.runRequireList(b), f.parentNode.removeChild(f)
        }, f.src = d, e.appendChild(f)
    }
};
var TextureManager = function(a) {
    if (null == a) throw new Error("root cannot be null");
    this.mRoot = a, this.mTextures = {}
};
TextureManager.prototype = {
    constructor: TextureManager,
    create: function(a, b) {
        var c = this.getByName(a, b);
        return null != c ? c : (c = new Texture(this.mRoot), c.mGroupId = b, c.filename = a, null == this.mTextures[b] && (this.mTextures[b] = {}), null == this.mTextures[b][a] && (this.mTextures[b][a] = c), c)
    },
    createManual: function(a, b, c, d, e) {
        var f = this.create(a, b);
        f.mWidth = c, f.mHeight = d;
        var g = this.mRoot.getRenderFunction().gl;
        return f.isRenderTarget = !0, f.fboBuffer = g.createFramebuffer(), g.bindFramebuffer(g.FRAMEBUFFER, f.fboBuffer), f.fboBuffer.width = c, f.fboBuffer.height = d, f.textureID = g.createTexture(), g.bindTexture(g.TEXTURE_2D, f.textureID), g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, !0), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.LINEAR), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.LINEAR), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE), g.texImage2D(g.TEXTURE_2D, 0, g.RGBA, f.fboBuffer.width, f.fboBuffer.height, 0, g.RGBA, g.UNSIGNED_BYTE, null), g.framebufferTexture2D(g.FRAMEBUFFER, g.COLOR_ATTACHMENT0, g.TEXTURE_2D, f.textureID, null), this.fboDepthRenderbuffer = g.createRenderbuffer(), g.bindRenderbuffer(g.RENDERBUFFER, this.fboDepthRenderbuffer), g.renderbufferStorage(g.RENDERBUFFER, g.DEPTH_COMPONENT16, f.fboBuffer.width, f.fboBuffer.height), g.framebufferRenderbuffer(g.FRAMEBUFFER, g.DEPTH_ATTACHMENT, g.RENDERBUFFER, this.fboDepthRenderbuffer), g.clearColor(e[0], e[1], e[2], e[3]), g.clear(g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT), g.bindTexture(g.TEXTURE_2D, null), g.bindRenderbuffer(g.RENDERBUFFER, null), g.bindFramebuffer(g.FRAMEBUFFER, null), f
    },
    getByName: function(a, b) {
        if (null == b) throw new Error("groupId cannot be null");
        var c = this.mTextures[b];
        return null == c ? null : c[a]
    },
    releaseByGroupId: function(a) {
        var b = this.mTextures[a];
        if (null != b) {
            for (var c in b) {
                var d = b[c];
                null != d.textureID && d.destroy()
            }
            delete this.mTextures[a]
        }
    },
    releaseAll: function() {
        for (var a in this.mTextures) {
            var b = this.mTextures[a];
            for (var a in b) {
                var c = b[a];
                null != c.textureID && c.destroy()
            }
        }
        this.mTextures = {}
    },
    isAllTexturePrepared: function() {
        for (var a in this.mTextures) {
            var b = this.mTextures[a];
            for (var a in b) {
                var c = b[a];
                if (null == c.textureID) return !1
            }
        }
        return !0
    }
};
var Texture = function(a) {
    Resource.call(this), this.mRoot = a;
    this.mRoot.getRenderFunction().gl;
    this.filename = null, this.textureID = null, this.isRenderTarget = !1, this.fboBuffer = null, this.fboDepthRenderbuffer = null, this.mWidth = 0, this.mHeight = 0
};
extend(Texture, Resource), Texture.prototype = {
    constructor: Texture,
    bind: function() {
        var a = this.mRoot.getRenderFunction().gl;
        a.bindTexture(a.TEXTURE_2D, this.textureID)
    },
    load: function(a, b) {
        var c = this;
        this.mRoot.mArchive.imageLoad(this.filename, function(b) {
            c._loadImpl(b, a, c.filename), c.mWidth = b.width, c.mHeight = b.height
        }, b)
    },
    _loadImpl: function(a, b, c) {
        var d = this.mRoot.mTimer.getCurrTime();
        Log.append("[u] " + c + " [t] " + d);
        var e = this.mRoot.getRenderFunction().gl;
        this.textureID = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.textureID), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !0), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, a), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), Log.info("[e] " + c + " [c] " + (this.mRoot.mTimer.getCurrTime() - d)), a = null, b && b()
    },
    getWidth: function() {
        return this.mWidth
    },
    getHeight: function() {
        return this.mHeight
    },
    destroy: function() {
        var a = this.mRoot.getRenderFunction().gl;
        null != this.fboDepthRenderbuffer && (a.deleteRenderbuffer(this.fboDepthRenderbuffer), this.fboDepthRenderbuffer = null), null != this.fboBuffer && (a.deleteFramebuffer(this.fboBuffer), this.fboBuffer = null), null != this.textureID && (a.deleteTexture(this.textureID), this.textureID = null)
    }
}, VideoType = {
    normal: 1,
    canvas: 2
};
var VideoTexture = function(a, b) {
    Texture.call(this, a), this.mVideo = b, this.mVideoCanvas = null, this.mVideoImg = null, this._createVideoTexture(b)
};
extend(VideoTexture, Texture), VideoTexture.prototype._createVideoTexture = function(a) {
    this.mVideo = a, this.mVideoCanvas = document.createElement("canvas"), this.mVideoImg = this.mVideoCanvas.getContext("2d"), this.mWidth = a.videoWidth, this.mHeight = a.videoHeight, console.log("video texture width =" + this.mWidth + " video texture height =" + this.mHeight), a.width = this.mWidth, a.height = this.mHeight, this.mVideoCanvas.width = this.mWidth, this.mVideoCanvas.height = this.mHeight, this.mVideoImg.width = this.mWidth, this.mVideoImg.height = this.mHeight, this.mdefaultCanvas = document.createElement("canvas"), this.mdefaultCanvas.width = this.mWidth, this.mdefaultCanvas.height = this.mHeight, this.mdefaultCanvas.getContext("2d").width = this.mWidth, this.mdefaultCanvas.getContext("2d").height = this.mHeight, this.mdefaultCanvas.getContext("2d").fillStyle = "#FFFFFF", this.mdefaultCanvas.getContext("2d").fillRect(0, 0, this.mWidth, this.mHeight), this.gl = this.mRoot.getRenderFunction().gl, this.textureID = this.gl.createTexture(), this._uploadTextureData(this.gl, this.mdefaultCanvas)
}, VideoTexture.prototype.updateVideoTexture = function() {
    this.mVideo.readyState === this.mVideo.HAVE_ENOUGH_DATA ? (this.mVideoImg.drawImage(this.mVideo, 0, 0), this._uploadTextureData(this.gl, this.mVideoCanvas)) : this.gl.bindTexture(this.gl.TEXTURE_2D, this.textureID)
}, VideoTexture.prototype._uploadTextureData = function(a, b) {
    a.bindTexture(a.TEXTURE_2D, this.textureID), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !0), a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, b), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE)
}, VideoTexture.prototype.bind = function() {
    this.textureID && this.updateVideoTexture()
};
var CanvasTexture = function(a, b) {
    Texture.call(this, a), this.mVideoCanvas = document.createElement("canvas"), this.mVideoImg = null, this.mSourceCanvas = b, this.createVideoTexFromCanvas(this.mSourceCanvas)
};
extend(CanvasTexture, Texture), CanvasTexture.prototype.createVideoTexFromCanvas = function(a) {
        this.mWidth = a.width, this.mHeight = a.height, this.mVideoImg = this.mVideoCanvas.getContext("2d"), this.mVideoCanvas.width = this.mWidth, this.mVideoCanvas.height = this.mHeight, console.log("video texture width =" + this.mWidth + " video texture height =" + this.mHeight), this.gl = this.mRoot.getRenderFunction().gl, this.textureID = this.gl.createTexture()
    }, CanvasTexture.prototype._uploadTextureData = function(a, b) {
        a.bindTexture(a.TEXTURE_2D, this.textureID), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !0), a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, b), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE)
    }, CanvasTexture.prototype.bind = function() {
        this.mSourceCanvas ? (this.mVideoImg.drawImage(this.mSourceCanvas, 0, 0), this._uploadTextureData(this.gl, this.mVideoCanvas)) : this.gl.bindTexture(this.gl.TEXTURE_2D, this.textureID)
    },
    function(a) {
        "use strict";
        var b = function() {
                return a.requestAnimationFrame || a.webkitRequestAnimationFrame || a.mozRequestAnimationFrame || function(b) {
                    a.setTimeout(b, 1e3 / 60)
                }
            }(),
            c = a.jsmpeg = function(a, b) {
                b = b || {}, this.progressive = b.progressive !== !1, this.benchmark = !!b.benchmark, this.canvas = b.canvas || document.createElement("canvas"), this.autoplay = !!b.autoplay, this.wantsToPlay = this.autoplay, this.loop = !!b.loop, this.seekable = !!b.seekable, this.externalLoadCallback = b.onload || null, this.externalDecodeCallback = b.ondecodeframe || null, this.externalFinishedCallback = b.onfinished || null, this.customIntraQuantMatrix = new Uint8Array(64), this.customNonIntraQuantMatrix = new Uint8Array(64), this.blockData = new Int32Array(64), this.zeroBlockData = new Int32Array(64), this.fillArray(this.zeroBlockData, 0), !b.forceCanvas2D && this.initWebGL() ? this.renderFrame = this.renderFrameGL : (this.canvasContext = this.canvas.getContext("2d"), this.renderFrame = this.renderFrame2D), a instanceof WebSocket ? (this.client = a, this.client.onopen = this.initSocketClient.bind(this)) : this.load(a)
            };
        c.prototype.waitForIntraFrame = !0, c.prototype.socketBufferSize = 524288, c.prototype.initSocketClient = function() {
            this.buffer = new G(new ArrayBuffer(this.socketBufferSize)), this.nextPictureBuffer = new G(new ArrayBuffer(this.socketBufferSize)), this.nextPictureBuffer.writePos = 0, this.nextPictureBuffer.chunkBegin = 0, this.nextPictureBuffer.lastWriteBeforeWrap = 0, this.client.binaryType = "arraybuffer", this.client.onmessage = this.receiveSocketMessage.bind(this)
        }, c.prototype.decodeSocketHeader = function(a) {
            a[0] === d.charCodeAt(0) && a[1] === d.charCodeAt(1) && a[2] === d.charCodeAt(2) && a[3] === d.charCodeAt(3) && (this.width = 256 * a[4] + a[5], this.height = 256 * a[6] + a[7], this.initBuffers())
        }, c.prototype.receiveSocketMessage = function(a) {
            var c = new Uint8Array(a.data);
            this.sequenceStarted || this.decodeSocketHeader(c);
            var d = this.buffer,
                f = this.nextPictureBuffer;
            f.writePos + c.length > f.length && (f.lastWriteBeforeWrap = f.writePos, f.writePos = 0, f.index = 0), f.bytes.set(c, f.writePos), f.writePos += c.length;
            for (var g = 0;;) {
                if (g = f.findNextMPEGStartCode(), g === G.NOT_FOUND || f.index >> 3 > f.writePos) return void(f.index = Math.max(f.writePos - 3, 0) << 3);
                if (g === z) break
            }
            if (this.waitForIntraFrame) return f.advance(10), void(f.getBits(3) === t && (this.waitForIntraFrame = !1, f.chunkBegin = f.index - 13 >> 3));
            this.currentPictureDecoded || this.decodePicture(e);
            var h = f.index >> 3;
            if (h > f.chunkBegin) d.bytes.set(f.bytes.subarray(f.chunkBegin, h)), d.writePos = h - f.chunkBegin;
            else {
                d.bytes.set(f.bytes.subarray(f.chunkBegin, f.lastWriteBeforeWrap));
                var i = f.lastWriteBeforeWrap - f.chunkBegin;
                d.bytes.set(f.bytes.subarray(0, h), i), d.writePos = h + i
            }
            d.index = 0, f.chunkBegin = h, this.currentPictureDecoded = !1, b(this.scheduleDecoding.bind(this), this.canvas)
        }, c.prototype.scheduleDecoding = function() {
            this.decodePicture(), this.currentPictureDecoded = !0
        }, c.prototype.isRecording = !1, c.prototype.recorderWaitForIntraFrame = !1, c.prototype.recordedFrames = 0, c.prototype.recordedSize = 0, c.prototype.didStartRecordingCallback = null, c.prototype.recordBuffers = [], c.prototype.canRecord = function() {
            return this.client && this.client.readyState === this.client.OPEN
        }, c.prototype.startRecording = function(a) {
            if (this.canRecord()) {
                this.discardRecordBuffers(), this.isRecording = !0, this.recorderWaitForIntraFrame = !0, this.didStartRecordingCallback = a || null, this.recordedFrames = 0, this.recordedSize = 0;
                var b = this.width >> 4,
                    c = (15 & this.width) << 4 | this.height >> 8,
                    d = 255 & this.height;
                this.recordBuffers.push(new Uint8Array([0, 0, 1, 179, b, c, d, 19, 255, 255, 225, 88, 0, 0, 1, 184, 0, 8, 0, 0, 0, 0, 1, 0]))
            }
        }, c.prototype.recordFrameFromCurrentBuffer = function() {
            if (this.isRecording) {
                if (this.recorderWaitForIntraFrame) {
                    if (this.pictureCodingType !== t) return;
                    this.recorderWaitForIntraFrame = !1, this.didStartRecordingCallback && this.didStartRecordingCallback(this)
                }
                this.recordedFrames++, this.recordedSize += this.buffer.writePos, this.recordBuffers.push(new Uint8Array(this.buffer.bytes.subarray(0, this.buffer.writePos)))
            }
        }, c.prototype.discardRecordBuffers = function() {
            this.recordBuffers = [], this.recordedFrames = 0
        }, c.prototype.stopRecording = function() {
            var a = new Blob(this.recordBuffers, {
                type: "video/mpeg"
            });
            return this.discardRecordBuffers(), this.isRecording = !1, a
        }, c.prototype.intraFrames = [], c.prototype.currentFrame = -1, c.prototype.currentTime = 0, c.prototype.frameCount = 0, c.prototype.duration = 0, c.prototype.progressiveMinSize = 131072, c.prototype.fetchReaderPump = function(a) {
            var b = this;
            a.read().then(function(c) {
                b.fetchReaderReceive(a, c)
            })
        }, c.prototype.fetchReaderReceive = function(a, b) {
            if (b.done) {
                if (this.seekable) {
                    var c = this.buffer.index;
                    this.collectIntraFrames(), this.buffer.index = c
                }
                return this.duration = this.frameCount / this.pictureRate, void(this.lastFrameIndex = this.buffer.writePos << 3)
            }
            if (this.buffer.bytes.set(b.value, this.buffer.writePos), this.buffer.writePos += b.value.byteLength, this.lastFrameIndex = this.findLastPictureStartCode(), !this.sequenceStarted && this.buffer.writePos >= this.progressiveMinSize) this.findStartCode(w), this.firstSequenceHeader = this.buffer.index, this.decodeSequenceHeader(), this.nextFrame(), this.autoplay && this.play(), this.externalLoadCallback && this.externalLoadCallback(this);
            else if (this.sequenceStarted && this.wantsToPlay && !this.playing) this.play();
            else if (!this.sequenceStarted) {
                var d = {
                    loaded: this.buffer.writePos,
                    total: this.progressiveMinSize
                };
                this.gl ? this.updateLoaderGL(d) : this.updateLoader2D(d)
            }
            this.fetchReaderPump(a)
        }, c.prototype.findLastPictureStartCode = function() {
            for (var a = this.buffer.bytes, b = this.buffer.writePos; b > 3; b--)
                if (a[b] == z && 1 == a[b - 1] && 0 == a[b - 2] && 0 == a[b - 3]) return b - 3 << 3;
            return 0
        }, c.prototype.load = function(b) {
            this.url = b;
            var c = this;
            if (this.progressive && a.fetch && a.ReadableByteStream) {
                var d = new Headers;
                d.append("Content-Type", "video/mpeg"), fetch(b, {
                    headers: d
                }).then(function(a) {
                    var b = a.headers.get("Content-Length"),
                        d = a.body.getReader();
                    c.buffer = new G(new ArrayBuffer(b)), c.buffer.writePos = 0, c.fetchReaderPump(d)
                })
            } else {
                var e = new XMLHttpRequest;
                e.onreadystatechange = function() {
                    e.readyState === e.DONE && 200 === e.status && c.loadCallback(e.response)
                }, e.onprogress = this.gl ? this.updateLoaderGL.bind(this) : this.updateLoader2D.bind(this), e.open("GET", b), e.responseType = "arraybuffer", e.send()
            }
        }, c.prototype.updateLoader2D = function(a) {
            var b = a.loaded / a.total,
                c = this.canvas.width,
                d = this.canvas.height,
                e = this.canvasContext;
            e.fillStyle = "#222", e.fillRect(0, 0, c, d), e.fillStyle = "#fff", e.fillRect(0, d - d * b, c, d * b)
        }, c.prototype.updateLoaderGL = function(a) {
            var b = this.gl;
            b.uniform1f(b.getUniformLocation(this.loadingProgram, "loaded"), a.loaded / a.total), b.drawArrays(b.TRIANGLE_STRIP, 0, 4)
        }, c.prototype.loadCallback = function(a) {
            this.buffer = new G(a), this.seekable && (this.collectIntraFrames(), this.buffer.index = 0), this.findStartCode(w), this.firstSequenceHeader = this.buffer.index, this.decodeSequenceHeader(), this.duration = this.frameCount / this.pictureRate, this.nextFrame(), this.autoplay && this.play(), this.externalLoadCallback && this.externalLoadCallback(this)
        }, c.prototype.collectIntraFrames = function() {
            var a;
            for (a = 0; this.findStartCode(z) !== G.NOT_FOUND; a++) this.buffer.advance(10), this.buffer.getBits(3) === t && this.intraFrames.push({
                frame: a,
                index: this.buffer.index - 13
            });
            this.frameCount = a
        }, c.prototype.seekToFrame = function(a, b) {
            if (0 > a || a >= this.frameCount || !this.intraFrames.length) return !1;
            for (var c = null, d = 0; d < this.intraFrames.length && this.intraFrames[d].frame <= a; d++) c = this.intraFrames[d];
            if (this.buffer.index = c.index, this.currentFrame = c.frame - 1, b) {
                for (var f = c.frame; a > f; f++) this.decodePicture(e), this.findStartCode(z);
                this.currentFrame = a - 1
            }
            return this.decodePicture(), !0
        }, c.prototype.seekToTime = function(a, b) {
            this.seekToFrame(a * this.pictureRate | 0, b)
        }, c.prototype.play = function() {
            this.playing || (this.targetTime = this.now(), this.playing = !0, this.wantsToPlay = !0, this.scheduleNextFrame())
        }, c.prototype.pause = function() {
            this.playing = !1, this.wantsToPlay = !1
        }, c.prototype.stop = function() {
            this.currentFrame = -1, this.buffer && (this.buffer.index = this.firstSequenceHeader), this.playing = !1, this.client && (this.client.close(), this.client = null), this.wantsToPlay = !1
        }, c.prototype.readCode = function(a) {
            var b = 0;
            do b = a[b + this.buffer.getBits(1)]; while (b >= 0 && 0 !== a[b]);
            return a[b + 2]
        }, c.prototype.findStartCode = function(a) {
            for (var b = 0;;)
                if (b = this.buffer.findNextMPEGStartCode(), b === a || b === G.NOT_FOUND) return b;
            return G.NOT_FOUND
        }, c.prototype.fillArray = function(a, b) {
            for (var c = 0, d = a.length; d > c; c++) a[c] = b
        }, c.prototype.pictureRate = 30, c.prototype.lateTime = 0, c.prototype.firstSequenceHeader = 0, c.prototype.targetTime = 0, c.prototype.benchmark = !1, c.prototype.benchFrame = 0, c.prototype.benchDecodeTimes = 0, c.prototype.benchAvgFrameTime = 0, c.prototype.now = function() {
            return a.performance ? a.performance.now() : Date.now()
        }, c.prototype.nextFrame = function() {
            if (this.buffer)
                for (var a = this.now();;) {
                    var b = this.buffer.findNextMPEGStartCode();
                    if (b === w) this.decodeSequenceHeader();
                    else {
                        if (b === z) return this.progressive && this.buffer.index >= this.lastFrameIndex ? void(this.playing = !1) : (this.playing && this.scheduleNextFrame(), this.decodePicture(), this.benchDecodeTimes += this.now() - a, this.canvas);
                        if (b === G.NOT_FOUND) return this.stop(), this.externalFinishedCallback && this.externalFinishedCallback(this), this.loop && this.sequenceStarted && this.play(), null
                    }
                }
        }, c.prototype.scheduleNextFrame = function() {
            this.lateTime = this.now() - this.targetTime;
            var b = Math.max(0, 1e3 / this.pictureRate - this.lateTime);
            this.targetTime = this.now() + b, this.benchmark ? (this.benchFrame++, this.benchFrame >= 120 && (this.benchAvgFrameTime = this.benchDecodeTimes / this.benchFrame, this.benchFrame = 0, this.benchDecodeTimes = 0, a.console && console.log("Average time per frame:", this.benchAvgFrameTime, "ms")), setTimeout(this.nextFrame.bind(this), 0)) : 18 > b ? this.scheduleAnimation() : setTimeout(this.scheduleAnimation.bind(this), b)
        }, c.prototype.scheduleAnimation = function() {
            b(this.nextFrame.bind(this), this.canvas)
        }, c.prototype.decodeSequenceHeader = function() {
            this.width = this.buffer.getBits(12), this.height = this.buffer.getBits(12), this.buffer.advance(4), this.pictureRate = f[this.buffer.getBits(4)], this.buffer.advance(30), this.initBuffers();
            var a;
            if (this.buffer.getBits(1)) {
                for (a = 0; 64 > a; a++) this.customIntraQuantMatrix[g[a]] = this.buffer.getBits(8);
                this.intraQuantMatrix = this.customIntraQuantMatrix
            }
            if (this.buffer.getBits(1)) {
                for (a = 0; 64 > a; a++) this.customNonIntraQuantMatrix[g[a]] = this.buffer.getBits(8);
                this.nonIntraQuantMatrix = this.customNonIntraQuantMatrix
            }
        }, c.prototype.initBuffers = function() {
            if (this.intraQuantMatrix = h, this.nonIntraQuantMatrix = i, this.mbWidth = this.width + 15 >> 4, this.mbHeight = this.height + 15 >> 4, this.mbSize = this.mbWidth * this.mbHeight, this.codedWidth = this.mbWidth << 4, this.codedHeight = this.mbHeight << 4, this.codedSize = this.codedWidth * this.codedHeight, this.halfWidth = this.mbWidth << 3, this.halfHeight = this.mbHeight << 3, this.quarterSize = this.codedSize >> 2, !this.sequenceStarted) {
                this.sequenceStarted = !0;
                var b = a.Uint8ClampedArray || a.Uint8Array;
                a.Uint8ClampedArray || (this.copyBlockToDestination = this.copyBlockToDestinationClamp, this.addBlockToDestination = this.addBlockToDestinationClamp), this.currentY = new b(this.codedSize), this.currentY32 = new Uint32Array(this.currentY.buffer), this.currentCr = new b(this.codedSize >> 2), this.currentCr32 = new Uint32Array(this.currentCr.buffer), this.currentCb = new b(this.codedSize >> 2), this.currentCb32 = new Uint32Array(this.currentCb.buffer), this.forwardY = new b(this.codedSize), this.forwardY32 = new Uint32Array(this.forwardY.buffer), this.forwardCr = new b(this.codedSize >> 2), this.forwardCr32 = new Uint32Array(this.forwardCr.buffer), this.forwardCb = new b(this.codedSize >> 2), this.forwardCb32 = new Uint32Array(this.forwardCb.buffer), this.canvas.width = this.width, this.canvas.height = this.height, this.gl ? (this.gl.useProgram(this.program), this.gl.viewport(0, 0, this.width, this.height)) : (this.currentRGBA = this.canvasContext.getImageData(0, 0, this.width, this.height), this.fillArray(this.currentRGBA.data, 255))
            }
        }, c.prototype.currentY = null, c.prototype.currentCr = null, c.prototype.currentCb = null, c.prototype.currentRGBA = null, c.prototype.pictureCodingType = 0, c.prototype.forwardY = null, c.prototype.forwardCr = null, c.prototype.forwardCb = null, c.prototype.fullPelForward = !1, c.prototype.forwardFCode = 0, c.prototype.forwardRSize = 0, c.prototype.forwardF = 0, c.prototype.decodePicture = function(a) {
            if (this.currentFrame++, this.currentTime = this.currentFrame / this.pictureRate, this.buffer.advance(10), this.pictureCodingType = this.buffer.getBits(3), this.buffer.advance(16), !(this.pictureCodingType <= 0 || this.pictureCodingType >= v)) {
                if (this.pictureCodingType === u) {
                    if (this.fullPelForward = this.buffer.getBits(1), this.forwardFCode = this.buffer.getBits(3), 0 === this.forwardFCode) return;
                    this.forwardRSize = this.forwardFCode - 1, this.forwardF = 1 << this.forwardRSize
                }
                var b = 0;
                do b = this.buffer.findNextMPEGStartCode(); while (b === A || b === B);
                for (; b >= x && y >= b;) this.decodeSlice(255 & b), b = this.buffer.findNextMPEGStartCode();
                if (this.buffer.rewind(32), this.recordFrameFromCurrentBuffer(), a !== e && (this.renderFrame(), this.externalDecodeCallback && this.externalDecodeCallback(this, this.canvas)), this.pictureCodingType === t || this.pictureCodingType === u) {
                    var c = this.forwardY,
                        d = this.forwardY32,
                        f = this.forwardCr,
                        g = this.forwardCr32,
                        h = this.forwardCb,
                        i = this.forwardCb32;
                    this.forwardY = this.currentY, this.forwardY32 = this.currentY32, this.forwardCr = this.currentCr, this.forwardCr32 = this.currentCr32, this.forwardCb = this.currentCb, this.forwardCb32 = this.currentCb32, this.currentY = c, this.currentY32 = d, this.currentCr = f, this.currentCr32 = g, this.currentCb = h, this.currentCb32 = i
                }
            }
        }, c.prototype.YCbCrToRGBA = function() {
            for (var a, b, c, d, e, f = this.currentY, g = this.currentCb, h = this.currentCr, i = this.currentRGBA.data, j = 0, k = this.codedWidth, l = this.codedWidth + (this.codedWidth - this.width), m = 0, n = this.halfWidth - (this.width >> 1), o = 0, p = 4 * this.width, q = 4 * this.width, r = this.width >> 1, s = this.height >> 1, t = 0; s > t; t++) {
                for (var u = 0; r > u; u++) {
                    a = g[m], b = h[m], m++, c = b + (103 * b >> 8) - 179, d = (88 * a >> 8) - 44 + (183 * b >> 8) - 91, e = a + (198 * a >> 8) - 227;
                    var v = f[j++],
                        w = f[j++];
                    i[o] = v + c, i[o + 1] = v - d, i[o + 2] = v + e, i[o + 4] = w + c, i[o + 5] = w - d, i[o + 6] = w + e, o += 8;
                    var x = f[k++],
                        y = f[k++];
                    i[p] = x + c, i[p + 1] = x - d, i[p + 2] = x + e, i[p + 4] = y + c, i[p + 5] = y - d, i[p + 6] = y + e, p += 8
                }
                j += l, k += l, o += q, p += q, m += n
            }
        }, c.prototype.renderFrame2D = function() {
            this.YCbCrToRGBA(), this.canvasContext.putImageData(this.currentRGBA, 0, 0)
        }, c.prototype.gl = null, c.prototype.program = null, c.prototype.YTexture = null, c.prototype.CBTexture = null, c.prototype.CRTexture = null, c.prototype.createTexture = function(a, b) {
            var c = this.gl,
                d = c.createTexture();
            return c.bindTexture(c.TEXTURE_2D, d), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.uniform1i(c.getUniformLocation(this.program, b), a), d
        }, c.prototype.compileShader = function(a, b) {
            var c = this.gl,
                d = c.createShader(a);
            if (c.shaderSource(d, b), c.compileShader(d), !c.getShaderParameter(d, c.COMPILE_STATUS)) throw new Error(c.getShaderInfoLog(d));
            return d
        }, c.prototype.initWebGL = function() {
            var a;
            try {
                a = this.gl = this.canvas.getContext("webgl") || this.canvas.getContext("experimental-webgl")
            } catch (b) {
                return !1
            }
            if (!a) return !1;
            if (this.buffer = a.createBuffer(), a.bindBuffer(a.ARRAY_BUFFER, this.buffer), a.bufferData(a.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), a.STATIC_DRAW), this.program = a.createProgram(), a.attachShader(this.program, this.compileShader(a.VERTEX_SHADER, E)), a.attachShader(this.program, this.compileShader(a.FRAGMENT_SHADER, C)), a.linkProgram(this.program), !a.getProgramParameter(this.program, a.LINK_STATUS)) throw new Error(a.getProgramInfoLog(this.program));
            a.useProgram(this.program), this.YTexture = this.createTexture(0, "YTexture"), this.CBTexture = this.createTexture(1, "CBTexture"), this.CRTexture = this.createTexture(2, "CRTexture");
            var c = a.getAttribLocation(this.program, "vertex");
            return a.enableVertexAttribArray(c), a.vertexAttribPointer(c, 2, a.FLOAT, !1, 0, 0), this.loadingProgram = a.createProgram(), a.attachShader(this.loadingProgram, this.compileShader(a.VERTEX_SHADER, E)), a.attachShader(this.loadingProgram, this.compileShader(a.FRAGMENT_SHADER, D)), a.linkProgram(this.loadingProgram), a.useProgram(this.loadingProgram), c = a.getAttribLocation(this.loadingProgram, "vertex"), a.enableVertexAttribArray(c), a.vertexAttribPointer(c, 2, a.FLOAT, !1, 0, 0), !0
        }, c.prototype.renderFrameGL = function() {
            var a = this.gl,
                b = new Uint8Array(this.currentY.buffer),
                c = new Uint8Array(this.currentCr.buffer),
                d = new Uint8Array(this.currentCb.buffer);
            a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, this.YTexture), a.texImage2D(a.TEXTURE_2D, 0, a.LUMINANCE, this.codedWidth, this.height, 0, a.LUMINANCE, a.UNSIGNED_BYTE, b), a.activeTexture(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this.CBTexture), a.texImage2D(a.TEXTURE_2D, 0, a.LUMINANCE, this.halfWidth, this.height / 2, 0, a.LUMINANCE, a.UNSIGNED_BYTE, c), a.activeTexture(a.TEXTURE2), a.bindTexture(a.TEXTURE_2D, this.CRTexture), a.texImage2D(a.TEXTURE_2D, 0, a.LUMINANCE, this.halfWidth, this.height / 2, 0, a.LUMINANCE, a.UNSIGNED_BYTE, d), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)
        }, c.prototype.quantizerScale = 0, c.prototype.sliceBegin = !1, c.prototype.decodeSlice = function(a) {
            for (this.sliceBegin = !0, this.macroblockAddress = (a - 1) * this.mbWidth - 1, this.motionFwH = this.motionFwHPrev = 0, this.motionFwV = this.motionFwVPrev = 0, this.dcPredictorY = 128, this.dcPredictorCr = 128, this.dcPredictorCb = 128, this.quantizerScale = this.buffer.getBits(5); this.buffer.getBits(1);) this.buffer.advance(8);
            do this.decodeMacroblock(); while (!this.buffer.nextBytesAreStartCode())
        }, c.prototype.macroblockAddress = 0, c.prototype.mbRow = 0, c.prototype.mbCol = 0, c.prototype.macroblockType = 0, c.prototype.macroblockIntra = !1, c.prototype.macroblockMotFw = !1, c.prototype.motionFwH = 0, c.prototype.motionFwV = 0, c.prototype.motionFwHPrev = 0, c.prototype.motionFwVPrev = 0, c.prototype.decodeMacroblock = function() {
            for (var a = 0, b = this.readCode(k); 34 === b;) b = this.readCode(k);
            for (; 35 === b;) a += 33, b = this.readCode(k);
            if (a += b, this.sliceBegin) this.sliceBegin = !1, this.macroblockAddress += a;
            else {
                if (this.macroblockAddress + a >= this.mbSize) return;
                for (a > 1 && (this.dcPredictorY = 128, this.dcPredictorCr = 128, this.dcPredictorCb = 128, this.pictureCodingType === u && (this.motionFwH = this.motionFwHPrev = 0, this.motionFwV = this.motionFwVPrev = 0)); a > 1;) this.macroblockAddress++, this.mbRow = this.macroblockAddress / this.mbWidth | 0, this.mbCol = this.macroblockAddress % this.mbWidth, this.copyMacroblock(this.motionFwH, this.motionFwV, this.forwardY, this.forwardCr, this.forwardCb), a--;
                this.macroblockAddress++
            }
            this.mbRow = this.macroblockAddress / this.mbWidth | 0, this.mbCol = this.macroblockAddress % this.mbWidth, this.macroblockType = this.readCode(F[this.pictureCodingType]), this.macroblockIntra = 1 & this.macroblockType, this.macroblockMotFw = 8 & this.macroblockType, 0 !== (16 & this.macroblockType) && (this.quantizerScale = this.buffer.getBits(5)), this.macroblockIntra ? (this.motionFwH = this.motionFwHPrev = 0, this.motionFwV = this.motionFwVPrev = 0) : (this.dcPredictorY = 128, this.dcPredictorCr = 128, this.dcPredictorCb = 128, this.decodeMotionVectors(), this.copyMacroblock(this.motionFwH, this.motionFwV, this.forwardY, this.forwardCr, this.forwardCb));
            for (var c = 0 !== (2 & this.macroblockType) ? this.readCode(o) : this.macroblockIntra ? 63 : 0, d = 0, e = 32; 6 > d; d++) 0 !== (c & e) && this.decodeBlock(d), e >>= 1
        }, c.prototype.decodeMotionVectors = function() {
            var a, b, c = 0;
            this.macroblockMotFw ? (a = this.readCode(p), 0 !== a && 1 !== this.forwardF ? (c = this.buffer.getBits(this.forwardRSize), b = (Math.abs(a) - 1 << this.forwardRSize) + c + 1, 0 > a && (b = -b)) : b = a, this.motionFwHPrev += b, this.motionFwHPrev > (this.forwardF << 4) - 1 ? this.motionFwHPrev -= this.forwardF << 5 : this.motionFwHPrev < -this.forwardF << 4 && (this.motionFwHPrev += this.forwardF << 5), this.motionFwH = this.motionFwHPrev, this.fullPelForward && (this.motionFwH <<= 1), a = this.readCode(p), 0 !== a && 1 !== this.forwardF ? (c = this.buffer.getBits(this.forwardRSize), b = (Math.abs(a) - 1 << this.forwardRSize) + c + 1, 0 > a && (b = -b)) : b = a, this.motionFwVPrev += b, this.motionFwVPrev > (this.forwardF << 4) - 1 ? this.motionFwVPrev -= this.forwardF << 5 : this.motionFwVPrev < -this.forwardF << 4 && (this.motionFwVPrev += this.forwardF << 5), this.motionFwV = this.motionFwVPrev, this.fullPelForward && (this.motionFwV <<= 1)) : this.pictureCodingType === u && (this.motionFwH = this.motionFwHPrev = 0, this.motionFwV = this.motionFwVPrev = 0)
        }, c.prototype.copyMacroblock = function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, n, o = this.currentY32,
                p = this.currentCb32,
                q = this.currentCr32;
            f = this.codedWidth, g = f - 16, h = a >> 1, i = b >> 1, j = 1 === (1 & a), k = 1 === (1 & b), l = ((this.mbRow << 4) + i) * f + (this.mbCol << 4) + h, m = this.mbRow * f + this.mbCol << 2, n = m + (f << 2);
            var r, s, t, u;
            if (j)
                if (k)
                    for (; n > m;) {
                        for (s = c[l] + c[l + f], l++, r = 0; 4 > r; r++) t = c[l] + c[l + f], l++, u = s + t + 2 >> 2 & 255, s = c[l] + c[l + f], l++, u |= s + t + 2 << 6 & 65280, t = c[l] + c[l + f], l++, u |= s + t + 2 << 14 & 16711680, s = c[l] + c[l + f], l++, u |= s + t + 2 << 22 & 4278190080, o[m++] = u;
                        m += g >> 2, l += g - 1
                    } else
                        for (; n > m;) {
                            for (s = c[l++], r = 0; 4 > r; r++) t = c[l++], u = s + t + 1 >> 1 & 255, s = c[l++], u |= s + t + 1 << 7 & 65280, t = c[l++], u |= s + t + 1 << 15 & 16711680, s = c[l++], u |= s + t + 1 << 23 & 4278190080, o[m++] = u;
                            m += g >> 2, l += g - 1
                        } else if (k)
                            for (; n > m;) {
                                for (r = 0; 4 > r; r++) u = c[l] + c[l + f] + 1 >> 1 & 255, l++, u |= c[l] + c[l + f] + 1 << 7 & 65280, l++, u |= c[l] + c[l + f] + 1 << 15 & 16711680, l++, u |= c[l] + c[l + f] + 1 << 23 & 4278190080, l++, o[m++] = u;
                                m += g >> 2, l += g
                            } else
                                for (; n > m;) {
                                    for (r = 0; 4 > r; r++) u = c[l], l++, u |= c[l] << 8, l++, u |= c[l] << 16, l++, u |= c[l] << 24, l++, o[m++] = u;
                                    m += g >> 2, l += g
                                }
                        f = this.halfWidth, g = f - 8, h = a / 2 >> 1, i = b / 2 >> 1, j = 1 === (a / 2 & 1), k = 1 === (b / 2 & 1), l = ((this.mbRow << 3) + i) * f + (this.mbCol << 3) + h, m = this.mbRow * f + this.mbCol << 1, n = m + (f << 1);
            var v, w, x, y, z, A;
            if (j)
                if (k)
                    for (; n > m;) {
                        for (v = d[l] + d[l + f], y = e[l] + e[l + f], l++, r = 0; 2 > r; r++) w = d[l] + d[l + f], z = e[l] + e[l + f], l++, x = v + w + 2 >> 2 & 255, A = y + z + 2 >> 2 & 255, v = d[l] + d[l + f], y = e[l] + e[l + f], l++, x |= v + w + 2 << 6 & 65280, A |= y + z + 2 << 6 & 65280, w = d[l] + d[l + f], z = e[l] + e[l + f], l++, x |= v + w + 2 << 14 & 16711680, A |= y + z + 2 << 14 & 16711680, v = d[l] + d[l + f], y = e[l] + e[l + f], l++, x |= v + w + 2 << 22 & 4278190080, A |= y + z + 2 << 22 & 4278190080, q[m] = x, p[m] = A, m++;
                        m += g >> 2, l += g - 1
                    } else
                        for (; n > m;) {
                            for (v = d[l], y = e[l], l++, r = 0; 2 > r; r++) w = d[l], z = e[l++], x = v + w + 1 >> 1 & 255, A = y + z + 1 >> 1 & 255, v = d[l], y = e[l++], x |= v + w + 1 << 7 & 65280, A |= y + z + 1 << 7 & 65280, w = d[l], z = e[l++], x |= v + w + 1 << 15 & 16711680, A |= y + z + 1 << 15 & 16711680, v = d[l], y = e[l++], x |= v + w + 1 << 23 & 4278190080, A |= y + z + 1 << 23 & 4278190080, q[m] = x, p[m] = A, m++;
                            m += g >> 2, l += g - 1
                        } else if (k)
                            for (; n > m;) {
                                for (r = 0; 2 > r; r++) x = d[l] + d[l + f] + 1 >> 1 & 255, A = e[l] + e[l + f] + 1 >> 1 & 255, l++, x |= d[l] + d[l + f] + 1 << 7 & 65280, A |= e[l] + e[l + f] + 1 << 7 & 65280, l++, x |= d[l] + d[l + f] + 1 << 15 & 16711680, A |= e[l] + e[l + f] + 1 << 15 & 16711680, l++, x |= d[l] + d[l + f] + 1 << 23 & 4278190080, A |= e[l] + e[l + f] + 1 << 23 & 4278190080, l++, q[m] = x, p[m] = A, m++;
                                m += g >> 2, l += g
                            } else
                                for (; n > m;) {
                                    for (r = 0; 2 > r; r++) x = d[l], A = e[l], l++, x |= d[l] << 8, A |= e[l] << 8, l++, x |= d[l] << 16, A |= e[l] << 16, l++, x |= d[l] << 24, A |= e[l] << 24, l++, q[m] = x, p[m] = A, m++;
                                    m += g >> 2, l += g
                                }
        }, c.prototype.blockData = null, c.prototype.decodeBlock = function(a) {
            var b, c = 0;
            if (this.macroblockIntra) {
                var d, e;
                if (4 > a ? (d = this.dcPredictorY, e = this.readCode(q)) : (d = 4 === a ? this.dcPredictorCr : this.dcPredictorCb, e = this.readCode(r)), e > 0) {
                    var f = this.buffer.getBits(e);
                    0 !== (f & 1 << e - 1) ? this.blockData[0] = d + f : this.blockData[0] = d + (-1 << e | f + 1)
                } else this.blockData[0] = d;
                4 > a ? this.dcPredictorY = this.blockData[0] : 4 === a ? this.dcPredictorCr = this.blockData[0] : this.dcPredictorCb = this.blockData[0], this.blockData[0] <<= 8, b = this.intraQuantMatrix, c = 1
            } else b = this.nonIntraQuantMatrix;
            for (var h = 0;;) {
                var i = 0,
                    k = this.readCode(s);
                if (1 === k && c > 0 && 0 === this.buffer.getBits(1)) break;
                65535 === k ? (i = this.buffer.getBits(6), h = this.buffer.getBits(8), 0 === h ? h = this.buffer.getBits(8) : 128 === h ? h = this.buffer.getBits(8) - 256 : h > 128 && (h -= 256)) : (i = k >> 8, h = 255 & k, this.buffer.getBits(1) && (h = -h)), c += i;
                var l = g[c];
                c++, h <<= 1, this.macroblockIntra || (h += 0 > h ? -1 : 1), h = h * this.quantizerScale * b[l] >> 4, 0 === (1 & h) && (h -= h > 0 ? 1 : -1), h > 2047 ? h = 2047 : -2048 > h && (h = -2048), this.blockData[l] = h * j[l]
            }
            var m, n, o;
            4 > a ? (m = this.currentY, o = this.codedWidth - 8, n = this.mbRow * this.codedWidth + this.mbCol << 4, 0 !== (1 & a) && (n += 8), 0 !== (2 & a) && (n += this.codedWidth << 3)) : (m = 4 === a ? this.currentCb : this.currentCr, o = (this.codedWidth >> 1) - 8, n = (this.mbRow * this.codedWidth << 2) + (this.mbCol << 3)), this.macroblockIntra ? 1 === c ? (this.copyValueToDestination(this.blockData[0] + 128 >> 8, m, n, o), this.blockData[0] = 0) : (this.IDCT(), this.copyBlockToDestination(this.blockData, m, n, o), this.blockData.set(this.zeroBlockData)) : 1 === c ? (this.addValueToDestination(this.blockData[0] + 128 >> 8, m, n, o), this.blockData[0] = 0) : (this.IDCT(), this.addBlockToDestination(this.blockData, m, n, o), this.blockData.set(this.zeroBlockData)), c = 0
        }, c.prototype.copyBlockToDestination = function(a, b, c, d) {
            for (var e = 0; 64 > e; e += 8, c += d + 8) b[c + 0] = a[e + 0], b[c + 1] = a[e + 1], b[c + 2] = a[e + 2], b[c + 3] = a[e + 3], b[c + 4] = a[e + 4], b[c + 5] = a[e + 5], b[c + 6] = a[e + 6], b[c + 7] = a[e + 7]
        }, c.prototype.addBlockToDestination = function(a, b, c, d) {
            for (var e = 0; 64 > e; e += 8, c += d + 8) b[c + 0] += a[e + 0], b[c + 1] += a[e + 1], b[c + 2] += a[e + 2], b[c + 3] += a[e + 3], b[c + 4] += a[e + 4], b[c + 5] += a[e + 5], b[c + 6] += a[e + 6], b[c + 7] += a[e + 7]
        }, c.prototype.copyValueToDestination = function(a, b, c, d) {
            for (var e = 0; 64 > e; e += 8, c += d + 8) b[c + 0] = a, b[c + 1] = a, b[c + 2] = a, b[c + 3] = a, b[c + 4] = a, b[c + 5] = a, b[c + 6] = a, b[c + 7] = a
        }, c.prototype.addValueToDestination = function(a, b, c, d) {
            for (var e = 0; 64 > e; e += 8, c += d + 8) b[c + 0] += a, b[c + 1] += a, b[c + 2] += a, b[c + 3] += a, b[c + 4] += a, b[c + 5] += a, b[c + 6] += a, b[c + 7] += a
        }, c.prototype.copyBlockToDestinationClamp = function(a, b, c, d) {
            for (var e = 0, f = 0; 8 > f; f++) {
                for (var g = 0; 8 > g; g++) {
                    var h = a[e++];
                    b[c++] = h > 255 ? 255 : 0 > h ? 0 : h
                }
                c += d
            }
        }, c.prototype.addBlockToDestinationClamp = function(a, b, c, d) {
            for (var e = 0, f = 0; 8 > f; f++) {
                for (var g = 0; 8 > g; g++) {
                    var h = a[e++] + b[c];
                    b[c++] = h > 255 ? 255 : 0 > h ? 0 : h
                }
                c += d
            }
        }, c.prototype.IDCT = function() {
            var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t = this.blockData;
            for (s = 0; 8 > s; ++s) a = t[32 + s], b = t[16 + s] + t[48 + s], c = t[40 + s] - t[24 + s], f = t[8 + s] + t[56 + s], g = t[24 + s] + t[40 + s], d = t[8 + s] - t[56 + s], e = f + g, h = t[0 + s], m = (473 * d - 196 * c + 128 >> 8) - e, i = m - (362 * (f - g) + 128 >> 8), j = h - a, k = (362 * (t[16 + s] - t[48 + s]) + 128 >> 8) - b, l = h + a, n = j + k, o = l + b, p = j - k, q = l - b, r = -i - (473 * c + 196 * d + 128 >> 8), t[0 + s] = e + o, t[8 + s] = m + n, t[16 + s] = p - i, t[24 + s] = q - r, t[32 + s] = q + r, t[40 + s] = i + p, t[48 + s] = n - m, t[56 + s] = o - e;
            for (s = 0; 64 > s; s += 8) a = t[4 + s], b = t[2 + s] + t[6 + s], c = t[5 + s] - t[3 + s], f = t[1 + s] + t[7 + s], g = t[3 + s] + t[5 + s], d = t[1 + s] - t[7 + s], e = f + g, h = t[0 + s], m = (473 * d - 196 * c + 128 >> 8) - e, i = m - (362 * (f - g) + 128 >> 8), j = h - a, k = (362 * (t[2 + s] - t[6 + s]) + 128 >> 8) - b, l = h + a, n = j + k, o = l + b, p = j - k, q = l - b, r = -i - (473 * c + 196 * d + 128 >> 8), t[0 + s] = e + o + 128 >> 8, t[1 + s] = m + n + 128 >> 8, t[2 + s] = p - i + 128 >> 8, t[3 + s] = q - r + 128 >> 8, t[4 + s] = q + r + 128 >> 8, t[5 + s] = i + p + 128 >> 8, t[6 + s] = n - m + 128 >> 8, t[7 + s] = o - e + 128 >> 8
        };
        var d = "jsmp",
            e = 1,
            f = [0, 23.976, 24, 25, 29.97, 30, 50, 59.94, 60, 0, 0, 0, 0, 0, 0, 0],
            g = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]),
            h = new Uint8Array([8, 16, 19, 22, 26, 27, 29, 34, 16, 16, 22, 24, 27, 29, 34, 37, 19, 22, 26, 27, 29, 34, 34, 38, 22, 22, 26, 27, 29, 34, 37, 40, 22, 26, 27, 29, 32, 35, 40, 48, 26, 27, 29, 32, 35, 40, 48, 58, 26, 27, 29, 34, 38, 46, 56, 69, 27, 29, 35, 38, 46, 56, 69, 83]),
            i = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]),
            j = new Uint8Array([32, 44, 42, 38, 32, 25, 17, 9, 44, 62, 58, 52, 44, 35, 24, 12, 42, 58, 55, 49, 42, 33, 23, 12, 38, 52, 49, 44, 38, 30, 20, 10, 32, 44, 42, 38, 32, 25, 17, 9, 25, 35, 33, 30, 25, 20, 14, 7, 17, 24, 23, 20, 17, 14, 9, 5, 9, 12, 12, 10, 9, 7, 5, 2]),
            k = new Int16Array([3, 6, 0, 9, 12, 0, 0, 0, 1, 15, 18, 0, 21, 24, 0, 27, 30, 0, 33, 36, 0, 0, 0, 3, 0, 0, 2, 39, 42, 0, 45, 48, 0, 0, 0, 5, 0, 0, 4, 51, 54, 0, 57, 60, 0, 0, 0, 7, 0, 0, 6, 63, 66, 0, 69, 72, 0, 75, 78, 0, 81, 84, 0, -1, 87, 0, -1, 90, 0, 93, 96, 0, 99, 102, 0, 105, 108, 0, 111, 114, 0, 0, 0, 9, 0, 0, 8, 117, 120, 0, 123, 126, 0, 129, 132, 0, 135, 138, 0, 0, 0, 15, 0, 0, 14, 0, 0, 13, 0, 0, 12, 0, 0, 11, 0, 0, 10, 141, -1, 0, -1, 144, 0, 147, 150, 0, 153, 156, 0, 159, 162, 0, 165, 168, 0, 171, 174, 0, 177, 180, 0, 183, -1, 0, -1, 186, 0, 189, 192, 0, 195, 198, 0, 201, 204, 0, 207, 210, 0, 213, 216, 0, 219, 222, 0, 0, 0, 21, 0, 0, 20, 0, 0, 19, 0, 0, 18, 0, 0, 17, 0, 0, 16, 0, 0, 35, 0, 0, 34, 0, 0, 33, 0, 0, 32, 0, 0, 31, 0, 0, 30, 0, 0, 29, 0, 0, 28, 0, 0, 27, 0, 0, 26, 0, 0, 25, 0, 0, 24, 0, 0, 23, 0, 0, 22]),
            l = new Int8Array([3, 6, 0, -1, 9, 0, 0, 0, 1, 0, 0, 17]),
            m = new Int8Array([3, 6, 0, 9, 12, 0, 0, 0, 10, 15, 18, 0, 0, 0, 2, 21, 24, 0, 0, 0, 8, 27, 30, 0, 33, 36, 0, -1, 39, 0, 0, 0, 18, 0, 0, 26, 0, 0, 1, 0, 0, 17]),
            n = new Int8Array([3, 6, 0, 9, 15, 0, 12, 18, 0, 24, 21, 0, 0, 0, 12, 27, 30, 0, 0, 0, 14, 39, 42, 0, 36, 33, 0, 0, 0, 4, 0, 0, 6, 54, 48, 0, 45, 51, 0, 0, 0, 8, 0, 0, 10, -1, 57, 0, 0, 0, 1, 60, 63, 0, 0, 0, 30, 0, 0, 17, 0, 0, 22, 0, 0, 26]),
            o = new Int16Array([6, 3, 0, 9, 18, 0, 12, 15, 0, 24, 33, 0, 36, 39, 0, 27, 21, 0, 30, 42, 0, 60, 57, 0, 54, 48, 0, 69, 51, 0, 81, 75, 0, 63, 84, 0, 45, 66, 0, 72, 78, 0, 0, 0, 60, 105, 120, 0, 132, 144, 0, 114, 108, 0, 126, 141, 0, 87, 93, 0, 117, 96, 0, 0, 0, 32, 135, 138, 0, 99, 123, 0, 129, 102, 0, 0, 0, 4, 90, 111, 0, 0, 0, 8, 0, 0, 16, 0, 0, 44, 150, 168, 0, 0, 0, 28, 0, 0, 52, 0, 0, 62, 183, 177, 0, 156, 180, 0, 0, 0, 1, 165, 162, 0, 0, 0, 61, 0, 0, 56, 171, 174, 0, 0, 0, 2, 0, 0, 40, 153, 186, 0, 0, 0, 48, 192, 189, 0, 147, 159, 0, 0, 0, 20, 0, 0, 12, 240, 249, 0, 0, 0, 63, 231, 225, 0, 195, 219, 0, 252, 198, 0, 0, 0, 24, 0, 0, 36, 0, 0, 3, 207, 261, 0, 243, 237, 0, 204, 213, 0, 210, 234, 0, 201, 228, 0, 216, 222, 0, 258, 255, 0, 264, 246, 0, -1, 282, 0, 285, 291, 0, 0, 0, 33, 0, 0, 9, 318, 330, 0, 306, 348, 0, 0, 0, 5, 0, 0, 10, 279, 267, 0, 0, 0, 6, 0, 0, 18, 0, 0, 17, 0, 0, 34, 339, 357, 0, 309, 312, 0, 270, 276, 0, 327, 321, 0, 351, 354, 0, 303, 297, 0, 294, 288, 0, 300, 273, 0, 342, 345, 0, 315, 324, 0, 336, 333, 0, 363, 375, 0, 0, 0, 41, 0, 0, 14, 0, 0, 21, 372, 366, 0, 360, 369, 0, 0, 0, 11, 0, 0, 19, 0, 0, 7, 0, 0, 35, 0, 0, 13, 0, 0, 50, 0, 0, 49, 0, 0, 58, 0, 0, 37, 0, 0, 25, 0, 0, 45, 0, 0, 57, 0, 0, 26, 0, 0, 29, 0, 0, 38, 0, 0, 53, 0, 0, 23, 0, 0, 43, 0, 0, 46, 0, 0, 42, 0, 0, 22, 0, 0, 54, 0, 0, 51, 0, 0, 15, 0, 0, 30, 0, 0, 39, 0, 0, 47, 0, 0, 55, 0, 0, 27, 0, 0, 59, 0, 0, 31]),
            p = new Int16Array([3, 6, 0, 12, 9, 0, 0, 0, 0, 18, 15, 0, 24, 21, 0, 0, 0, -1, 0, 0, 1, 27, 30, 0, 36, 33, 0, 0, 0, 2, 0, 0, -2, 42, 45, 0, 48, 39, 0, 60, 54, 0, 0, 0, 3, 0, 0, -3, 51, 57, 0, -1, 69, 0, 81, 75, 0, 78, 63, 0, 72, 66, 0, 96, 84, 0, 87, 93, 0, -1, 99, 0, 108, 105, 0, 0, 0, -4, 90, 102, 0, 0, 0, 4, 0, 0, -7, 0, 0, 5, 111, 123, 0, 0, 0, -5, 0, 0, 7, 114, 120, 0, 126, 117, 0, 0, 0, -6, 0, 0, 6, 153, 162, 0, 150, 147, 0, 135, 138, 0, 156, 141, 0, 129, 159, 0, 132, 144, 0, 0, 0, 10, 0, 0, 9, 0, 0, 8, 0, 0, -8, 171, 198, 0, 0, 0, -9, 180, 192, 0, 168, 183, 0, 165, 186, 0, 174, 189, 0, 0, 0, -10, 177, 195, 0, 0, 0, 12, 0, 0, 16, 0, 0, 13, 0, 0, 14, 0, 0, 11, 0, 0, 15, 0, 0, -16, 0, 0, -12, 0, 0, -14, 0, 0, -15, 0, 0, -11, 0, 0, -13]),
            q = new Int8Array([6, 3, 0, 18, 15, 0, 9, 12, 0, 0, 0, 1, 0, 0, 2, 27, 24, 0, 21, 30, 0, 0, 0, 0, 36, 33, 0, 0, 0, 4, 0, 0, 3, 39, 42, 0, 0, 0, 5, 0, 0, 6, 48, 45, 0, 51, -1, 0, 0, 0, 7, 0, 0, 8]),
            r = new Int8Array([6, 3, 0, 12, 9, 0, 18, 15, 0, 24, 21, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 30, 27, 0, 0, 0, 3, 36, 33, 0, 0, 0, 4, 42, 39, 0, 0, 0, 5, 48, 45, 0, 0, 0, 6, 51, -1, 0, 0, 0, 7, 0, 0, 8]),
            s = new Int32Array([3, 6, 0, 12, 9, 0, 0, 0, 1, 21, 24, 0, 18, 15, 0, 39, 27, 0, 33, 30, 0, 42, 36, 0, 0, 0, 257, 60, 66, 0, 54, 63, 0, 48, 57, 0, 0, 0, 513, 51, 45, 0, 0, 0, 2, 0, 0, 3, 81, 75, 0, 87, 93, 0, 72, 78, 0, 96, 90, 0, 0, 0, 1025, 69, 84, 0, 0, 0, 769, 0, 0, 258, 0, 0, 1793, 0, 0, 65535, 0, 0, 1537, 111, 108, 0, 0, 0, 1281, 105, 102, 0, 117, 114, 0, 99, 126, 0, 120, 123, 0, 156, 150, 0, 162, 159, 0, 144, 147, 0, 129, 135, 0, 138, 132, 0, 0, 0, 2049, 0, 0, 4, 0, 0, 514, 0, 0, 2305, 153, 141, 0, 165, 171, 0, 180, 168, 0, 177, 174, 0, 183, 186, 0, 0, 0, 2561, 0, 0, 3329, 0, 0, 6, 0, 0, 259, 0, 0, 5, 0, 0, 770, 0, 0, 2817, 0, 0, 3073, 228, 225, 0, 201, 210, 0, 219, 213, 0, 234, 222, 0, 216, 231, 0, 207, 192, 0, 204, 189, 0, 198, 195, 0, 243, 261, 0, 273, 240, 0, 246, 237, 0, 249, 258, 0, 279, 276, 0, 252, 255, 0, 270, 282, 0, 264, 267, 0, 0, 0, 515, 0, 0, 260, 0, 0, 7, 0, 0, 1026, 0, 0, 1282, 0, 0, 4097, 0, 0, 3841, 0, 0, 3585, 315, 321, 0, 333, 342, 0, 312, 291, 0, 375, 357, 0, 288, 294, 0, -1, 369, 0, 285, 303, 0, 318, 363, 0, 297, 306, 0, 339, 309, 0, 336, 348, 0, 330, 300, 0, 372, 345, 0, 351, 366, 0, 327, 354, 0, 360, 324, 0, 381, 408, 0, 417, 420, 0, 390, 378, 0, 435, 438, 0, 384, 387, 0, 0, 0, 2050, 396, 402, 0, 465, 462, 0, 0, 0, 8, 411, 399, 0, 429, 432, 0, 453, 414, 0, 426, 423, 0, 0, 0, 10, 0, 0, 9, 0, 0, 11, 0, 0, 5377, 0, 0, 1538, 0, 0, 771, 0, 0, 5121, 0, 0, 1794, 0, 0, 4353, 0, 0, 4609, 0, 0, 4865, 444, 456, 0, 0, 0, 1027, 459, 450, 0, 0, 0, 261, 393, 405, 0, 0, 0, 516, 447, 441, 0, 516, 519, 0, 486, 474, 0, 510, 483, 0, 504, 498, 0, 471, 537, 0, 507, 501, 0, 522, 513, 0, 534, 531, 0, 468, 477, 0, 492, 495, 0, 549, 546, 0, 525, 528, 0, 0, 0, 263, 0, 0, 2562, 0, 0, 2306, 0, 0, 5633, 0, 0, 5889, 0, 0, 6401, 0, 0, 6145, 0, 0, 1283, 0, 0, 772, 0, 0, 13, 0, 0, 12, 0, 0, 14, 0, 0, 15, 0, 0, 517, 0, 0, 6657, 0, 0, 262, 540, 543, 0, 480, 489, 0, 588, 597, 0, 0, 0, 27, 609, 555, 0, 606, 603, 0, 0, 0, 19, 0, 0, 22, 591, 621, 0, 0, 0, 18, 573, 576, 0, 564, 570, 0, 0, 0, 20, 552, 582, 0, 0, 0, 21, 558, 579, 0, 0, 0, 23, 612, 594, 0, 0, 0, 25, 0, 0, 24, 600, 615, 0, 0, 0, 31, 0, 0, 30, 0, 0, 28, 0, 0, 29, 0, 0, 26, 0, 0, 17, 0, 0, 16, 567, 618, 0, 561, 585, 0, 654, 633, 0, 0, 0, 37, 645, 648, 0, 0, 0, 36, 630, 636, 0, 0, 0, 34, 639, 627, 0, 663, 666, 0, 657, 624, 0, 651, 642, 0, 669, 660, 0, 0, 0, 35, 0, 0, 267, 0, 0, 40, 0, 0, 268, 0, 0, 266, 0, 0, 32, 0, 0, 264, 0, 0, 265, 0, 0, 38, 0, 0, 269, 0, 0, 270, 0, 0, 33, 0, 0, 39, 0, 0, 7937, 0, 0, 6913, 0, 0, 7681, 0, 0, 4098, 0, 0, 7425, 0, 0, 7169, 0, 0, 271, 0, 0, 274, 0, 0, 273, 0, 0, 272, 0, 0, 1539, 0, 0, 2818, 0, 0, 3586, 0, 0, 3330, 0, 0, 3074, 0, 0, 3842]),
            t = 1,
            u = 2,
            v = 3,
            w = 179,
            x = 1,
            y = 175,
            z = 0,
            A = 181,
            B = 178,
            C = ["precision mediump float;", "uniform sampler2D YTexture;", "uniform sampler2D CBTexture;", "uniform sampler2D CRTexture;", "varying vec2 texCoord;", "void main() {", "float y = texture2D(YTexture, texCoord).r;", "float cr = texture2D(CBTexture, texCoord).r - 0.5;", "float cb = texture2D(CRTexture, texCoord).r - 0.5;", "gl_FragColor = vec4(", "y + 1.4 * cr,", "y + -0.343 * cb - 0.711 * cr,", "y + 1.765 * cb,", "1.0", ");", "}"].join("\n"),
            D = ["precision mediump float;", "uniform float loaded;", "varying vec2 texCoord;", "void main() {", "float c = ceil(loaded-(1.0-texCoord.y));", "gl_FragColor = vec4(c,c,c,1);", "}"].join("\n"),
            E = ["attribute vec2 vertex;", "varying vec2 texCoord;", "void main() {", "texCoord = vertex;", "gl_Position = vec4((vertex * 2.0 - 1.0) * vec2(1, -1), 0.0, 1.0);", "}"].join("\n"),
            F = [null, l, m, n],
            G = function(a) {
                this.bytes = new Uint8Array(a), this.length = this.bytes.length, this.writePos = this.bytes.length, this.index = 0
            };
        G.NOT_FOUND = -1, G.prototype.findNextMPEGStartCode = function() {
            for (var a = this.index + 7 >> 3; a < this.writePos; a++)
                if (0 === this.bytes[a] && 0 === this.bytes[a + 1] && 1 === this.bytes[a + 2]) return this.index = a + 4 << 3, this.bytes[a + 3];
            return this.index = this.writePos << 3, G.NOT_FOUND
        }, G.prototype.nextBytesAreStartCode = function() {
            var a = this.index + 7 >> 3;
            return a >= this.writePos || 0 === this.bytes[a] && 0 === this.bytes[a + 1] && 1 === this.bytes[a + 2]
        }, G.prototype.nextBits = function(a) {
            var b = this.index >> 3,
                c = 8 - this.index % 8;
            if (c >= a) return this.bytes[b] >> c - a & 255 >> 8 - a;
            var d = (this.index + a) % 8,
                e = this.index + a - 1 >> 3,
                f = this.bytes[b] & 255 >> 8 - c;
            for (b++; e > b; b++) f <<= 8, f |= this.bytes[b];
            return d > 0 ? (f <<= d, f |= this.bytes[b] >> 8 - d) : (f <<= 8, f |= this.bytes[b]), f
        }, G.prototype.getBits = function(a) {
            var b = this.nextBits(a);
            return this.index += a, b
        }, G.prototype.advance = function(a) {
            return this.index += a
        }, G.prototype.rewind = function(a) {
            return this.index -= a
        }
    }(window);
var MpegTexture = function(a, b, c) {
    CanvasTexture.call(this, a, b), this.mVideoPlayer = c
};
extend(MpegTexture, CanvasTexture);
var TextureUnitState = function(a, b, c) {
    if (null == a || null == b || null == c) throw new Error("incomplete arguments");
    this.mRoot = a, this.texture = null, this.mGroupId = b, this.mPrefix = c, this.mName = "", this.mFrames = [], this.mFramePtrs = [], this.mTextureNameAlias = "", this.mEffects = {}, this.mCompositorRefName = "", this.mCompositorRefTexName = "", this.mCurrentFrame = 0, this.mCompareEnabled = !1, this.mCompareFunc = 0, this.mAnimDuration = 0, this.mCubic = !1, this.mTextureType = 2, this.mDesiredFormat = 0, this.mTextureSrcMipmaps = -1, this.mTextureCoordSetIndex = 0, this.mAddressMode = {}, this.setTextureAddressingMode(TAM_CLAMP), this.mBorderColour = ColourValue.Black, this.mColourBlendMode = new LayerBlendModeEx, this.mColourFallbackSrc, this.mColourBlendFallbackDest, this.mAlphaBlendMode = new LayerBlendModeEx, this.mTextureLoadFailed, this.mIsAlpha = !1, this.mHwGamma = !1, this.mGamma = 1, this.mRecalcTexMatrix = !1, this.mUMod = 0, this.mVMod = 0, this.mUScale = 1, this.mVScale = 1, this.mRotate = 0, this.mTexModMatrix = new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this.mMinFilter = 2, this.mMagFilter = 2, this.mMipFilter = 1, this.mMaxAniso = 0, this.mMipmapBias = 0, this.mIsDefaultAniso = !0, this.mIsDefaultFiltering = !0, this.mBindingType = 0, this.mContentType = 0, this.mCompositorRefMrtIndex, this.mAnimController = 0
};
TextureUnitState.prototype = {
    constructor: TextureUnitState,
    load: function(a) {},
    setTextureName: function(a) {
        if (a) {
            var b = this.mRoot.getTextureManager().getByName(a, this.mGroupId);
            if (null == b) {
                StringConverter.parseSuffix(a);
                b = this.mRoot.getTextureManager().create(a, this.mGroupId), b.load(null, this.mPrefix)
            }
            this.texture = b
        }
    },
    setTexture: function(a) {
        a && (this.texture = a)
    },
    getTexture: function() {
        return this.texture
    },
    setCurrentFrame: function(a) {
        a < this.mFrames.length && (this.mCurrentFrame = a)
    },
    getCurrentFrame: function() {
        return this.mCurrentFrame
    },
    getFrameTextureName: function(a) {
        return this.mFrames[a]
    },
    setDesiredFormat: function(a) {
        this.mDesiredFormat = a
    },
    getDesiredFormat: function() {
        return this.mDesiredFormat
    },
    setNumMipmaps: function(a) {
        this.mTextureSrcMipmaps = a
    },
    getNumMipmaps: function() {
        return this.mTextureSrcMipmaps
    },
    setIsAlpha: function(a) {
        this.mIsAlpha = a
    },
    getIsAlpha: function() {
        return this.mIsAlpha
    },
    setHardwareGammaEnabled: function(a) {
        this.mHwGamma = a
    },
    isHardwareGammaEnabled: function() {
        return this.mHwGamma
    },
    getTextureCoordSet: function() {
        return this.mTextureCoordSetIndex
    },
    setTextureCoordSet: function(a) {
        this.mTextureCoordSetIndex = a
    },
    setTextureCompareEnabled: function(a) {
        this.mCompareEnabled = a
    },
    getTextureCompareEnabled: function() {
        return this.mCompareEnabled
    },
    setTextureCompareFunction: function(a) {
        this.mCompareFunc = a
    },
    getTextureCompareFunction: function() {
        return this.mCompareFunc
    },
    setTextureScroll: function(a, b) {
        this.mUMod = a, this.mVMod = b, this.mRecalcTexMatrix = !0
    },
    setTextureVScroll: function(a) {
        this.mVMod = a, this.mRecalcTexMatrix = !0
    },
    getTextureVScroll: function() {
        return this.mVMod
    },
    setTextureUScroll: function(a) {
        this.mUMod = a, this.mRecalcTexMatrix = !0
    },
    getTextureUScroll: function() {
        return this.mUMod
    },
    setTextureUScale: function(a) {
        this.mUScale = a, this.mRecalcTexMatrix = !0
    },
    getTextureUScale: function() {
        return this.mUScale
    },
    setTextureVScale: function(a) {
        this.mVScale = a, this.mRecalcTexMatrix = !0
    },
    getTextureVScale: function() {
        return this.mVScale
    },
    setTextureScale: function(a, b) {
        this.mUScale = a, this.mVScale = b, this.mRecalcTexMatrix = !0
    },
    setTextureRotate: function(a) {
        this.mRotate = a, this.mRecalcTexMatrix = !0
    },
    getTextureRotate: function() {
        return this.mRotate
    },
    getTextureTransform: function() {
        return this.mRecalcTexMatrix && this.recalcTextureMatrix(), this.mTexModMatrix
    },
    recalcTextureMatrix: function() {
        var a = new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        if ((1 != this.mUScale || 1 != this.mVScale) && (a.m[0] = 1 / this.mUScale, a.m[5] = 1 / this.mVScale, a.m[3] = -.5 * a.m[0] + .5, a.m[7] = -.5 * a.m[5] + .5), 0 != this.mRotate) {
            var b = new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                c = this.mRotate,
                d = Math.cos(c),
                e = Math.sin(c);
            b.m[0] = d, b.m[1] = -e, b.m[4] = e, b.m[5] = d, b.m[3] = .5 + (-.5 * d - -.5 * e), b.m[7] = .5 + (-.5 * e + -.5 * d), a = b.multiply(a)
        }
        if (this.mUMod || this.mVMod) {
            var f = new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            f.m[3] = this.mUMod, f.m[7] = this.mVMod, a = f.multiply(a)
        }
        this.mTexModMatrix = a, this.mRecalcTexMatrix = !1
    },
    setTextureAddressingMode: function(a, b, c) {
        3 == arguments.length ? (this.mAddressMode.u = a, this.mAddressMode.v = b, this.mAddressMode.w = c) : (this.mAddressMode.u = a, this.mAddressMode.v = a, this.mAddressMode.w = a)
    },
    getTextureAddressingMode: function() {
        return this.mAddressMode
    }
};
var ET_ENVIRONMENT_MAP = 0,
    ET_PROJECTIVE_TEXTURE = 1,
    ET_UVSCROLL = 2,
    ET_USCROLL = 3,
    ET_VSCROLL = 4,
    ET_ROTATE = 5,
    ET_TRANSFORM = 6,
    ENV_PLANAR = 0,
    ENV_CURVED = 1,
    ENV_REFLECTION = 2,
    ENV_NORMAL = 3,
    TT_TRANSLATE_U = 0,
    TT_TRANSLATE_V = 1,
    TT_SCALE_U = 2,
    TT_SCALE_V = 3,
    TT_ROTATE = 4,
    TAM_WRAP = 0,
    TAM_MIRROR = 1,
    TAM_CLAMP = 2,
    TAM_BORDER = 3,
    UVWAddressingMode = function() {
        this.u, this.v, this.w
    },
    CUBE_FRONT = 0,
    CUBE_BACK = 1,
    CUBE_LEFT = 2,
    CUBE_RIGHT = 3,
    CUBE_UP = 4,
    CUBE_DOWN = 5,
    TextureEffect = function() {
        this.type, this.subtype, this.arg1, this.arg2, this.waveType, this.base, this.frequency, this.phase, this.amplitude, this.controller = [], this.frustum
    },
    AnimationManager = function(a) {
        ResourceManager.call(this), this.mRoot = a, this.mAnimationList = [], this.mAnimationUtil = new AnimationUtils, this.mIsPause = !1
    };
AnimationManager.prototype = {
    constructor: AnimationManager,
    registerAnimation: function(a) {
        this.mAnimationList.push(a)
    },
    unregisterAnimation: function(a) {
        for (var b = this.mAnimationList.length, c = 0; b > c; c++)
            if (a === this.mAnimationList[c]) return void this.mAnimationList.slice(c, 1)
    },
    update: function() {
        if (!this.mIsPause)
            for (var a in this.mAnimationList) {
                var b = this.mAnimationList[a];
                b.updateAnimation()
            }
    },
    onStop: function(a) {
        for (var b in this.mAnimationList) {
            var c = this.mAnimationList[b];
            c.onStopAnimation(a)
        }
    },
    findAnimation: function(a) {
        for (var b in this.mAnimationList) {
            var c = this.mAnimationList[b];
            if (c.getName() == a) return c;
            if (c instanceof AnimationSet) {
                var d = c.findAnimation(a);
                if (d) return d
            }
        }
        return null
    },
    releaseAllAnimation: function() {
        for (; 0 !== this.mAnimationList.length;) {
            var a = this.mAnimationList.slice(0, 1);
            a = null
        }
    },
    onResize: function(a, b) {
        for (var c in this.mAnimationList) this.mAnimationList[c].onResize(a, b)
    },
    pauseAnimaitonTime: function() {
        this.mIsPause || (this.mIsPause = !0, this.mAnimationUtil.pauseTime())
    },
    resumeAnimation: function() {
        this.mIsPause && (this.mIsPause = !1, this.mAnimationUtil.resumeTime())
    },
    getAnimationUtil: function() {
        return this.mAnimationUtil
    },
    resetAnimation: function() {
        this.mIsPause = !1, this.mAnimationUtil.reset()
    }
}, AnimationManager.prototype.releaseResourceByGroupId = function(a) {
    for (var b = 0; b < this.mAnimationList.length;) this.mAnimationList[b].mGroupId == a ? this.mAnimationList.splice(b, 1) : b++
};
var TRect = function(a, b, c, d) {
    this.left = a || 0, this.top = b || 0, this.right = c || 0, this.bottom = d || 0
};
TRect.prototype = {
    constructor: TRect,
    copy: function(a) {
        this.left = a.left, this.right = a.right, this.top = a.top, this.bottom = a.bottom
    },
    set: function(a, b, c, d) {
        this.left = a, this.top = b, this.right = c, this.bottom = d
    },
    insert: function(a, b) {
        this.left += a, this.top += b, this.right -= a, this.bottom -= b
    },
    uniont: function(a, b, c, d) {
        if (4 == arguments.length) this.left < this.right && this.top < this.bottom ? (this.left > a && (this.left = a), this.top > b && (this.top = b), this.right < c && (this.right = c), this.bottom < d && (this.bottom = d)) : (this.left = a, this.top = b, this.right = c, this.bottom = d);
        else {
            var e = arguments[0];
            this.uniont(e.left, e.top, e.right, e.bottom)
        }
    },
    width: function() {
        return this.right - this.left
    },
    height: function() {
        return this.bottom - this.top
    },
    isNull: function() {
        return 0 == this.width() || 0 == this.height()
    },
    setNull: function() {
        this.left = 0, this.right = 0, this.top = 0, this.bottom = 0
    },
    merge: function(a) {
        return this.isNull ? this.copy(a) : a.isNull || (this.left = Math.min(this.left, a.left), this.right = Math.max(this.right, a.right), this.top = Math.min(this.top, a, top), this.bottom = Math.max(this.bottom, a.bottom)), this
    },
    intersect: function(a) {
        var b = new TRect;
        return this.isNull() || a.isNull() ? b : (b.left = Math.max(this.left, a.left), b.right = Math.min(this.right, a.right), b.top = Math.max(this.top, a.top), b.bottom = Math.min(this.bottom, a.bottom), (b.left > b.right || b.top > b.bottom) && b.setNull(), b)
    }
};
var Box = function() {
    this.left = 0, this.top = 0, this.right = 1, this.bottom = 1, this.front = 0, this.back = 1
};
Box.prototype = {
    constructor: Box,
    copy: function(a) {
        this.left = a.left, this.top = a.top, this.right = a.right, this.bottom = a.bottom, this.front = a.front, this.back = a.back
    },
    set: function(a, b, c, d, e, f) {
        this.left = a, this.top = b, this.right = d, this.bottom = e, this.front = c, this.back = f
    },
    contains: function(a) {
        return a.left >= this.left && a.top >= this.top && a.front >= this.front && a.right >= this.right && a.bottom <= this.bottom && a.back <= this.back
    },
    getWidth: function() {
        return this.right - this.left
    },
    getHeight: function() {
        return this.bottom - this.top
    },
    getDepth: function() {
        return this.back - this.front
    }
};
var TextureSplit = function() {
    this.mTextureCoords = []
};
TextureSplit.prototype = {
    constructor: TextureSplit,
    setTextureStacksAndSlices: function(a, b, c, d) {
        c = void 0 !== c ? c : !1, d = void 0 !== d ? d : !1, 0 == a && (a = 1), 0 == b && (b = 1), this.mTextureCoords = new Array(a * b);
        for (var e = 0, f = 0; a > f; ++f) {
            var g, h;
            d ? (g = (a - f - 1) / a, h = (a - f) / a) : (g = f / a, h = (f + 1) / a);
            for (var i = 0; b > i; ++i) {
                var j = new TRect;
                c ? (j.left = i / b, j.bottom = g, j.right = (i + 1) / b, j.top = h) : (j.left = i / b, j.bottom = h, j.right = (i + 1) / b, j.top = g), this.mTextureCoords[e] = j, ++e
            }
        }
    },
    getTextureCoord: function(a) {
        return this.mTextureCoords[a]
    },
    getTextureCoords: function() {
        return this.mTextureCoords
    }
};
var Timer = function() {
    var a = new Date;
    this.mStartTime = a.valueOf(), this.mLastTime = this.mStartTime
};
Timer.prototype = {
    constructor: Timer,
    setOption: function(a, b) {
        return !1
    },
    reset: function() {
        var a = new Date;
        this.mStartTime = a.valueOf(), this.mLastTime = this.mStartTime
    },
    getCurrTime: function() {
        var a = new Date;
        return a.valueOf()
    },
    getStartTime: function() {
        return this.mStartTime
    },
    getLastTime: function() {
        return this.mLastTime
    },
    getTimeDiff: function() {
        return this.getCurrTime() - this.mLastTime
    },
    getMilliseconds: function() {
        var a = new Date,
            b = a.valueOf();
        return this.mLastTime = b, this.mLastTime - this.mStartTime
    }
}, Timer.currentTimeMillis = function() {
    return 0
};
var TouchEventListener = function() {
    this.mClickEventListener = [], this.mMoveEventListener = [], this.mLongPressEventListener = [], this.mPressDownEventListener = [], this.mPressUpEventListener = []
};
TouchEventListener.prototype = {
    constructor: TouchEventListener,
    onEventClick: function(a) {
        var b = null;
        for (var c in this.mClickEventListener)(b = this.mClickEventListener[c])(a)
    },
    onEventMove: function(a, b, c) {
        var d = null;
        for (var e in this.mMoveEventListener)(d = this.mMoveEventListener[e])(a, b, c)
    },
    onEventLongPress: function(a) {
        var b = null;
        for (var c in this.mLongPressEventListener)(b = this.mLongPressEventListener[c])(a)
    },
    onEventPressDown: function(a) {
        var b = null;
        for (var c in this.mPressDownEventListener)(b = this.mPressDownEventListener[c])(a)
    },
    onEventPressUp: function(a, b, c) {
        var d = null;
        for (var e in this.mPressUpEventListener)(d = this.mPressUpEventListener[e])(a, b, c)
    }
};
var TouchScreenEvent = function(a, b, c) {
    this.mRoot = a, this.screen = {
        left: 0,
        top: 0,
        width: 0,
        height: 0
    }, this.object = b, this.domElement = void 0 !== c ? c : document, this.mouseDown = !1, this.moved = !1, this.startTime = 0, this.currentTime = 0, this.lagTime = 0, this.startPos = {
        x: 0,
        y: 0
    }, this.endPos = {
        x: 0,
        y: 0
    }, this.curPos = {
        x: 0,
        y: 0
    };
    var d = this;
    this.handleResize = function(a) {
        var b = (this.screen, 0);
        if (this.domElement == a) {
            b = 1;
            try {
                var c = this.domElement.getBoundingClientRect();
                this.screen.left = c.left, this.screen.top = c.top, this.screen.width = c.width, this.screen.height = c.height
            } catch (d) {
                console.error("You should display canvas before TouchEvent is created.")
            }
        } else {
            b = 2;
            var c = this.domElement.getBoundingClientRect(),
                e = this.domElement.ownerDocument.documentElement;
            this.screen.left = c.left + window.pageXOffset - e.clientLeft, this.screen.top = c.top + window.pageYOffset - e.clientTop, this.screen.width = c.width, this.screen.height = c.height;
            var f = this.mRoot.getCanvasRatio(this.domElement);
            this.mRoot.onSize(c.width * f, c.height * f)
        }
    }, d.getMouseOnScreen = function(a, b) {
        return {
            x: (a - this.screen.left) / d.screen.width,
            y: (b - this.screen.top) / d.screen.height
        }
    }, d.touchStartHandler = function(a) {
        if (d.startTime = (new Date).getTime(), d.moved = !1, a.preventDefault(), a.stopPropagation(), a.touches.length > 0) {
            var b = a.touches[0];
            d.curPos = d.getMouseOnScreen(b.pageX, b.pageY), d.startPos = d.curPos, d.mListener.onEventPressDown(d.curPos)
        }
    }, this.touchMoveHandler = function(a) {
        if (d.moved = !0, a.preventDefault(), a.stopPropagation(), a.touches.length > 0) {
            var b = a.touches[0];
            d.curPos = d.getMouseOnScreen(b.pageX, b.pageY), d.endPos = d.curPos;
            var c = d.endPos.x - d.startPos.x,
                e = d.endPos.y - d.startPos.y;
            d.mListener.onEventMove(d.curPos, c, e)
        }
    }, d.touchEndHandler = function(a) {
        if (d.currentTime = (new Date).getTime(), d.lagTime = d.currentTime - d.startTime, a.preventDefault(), a.stopPropagation(), a.changedTouches.length > 0) {
            var b = a.changedTouches[0];
            d.curPos = d.getMouseOnScreen(b.pageX, b.pageY), d.endPos = d.curPos;
            var c = d.endPos.x - d.startPos.x,
                e = d.endPos.y - d.startPos.y;
            !d.moved || 0 == c && 0 == e ? d.lagTime < 300 ? d.mListener.onEventClick(d.curPos) : d.mListener.onEventLongPress(d.curPos) : (d.mListener.onEventMove(d.curPos, c, e), d.startPos = d.endPos), d.mListener.onEventPressUp(d.curPos, c, e), d.moved = !1
        }
    }, d.mouseDownHandler = function(a) {
        d.startTime = (new Date).getTime(), d.moved = !1, d.mouseDown = !0, a = a || window.event;
        var b = 0,
            c = 0;
        a.pageX || a.pageY ? (b = a.pageX, c = a.pageY) : (b = a.clientX + document.body.scrollLeft - document.body.clientLeft, c = a.clientY + document.body.scrollTop - document.body.clientTop), a.preventDefault(), a.stopPropagation();
        var e = d.getMouseOnScreen(b, c);
        d.startPos = {
            x: e.x,
            y: e.y
        }, d.mListener.onEventPressDown(e)
    }, d.mouseMoveHandler = function(a) {
        d.moved = !1, a = a || window.event;
        var b = 0,
            c = 0;
        if (a.pageX || a.pageY ? (b = a.pageX, c = a.pageY) : (b = a.clientX + document.body.scrollLeft - document.body.clientLeft, c = a.clientY + document.body.scrollTop - document.body.clientTop), a.preventDefault(), a.stopPropagation(), d.mouseDown) {
            d.curPos = d.getMouseOnScreen(b, c), d.endPos = {
                x: d.curPos.x,
                y: d.curPos.y
            };
            var e = d.endPos.x - d.startPos.x,
                f = d.endPos.y - d.startPos.y;
            (Math.abs(e) > 0 || Math.abs(f) > 0) && (d.moved = !0, d.mListener.onEventMove(d.curPos, e, f))
        }
    }, d.mouseUpHandler = function(a) {
        d.mouseDown = !1, d.currentTime = (new Date).getTime(), d.lagTime = d.currentTime - d.startTime, a.preventDefault(), a.stopPropagation();
        var b = d.getMouseOnScreen(a.pageX, a.pageY);
        d.endPos = {
            x: b.x,
            y: b.y
        };
        var c = d.endPos.x - d.startPos.x,
            e = d.endPos.y - d.startPos.y;
        d.moved ? d.mListener.onEventMove(b, c, e) : d.lagTime < 300 ? d.mListener.onEventClick(b) : d.mListener.onEventLongPress(b), d.mListener.onEventPressUp(b, c, e), d.moved = !1
    }, this.domElement.addEventListener("mousedown", this.mouseDownHandler, !1), this.domElement.addEventListener("mouseup", this.mouseUpHandler, !1), this.domElement.addEventListener("mousemove", this.mouseMoveHandler, !1), this.domElement.addEventListener("touchstart", this.touchStartHandler, !1), this.domElement.addEventListener("touchend", this.touchEndHandler, !1), this.domElement.addEventListener("touchmove", this.touchMoveHandler, !1), this.handleResize(c), this.mListener = new TouchEventListener
};
TouchScreenEvent.prototype = {
    constructor: TouchScreenEvent,
    registerTouchEvent: function(a, b, c, d, e, f) {
        b && (b.mGroupId = a, this.mListener.mClickEventListener.push(b)), c && (c.mGroupId = a, this.mListener.mMoveEventListener.push(c)), d && (d.mGroupId = a, this.mListener.mLongPressEventListener.push(d)), e && (e.mGroupId = a, this.mListener.mPressDownEventListener.push(e)), f && (f.mGroupId = a, this.mListener.mPressUpEventListener.push(f))
    },
    removeTouchEventByOwner: function(a) {
        var b = null;
        for (var c in this.mListener.mClickEventListener) b = this.mListener.mClickEventListener[c], b.mGroupId === a && (this.mListener.mClickEventListener.splice(c, 1), b = null);
        for (var c in this.mListener.mMoveEventListener) b = this.mListener.mMoveEventListener[c], b.mGroupId === a && (this.mListener.mMoveEventListener.splice(c, 1), b = null);
        for (var c in this.mListener.mLongPressEventListener) b = this.mListener.mLongPressEventListener[c], b.mGroupId === a && (this.mListener.mLongPressEventListener.splice(c, 1), b = null);
        for (var c in this.mListener.mPressDownEventListener) b = this.mListener.mPressDownEventListener[c], b.mGroupId === a && (this.mListener.mPressDownEventListener.splice(c, 1), b = null);
        for (var c in this.mListener.mPressUpEventListener) b = this.mListener.mPressUpEventListener[c], b.mGroupId === a && (this.mListener.mPressUpEventListener.splice(c, 1), b = null)
    }
};
var LBT_COLOUR = 0,
    LBT_ALPHA = 1,
    LBO_REPLACE = 0,
    LBO_ADD = 1,
    LBO_MODULATE = 2,
    LBO_ALPHA_BLEND = 3,
    LBX_SOURCE1 = 0,
    LBX_SOURCE2 = 1,
    LBX_MODULATE = 2,
    LBX_MODULATE_X2 = 3,
    LBX_MODULATE_X4 = 4,
    LBX_ADD = 5,
    LBX_ADD_SIGNED = 6,
    LBX_ADD_SMOOTH = 7,
    LBX_SUBTRACT = 8,
    LBX_BLEND_DIFFUSE_ALPHA = 9,
    LBX_BLEND_TEXTURE_ALPHA = 10,
    LBX_BLEND_CURRENT_ALPHA = 11,
    LBX_BLEND_MANUAL = 12,
    LBX_DOTPRODUCT = 13,
    LBX_BLEND_DIFFUSE_COLOUR = 14,
    LBS_CURRENT = 0,
    LBS_TEXTURE = 1,
    LBS_DIFFUSE = 2,
    LBS_SPECULAR = 3,
    LBS_MANUAL = 4,
    LayerBlendModeEx = function() {
        this.blendType, this.operation, this.source1, this.source2, this.colourArg1, this.colourArg2, this.alphaArg1, this.alphaArg2, this.factor
    };
LayerBlendModeEx.prototype = {
    constructor: LayerBlendModeEx,
    equals: function(a) {
        if (this.blendType != a.blendType) return !1;
        if (this.blendType == LBT_COLOUR) {
            if (this.operation == a.operation && this.source1 == a.source1 && this.source2 == a.source2 && this.colourArg1 == a.colourArg1 && this.colourArg2 == a.colourArg2 && this.factor == a.factor) return !0
        } else if (this.operation == a.operation && this.source1 == a.source1 && this.source2 == a.source2 && this.alphaArg1 == a.alphaArg1 && this.alphaArg2 == a.alphaArg2 && this.factor == a.factor) return !0;
        return !1
    },
    notEquals: function(a) {
        return !this.equals(a)
    }
};
var SBT_TRANSPARENT_ALPHA = 1,
    SBT_TRANSPARENT_COLOUR = 2,
    SBT_ADD = 3,
    SBT_MODULATE = 4,
    SBT_REPLACE = 5,
    SBF_ONE = 0,
    SBF_ZERO = 1,
    SBF_DEST_COLOUR = 2,
    SBF_SOURCE_COLOUR = 3,
    SBF_ONE_MINUS_DEST_COLOUR = 4,
    SBF_ONE_MINUS_SOURCE_COLOUR = 5,
    SBF_DEST_ALPHA = 6,
    SBF_SOURCE_ALPHA = 7,
    SBF_ONE_MINUS_DEST_ALPHA = 8,
    SBF_ONE_MINUS_SOURCE_ALPHA = 9,
    SBO_ADD = 0,
    SBO_SUBTRACT = 1,
    SBO_REVERSE_SUBTRACT = 2,
    SBO_MIN = 3,
    SBO_MAX = 4,
    HardwareBuffer = function(a, b, c) {
        c && a == HBU_DYNAMIC ? this.mUsage = HBU_DYNAMIC_WRITE_ONLY : c && a == HBU_STATIC && (this.mUsage = HBU_STATIC_WRITE_ONLY), this.mSizeInBytes = null
    };
HardwareBuffer.prototype = {
    constructor: HardwareBuffer,
    createDataBuffer: function(a, b) {},
    lock: function() {},
    unlock: function() {}
};
var HBU_STATIC = 1,
    HBU_DYNAMIC = 2,
    HBU_WRITE_ONLY = 4,
    HBU_DISCARDABLE = 8,
    HBU_STATIC_WRITE_ONLY = 5,
    HBU_DYNAMIC_WRITE_ONLY = 6,
    HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE = 14,
    HBL_NORMAL = 0,
    HBL_DISCARD = 1,
    HBL_READ_ONLY = 2,
    HBL_NO_OVERWRITE = 3,
    HBL_WRITE_ONLY = 4,
    HardwareVertexBuffer = function(a, b, c, d, e, f) {
        HardwareBuffer.call(this, d, e, f), this.mNumVertices = c, this.mVertexSize = b, this.mSizeInBytes = this.mVertexSize * this.mNumVertices
    };
extend(HardwareVertexBuffer, HardwareBuffer), HardwareVertexBuffer.prototype.getVertexSize = function() {
    return this.mVertexSize
};
var HardwareIndexBuffer = function(a, b, c, d, e, f) {
    HardwareBuffer.call(this, d, e, f), this.mIndexType = b, this.mNumIndexes = c, this.mIndexSize = 0, this.mIndexSize = Int16Array.BYTES_PER_ELEMENT, this.mSizeInBytes = this.mIndexSize * this.mNumIndexes
};
extend(HardwareIndexBuffer, HardwareBuffer);
var IT_16BIT = 0,
    IT_32BIT = 1,
    GLES2HardwareVertexBuffer = function(a, b, c, d) {
        HardwareVertexBuffer.call(this, 0, b, c, d, !0, !1), this.mRoot = a
    };
extend(GLES2HardwareVertexBuffer, HardwareVertexBuffer), GLES2HardwareVertexBuffer.prototype.createDataBuffer = function(a, b) {
    if (a) {
        var c = a.slice(b, b + this.mSizeInBytes);
        this.mData = new Float32Array(c, 0, this.mSizeInBytes / Float32Array.BYTES_PER_ELEMENT)
    } else this.mData = new Float32Array(this.mSizeInBytes / Float32Array.BYTES_PER_ELEMENT);
    if (!this.mBufferId) {
        var d = this.mRoot.getRenderFunction().gl;
        this.mBufferId = d.createBuffer(), d.bindBuffer(d.ARRAY_BUFFER, this.mBufferId), d.bufferData(d.ARRAY_BUFFER, this.mData, d.STATIC_DRAW)
    }
}, GLES2HardwareVertexBuffer.prototype.lock = function() {
    return this.mData
}, GLES2HardwareVertexBuffer.prototype.unlock = function() {
    if (this.mBufferId) {
        var a = this.mRoot.getRenderFunction().gl;
        a.bindBuffer(a.ARRAY_BUFFER, this.mBufferId), a.bufferSubData(a.ARRAY_BUFFER, 0, this.mData)
    }
};
var GLES2HardwareIndexBuffer = function(a, b, c, d) {
    HardwareIndexBuffer.call(this, 0, b, c, d, !0, !1), this.mRoot = a
};
GLES2HardwareIndexBuffer.prototype.createDataBuffer = function(a, b) {
    if (a) {
        var c = a.slice(b, b + this.mSizeInBytes);
        this.mData = new Int16Array(c, 0, this.mSizeInBytes / Int16Array.BYTES_PER_ELEMENT)
    } else this.mData = new Int16Array(this.mSizeInBytes / Int16Array.BYTES_PER_ELEMENT);
    if (!this.mBufferId) {
        var d = this.mRoot.getRenderFunction().gl;
        this.mBufferId = d.createBuffer(), d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, this.mBufferId), d.bufferData(d.ELEMENT_ARRAY_BUFFER, this.mData, d.STATIC_DRAW)
    }
}, extend(HardwareIndexBuffer, GLES2HardwareIndexBuffer), GLES2HardwareIndexBuffer.prototype.lock = function() {
    return this.mData
}, GLES2HardwareIndexBuffer.prototype.unlock = function() {
    if (this.mBufferId) {
        var a = this.mRoot.getRenderFunction().gl;
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.mBufferId), a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, this.mData)
    }
};
var VertexElement = function(a, b, c, d, e) {
    this.mSemantic = d, this.mType = c, this.mIndex = e || 0, this.mSource = a, this.mOffset = b
};
VertexElement.prototype.getSize = function() {
    return VertexElement.getTypeSize(this.mType)
}, VertexElement.prototype.getSource = function() {
    return this.mSource
}, VertexElement.prototype.getOffset = function() {
    return this.mOffset
}, VertexElement.prototype.getIndex = function() {
    return this.mIndex
}, VertexElement.prototype.getSemantic = function() {
    return this.mSemantic
}, VertexElement.prototype.getType = function() {
    return this.mType
}, VertexElement.getTypeSize = function(a) {
    switch (a) {
        case VET_COLOUR:
            return 16;
        case VET_COLOUR_ABGR:
        case VET_COLOUR_ARGB:
            return 4;
        case VET_FLOAT1:
            return 4;
        case VET_FLOAT2:
            return 8;
        case VET_FLOAT3:
            return 12;
        case VET_FLOAT4:
            return 16;
        case VET_DOUBLE1:
            return 8;
        case VET_DOUBLE2:
            return 16;
        case VET_DOUBLE3:
            return 24;
        case VET_DOUBLE4:
            return 32;
        case VET_SHORT1:
            return 2;
        case VET_SHORT2:
            return 4;
        case VET_SHORT3:
            return 6;
        case VET_SHORT4:
            return 8;
        case VET_USHORT1:
            return 2;
        case VET_USHORT2:
            return 4;
        case VET_USHORT3:
            return 6;
        case VET_USHORT4:
            return 8;
        case VET_INT1:
            return 4;
        case VET_INT2:
            return 8;
        case VET_INT3:
            return 12;
        case VET_INT4:
            return 16;
        case VET_UINT1:
            return 4;
        case VET_UINT2:
            return 8;
        case VET_UINT3:
            return 12;
        case VET_UINT4:
            return 16;
        case VET_UBYTE4:
            return 2
    }
    return 0
}, VertexElement.getTypeCount = function(a) {
    switch (a) {
        case VET_COLOUR:
        case VET_COLOUR_ABGR:
        case VET_COLOUR_ARGB:
        case VET_FLOAT1:
        case VET_SHORT1:
        case VET_USHORT1:
        case VET_UINT1:
        case VET_INT1:
        case VET_DOUBLE1:
            return 1;
        case VET_FLOAT2:
        case VET_SHORT2:
        case VET_USHORT2:
        case VET_UINT2:
        case VET_INT2:
        case VET_DOUBLE2:
            return 2;
        case VET_FLOAT3:
        case VET_SHORT3:
        case VET_USHORT3:
        case VET_UINT3:
        case VET_INT3:
        case VET_DOUBLE3:
            return 3;
        case VET_FLOAT4:
        case VET_SHORT4:
        case VET_USHORT4:
        case VET_UINT4:
        case VET_INT4:
        case VET_DOUBLE4:
        case VET_UBYTE4:
            return 4
    }
}, VertexElement.getBaseType = function(a) {
    switch (a) {
        case VET_FLOAT1:
        case VET_FLOAT2:
        case VET_FLOAT3:
        case VET_FLOAT4:
            return VET_FLOAT1;
        case VET_DOUBLE1:
        case VET_DOUBLE2:
        case VET_DOUBLE3:
        case VET_DOUBLE4:
            return VET_DOUBLE1;
        case VET_INT1:
        case VET_INT2:
        case VET_INT3:
        case VET_INT4:
            return VET_INT1;
        case VET_UINT1:
        case VET_UINT2:
        case VET_UINT3:
        case VET_UINT4:
            return VET_UINT1;
        case VET_COLOUR:
            return VET_COLOUR;
        case VET_COLOUR_ABGR:
            return VET_COLOUR_ABGR;
        case VET_COLOUR_ARGB:
            return VET_COLOUR_ARGB;
        case VET_SHORT1:
        case VET_SHORT2:
        case VET_SHORT3:
        case VET_SHORT4:
            return VET_SHORT1;
        case VET_USHORT1:
        case VET_USHORT2:
        case VET_USHORT3:
        case VET_USHORT4:
            return VET_USHORT1;
        case VET_UBYTE4:
            return VET_UBYTE4
    }
    return VET_FLOAT1
};
var VES_POSITION = 1,
    VES_BLEND_WEIGHTS = 2,
    VES_BLEND_INDICES = 3,
    VES_NORMAL = 4,
    VES_DIFFUSE = 5,
    VES_SPECULAR = 6,
    VES_TEXTURE_COORDINATES = 7,
    VES_BINORMAL = 8,
    VES_TANGENT = 9,
    VES_COUNT = 9,
    VET_FLOAT1 = 0,
    VET_FLOAT2 = 1,
    VET_FLOAT3 = 2,
    VET_FLOAT4 = 3,
    VET_COLOUR = 4,
    VET_SHORT1 = 5,
    VET_SHORT2 = 6,
    VET_SHORT3 = 7,
    VET_SHORT4 = 8,
    VET_UBYTE4 = 9,
    VET_COLOUR_ARGB = 10,
    VET_COLOUR_ABGR = 11,
    VET_DOUBLE1 = 12,
    VET_DOUBLE2 = 13,
    VET_DOUBLE3 = 14,
    VET_DOUBLE4 = 15,
    VET_USHORT1 = 16,
    VET_USHORT2 = 17,
    VET_USHORT3 = 18,
    VET_USHORT4 = 19,
    VET_INT1 = 20,
    VET_INT2 = 21,
    VET_INT3 = 22,
    VET_INT4 = 23,
    VET_UINT1 = 24,
    VET_UINT2 = 25,
    VET_UINT3 = 26,
    VET_UINT4 = 27,
    VertexDeclaration = function() {
        this.mElementList = []
    };
VertexDeclaration.prototype = {
    constructor: VertexDeclaration,
    addElement: function(a, b, c, d, e) {
        return this.mElementList.push(new VertexElement(a, b, c, d, e)), this.mElementList[this.mElementList.length - 1]
    },
    inertElement: function(a, b, c, d, e, f) {},
    getElement: function(a) {
        return a < this.mElementList.length && a >= 0 ? this.mElementList[a] : null
    },
    removeElement: function(a) {
        return a < this.mElementList.length && a >= 0 ? this.mElementList.splice(a, 1) : null
    },
    removeAllElement: function() {
        this.mElementList = []
    },
    getVertexSize: function(a) {
        var b = 0;
        for (var c in this.mElementList) {
            var d = this.mElementList[c];
            d.getSource() == a && (b += d.getSize())
        }
        return b
    }
};
var VertexData = function(a) {
        this.mMgr = a, this.vertexDeclaration = this.mMgr.createVertexDeclaration(), this.vertexBufferBinding = this.mMgr.createVertexBufferBinding(), this.mVertexStart = 0, this.mVertexCount = 0
    },
    IndexData = function(a) {
        this.mMgr = a, this.indexBuffer = null, this.indexStart = 0, this.indexCount = 0
    },
    SubMesh = function(a) {
        this.parent = a, this.vertexData = null, this.indexData = null, this.operationType = null, this.useSharedVertices = !1, this.mAmBoneWorld = null, this.mAfBoneWorldIT = null, this.mBoneCount = -1, this.mBoneIdList = null
    };
SubMesh.prototype.getRenderOperation = function(a) {
    a.useIndexes = null == this.indexData ? !1 : 0 != this.indexData.indexCount, a.indexData = this.indexData, a.operationType = this.operationType, a.vertexData = this.useSharedVertices ? this.parent.sharedVertexData : this.vertexData
};
var Mesh = function() {
    this.mSubMeshList = [], this.sharedVertexData = null, this.mManipulator = null, this.mBoneIdList = null, this.box_ab = null
};
Mesh.prototype.createSubMesh = function() {
    var a = new SubMesh(this);
    return this.mSubMeshList.push(a), a
}, Mesh.prototype.getNumSubMeshes = function() {
    return this.mSubMeshList.length
}, Mesh.prototype.getSubMesh = function(a) {
    return "number" == typeof a && a < this.mSubMeshList.length && a >= 0 ? this.mSubMeshList[a] : null
}, Mesh.prototype.getWidth = function() {
    return this.mManipulator instanceof eRectManipulator ? this.mManipulator.getWidth() : void 0
}, Mesh.prototype.getHeight = function() {
    return this.mManipulator instanceof eRectManipulator ? this.mManipulator.getHeight() : void 0
}, Mesh.prototype.resize = function(a, b) {
    this.mManipulator instanceof eRectManipulator && this.mManipulator.resize(a, b)
}, Mesh.prototype.setCustomizeAnchor = function(a, b) {
    this.mManipulator instanceof eRectManipulator && this.mManipulator.setCustomizeAnchor(a, b)
}, Mesh.prototype.getAnchor = function() {
    return this.mManipulator instanceof eRectManipulator ? this.mManipulator.getAnchor() : void 0
}, Mesh.prototype.getRenderOperation = function(a) {
    for (var b = 0; b < this.mSubMeshList.length; b++) {
        var c = this.mSubMeshList[b],
            d = new RenderOperation;
        c.getRenderOperation(d), a.push(d)
    }
}, Mesh.prototype.updateTexCoords = function(a, b, c, d) {
    this.mManipulator.updateTexCoords(a, b, c, d)
}, Mesh.prototype.hitTest = function(a) {
    return a.intersectBox(this.box_ab)
};
var MeshManipulator = function(a) {
    this.mMesh = a
};
MeshManipulator.prototype = {
    constructor: MeshManipulator,
    getMesh: function() {
        return this.mMesh
    }
};
var VertexBufferBinding = function() {
        this.mBindingMap = {}, this.setBinding = function(a, b) {
            this.mBindingMap[a] = b
        }, this.getBuffer = function(a) {
            return this.mBindingMap[a]
        }
    },
    HardwareBufferManagerBase = function(a) {
        this.mRoot = a
    };
HardwareBufferManagerBase.prototype.createVertexDeclaration = function() {
    var a = this.createVertexDeclarationImpl();
    return a
}, HardwareBufferManagerBase.prototype.createVertexBufferBinding = function() {
    var a = this.createVertexBufferBindingImpl();
    return a
}, HardwareBufferManagerBase.prototype.createVertexBuffer = function(a, b, c, d) {
    return new GLES2HardwareVertexBuffer(this.mRoot, a, b, c, !1)
}, HardwareBufferManagerBase.prototype.createIndexBuffer = function(a, b, c, d) {
    return new GLES2HardwareIndexBuffer(this.mRoot, a, b, c, !0)
}, HardwareBufferManagerBase.prototype.createVertexDeclarationImpl = function() {
    return new VertexDeclaration(this)
}, HardwareBufferManagerBase.prototype.createVertexBufferBindingImpl = function() {
    return new VertexBufferBinding
};
var eRectManipulator = function(a, b, c, d) {
    Resource.call(this), this.mMesh = b, this.mRoot = a, this.x = 0, this.y = 0, this.mDepth = 0, this.mMainBuf = null, this.width = c || 100, this.height = d || 100, this.mAutoViewportSize = !1, this.mAnchor = TOP_LEFT, this.longUpdate = !1, this.init()
};
eRectManipulator.prototype = {
    constructor: eRectManipulator,
    init: function() {
        var a = this.genVertices(),
            b = a.x0,
            c = a.x1,
            d = a.x2,
            e = a.x3,
            f = a.y0,
            g = a.y1,
            h = a.y2,
            i = a.y3,
            j = {
                left: 0,
                bottom: 0,
                right: 1,
                top: 1
            },
            k = new VertexData(this.mRoot.getHardwareBufferManager());
        k.vertexCount = 4, k.vertexStart = 0;
        var l = k.vertexDeclaration,
            m = k.vertexBufferBinding,
            n = 0;
        l.addElement(0, n, VET_FLOAT3, VES_POSITION), n += VertexElement.getTypeSize(VET_FLOAT3), l.addElement(0, n, VET_FLOAT2, VES_TEXTURE_COORDINATES, 0);
        var o = !0;
        this.mMainBuf = this.mRoot.getHardwareBufferManager().createVertexBuffer(l.getVertexSize(0), k.vertexCount, o ? HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE : HBU_STATIC_WRITE_ONLY), this.mMainBuf.createDataBuffer(), m.setBinding(0, this.mMainBuf);
        var p = 0,
            q = this.mMainBuf.lock();
        q[p++] = b, q[p++] = f, q[p++] = this.mDepth, q[p++] = j.left, q[p++] = j.top, q[p++] = c, q[p++] = g, q[p++] = this.mDepth, q[p++] = j.left, q[p++] = j.bottom, q[p++] = d, q[p++] = h, q[p++] = this.mDepth, q[p++] = j.right, q[p++] = j.top, q[p++] = e, q[p++] = i, q[p++] = this.mDepth, q[p++] = j.right, q[p++] = j.bottom, this.mMainBuf.unlock();
        var r = new IndexData(this.mRoot.getHardwareBufferManager());
        r.indexStart = 0, r.indexCount = 6, r.indexBuffer = this.mRoot.getHardwareBufferManager().createIndexBuffer(IT_16BIT, r.indexCount, HBU_STATIC_WRITE_ONLY), r.indexBuffer.createDataBuffer();
        var s = 0,
            t = r.indexBuffer.lock();
        t[s++] = 0, t[s++] = 1, t[s++] = 2, t[s++] = 1, t[s++] = 3, t[s++] = 2, r.indexBuffer.unlock();
        var u = this.mMesh.createSubMesh();
        u.vertexData = k, u.indexData = r, u.operationType = RenderOperation.OT_TRIANGLE_LIST
    },
    genVertices: function() {
        this.vertices = [];
        var a = 0,
            b = 0,
            c = 0,
            d = 0,
            e = 0,
            f = 0,
            g = 0,
            h = 0;
        return this.mAnchor == TOP_LEFT ? (a = 0, e = 0, b = 0, f = this.height, c = this.width, g = 0, d = this.width, h = this.height) : this.mAnchor == BOTTOM_LEFT ? (a = 0, e = -this.height, b = 0, f = 0, c = this.width, g = -this.height, d = this.width, h = 0) : this.mAnchor == TOP_RIGHT ? (a = -this.width, e = 0, b = -this.width, f = this.height, c = 0, g = 0, d = 0, h = this.height) : this.mAnchor == BOTTOM_RIGHT ? (a = -this.width, e = -this.height, b = -this.width, f = 0, c = 0, g = -this.height, d = 0, h = 0) : this.mAnchor == CENTER ? (a = -this.width / 2, e = -this.height / 2, b = -this.width / 2, f = this.height / 2, c = this.width / 2, g = -this.height / 2, d = this.width / 2, h = this.height / 2) : this.mAnchor == TOP_CENTER ? (a = -this.width / 2, e = 0, b = -this.width / 2, f = this.height, c = this.width / 2, g = 0, d = this.width / 2, h = this.height) : this.mAnchor == CUSTOMIZE && (a = -this.width * this.mCustomizeAnchorX, e = -this.height * this.mCustomizeAnchorY, b = a, f = this.height * (1 - this.mCustomizeAnchorY), c = this.width * (1 - this.mCustomizeAnchorX), g = e, d = c, h = f), {
            x0: a,
            x1: b,
            x2: c,
            x3: d,
            y0: e,
            y1: f,
            y2: g,
            y3: h
        }
    },
    genOffset: function() {
        var a = [];
        return this.mAnchor == TOP_LEFT ? (a[0] = 0, a[1] = 0) : this.mAnchor == BOTTOM_LEFT ? (a[0] = 0, a[1] = -this.height) : this.mAnchor == TOP_RIGHT ? (a[0] = -this.width, a[1] = 0) : this.mAnchor == BOTTOM_RIGHT ? (a[0] = -this.width, a[1] = -this.height) : this.mAnchor == CENTER ? (a[0] = -this.width / 2, a[1] = -this.height / 2) : this.mAnchor == TOP_CENTER ? (a[0] = -this.width / 2, a[1] = 0) : this.mAnchor == CUSTOMIZE && (a[0] = -this.width * this.mCustomizeAnchorX, a[1] = -this.height * this.mCustomizeAnchorY), a
    },
    setAnchor: function(a) {
        this.mAnchor = a
    },
    setWidth: function(a) {
        this.width = a
    },
    setHeight: function(a) {
        this.height = a
    },
    setDepth: function(a) {
        this.mDepth = a
    },
    getWidth: function() {
        return this.width
    },
    getHeight: function() {
        return this.height
    },
    getDepth: function() {
        return this.mDepth
    },
    setCustomizeAnchor: function(a, b, c) {
        null == c && (c = !0), this.mCustomizeAnchorX = a, this.mCustomizeAnchorY = b, c && (this.mAnchor = CUSTOMIZE)
    },
    getAnchor: function() {
        switch (this.mAnchor) {
            case TOP_LEFT:
                return new Vector2(0, 0);
            case BOTTOM_LEFT:
                return new Vector2(0, 1);
            case TOP_RIGHT:
                return new Vector2(1, 0);
            case BOTTOM_RIGHT:
                return new Vector2(1, 1);
            case CENTER:
                return new Vector2(.5, .5);
            case TOP_CENTER:
                return new Vector2(0, .5);
            case CUSTOMIZE:
                return new Vector2(this.mCustomizeAnchorX, this.mCustomizeAnchorY);
            default:
                return new Vector2(0, 0)
        }
    },
    updateVertices: function() {
        var a = this.genVertices(),
            b = a.x0,
            c = a.x1,
            d = a.x2,
            e = a.x3,
            f = a.y0,
            g = a.y1,
            h = a.y2,
            i = a.y3,
            j = 0,
            k = this.mMainBuf.lock();
        k[j++] = b, k[j++] = f, j += 3, k[j++] = c, k[j++] = g, j += 3, k[j++] = d, k[j++] = h, j += 3, k[j++] = e, k[j++] = i, j += 3, this.mMainBuf.unlock()
    },
    setTextureCoord: function(a) {
        var b = a,
            c = 0,
            d = this.mMainBuf.lock();
        c += 3, d[c++] = b.left, d[c++] = b.top, c += 3, d[c++] = b.left, d[c++] = b.bottom, c += 3, d[c++] = b.right, d[c++] = b.top, c += 3, d[c++] = b.right, d[c++] = b.bottom, this.mMainBuf.unlock()
    },
    updateTexCoords: function(a, b, c, d) {
        if (1 === arguments.length) this.setTextureCoord(arguments[0]);
        else if (4 === arguments.length) {
            var e = new TRect;
            e.bottom = d, e.top = c, e.left = a, e.right = b, this.setTextureCoord(e)
        }
    },
    resize: function(a, b) {
        this.width = a, this.height = b, this.updateVertices()
    },
    hitTest: function(a, b) {
        var c = this.genOffset();
        a -= c[0], b -= c[1];
        var d = {};
        return a <= this.width && a >= 0 && b <= this.height && b >= 0 ? (d.interSP = new Vector3(a, b, 0), d.objDistance = 0, d) : null
    }
};
var TimeInterpolator = function() {};
TimeInterpolator.prototype.getInterpolation = function() {};
var Interpolator = function() {
    TimeInterpolator.call(this)
};
extend(Interpolator, TimeInterpolator);
var InterpolatorSet = function() {
    this.mInterpolatorArray = []
};
InterpolatorSet.prototype = {
    constructor: InterpolatorSet,
    getInterpolator: function(a) {
        return 0 == this.mInterpolatorArray.length ? 0 : a >= this.mInterpolatorArray.length ? 0 : this.mInterpolatorArray[a]
    },
    addInterpolator: function(a) {
        return a ? this.mInterpolatorArray.push(a) : void 0
    },
    destroyInterpolators: function() {
        for (var a in this.mInterpolatorArray) {
            var b = this.mInterpolatorArray.shift();
            b = null
        }
    },
    size: function() {
        return this.InterpolatorArray.length
    }
}, InterpolatorSet.getInterpolatorInstance = function(a, b) {
    var c = null;
    return b = void 0 !== b ? b : 1, a = a.toLowerCase(), c = 0 == "accelerate".localeCompare(a) ? new AccelerateInterpolator(b) : 0 == "decelerate".localeCompare(a) ? new DecelerateInterpolator(b) : 0 == "accelerate_decelerate".localeCompare(a) ? new AccelerateDecelerateInterpolator : 0 == "anticipate".localeCompare(a) ? new AnticipateInterpolator : 0 == "anticipate_overshoot".localeCompare(a) ? new AnticipateOvershootInterpolator : 0 == "bounce".localeCompare(a) ? new BounceInterpolator(b) : 0 == "cycle".localeCompare(a) ? new CycleInterpolator(1) : 0 == "overshoot".localeCompare(a) ? new OvershootInterpolator : new LinearInterpolator
};
var LinearInterpolator = function() {
    Interpolator.call(this)
};
extend(LinearInterpolator, Interpolator), LinearInterpolator.prototype.getInterpolation = function(a) {
    return a
};
var AccelerateInterpolator = function(a) {
    Interpolator.call(this), this.mFactor = void 0 !== a ? a : 1, this.mDoubleFactor = 2 * this.mFactor
};
extend(AccelerateInterpolator, Interpolator), AccelerateInterpolator.prototype.getInterpolation = function(a) {
    return 1 == this.mFactor ? a * a : Math.pow(a, this.mDoubleFactor)
};
var DecelerateInterpolator = function(a) {
    Interpolator.call(this), this.mFactor = void 0 !== a ? a : 1
};
extend(DecelerateInterpolator, Interpolator), DecelerateInterpolator.prototype.getInterpolation = function(a) {
    var b;
    return b = 1 == this.mFactor ? 1 - (1 - a) * (1 - a) : 1 - Math.pow(1 - a, 2 * this.mFactor)
};
var AccelerateDecelerateInterpolator = function() {
    Interpolator.call(this)
};
extend(AccelerateDecelerateInterpolator, Interpolator), AccelerateDecelerateInterpolator.prototype.getInterpolation = function(a) {
    return Math.cos((1 + a) * Math.PI) / 2 + .5
};
var AnticipateInterpolator = function(a) {
    Interpolator.call(this), this.mTension = void 0 !== a ? a : 2
};
extend(AnticipateInterpolator, Interpolator), AnticipateInterpolator.prototype.getInterpolation = function(a) {
    return a * a * ((this.mTension + 1) * a - this.mTension)
};
var AnticipateOvershootInterpolator = function(a, b) {
    Interpolator.call(this), b = void 0 !== b || 1.5, a = void 0 !== a ? a : 2, this.mTension = a * b
};
extend(AnticipateOvershootInterpolator, Interpolator), AnticipateOvershootInterpolator.prototype.getInterpolation = function(a) {
    return .5 > a ? .5 * this.a(2 * a, this.mTension) : .5 * (this.o(2 * a - 2, this.mTension) + 2)
}, AnticipateOvershootInterpolator.prototype.a = function(a, b) {
    return a * a * ((b + 1) * a - b)
}, AnticipateOvershootInterpolator.prototype.o = function(a, b) {
    return a * a * ((b + 1) * a + b)
};
var BounceInterpolator = function(a) {
    Interpolator.call(this), this.mFactor = void 0 !== a ? a : 1
};
extend(BounceInterpolator, Interpolator), BounceInterpolator.prototype.bounce = function(a) {
    return a * a * this.mFactor * 8
}, BounceInterpolator.prototype.getInterpolation = function(a) {
    return a *= 1.1226, .3535 > a ? this.bounce(a) : .7408 > a ? this.bounce(a - .54719) + .7 : .9644 > a ? this.bounce(a - .8526) + .9 : this.bounce(a - 1.0435) + .95
};
var CycleInterpolator = function(a) {
    Interpolator.call(this), void 0 === a ? console.error("mCycles no value.") : this.mCycles = a
};
extend(CycleInterpolator, Interpolator), CycleInterpolator.prototype.getInterpolation = function(a) {
    return Math.sin(2 * this.mCycles * Math.PI * a)
};
var OvershootInterpolator = function(a) {
    Interpolator.call(this), this.mTension = void 0 !== a ? a : 2
};
extend(OvershootInterpolator, Interpolator), OvershootInterpolator.prototype.getInterpolation = function(a) {
    return a -= 1, a * a * ((this.mTension + 1) * a + this.mTension) + 1
};
var Description = function() {
        this.type = 0, this.value = 0
    },
    Animation = function(a, b) {
        Resource.call(this), this.mRoot = a, this.mEnded = !1, this.mUpdate = !1, this.mRelative = !1, this.mIgnoreFirst = !1, this.mStarted = !1, this.mCycleFlip = !1, this.mInitialized = !1, this.mFillBefore = !0, this.mFillAfter = !1, this.mFillEnabled = !1, this.mStartTime = -1, this.mStartOffset = 0, this.mDuration = 0, this.mRepeatCount = 0, this.mRepeated = 0, this.mRepeatMode = Animation.RESTART, this.mResetMode = Animation.RESETMODE_UNIT, this.mBeFreeInterpolator = !0, this.mInterpolator = new LinearInterpolator, this.parentAniSet = null, this.mListeners = [], this.mZAdjustment = 0, this.mBackgroundColor = 0, this.mScaleFactor = 1, this.mDetachWallpaper = !1, this.mMore = !0, this.mOneMoreTime = !0, this.mVersion = 1, this.mIsActive = !1, this.mCurrLifeTime = -1, this.mStopTimeSetting = -1, this.mStopRepeatSetting = -1, this.mStartTimeSetting = -1, this.mStartRepeatSetting = -1, this.mIsOnReverseSetStartOffset = !1, this.mHasAniStarted = !1, this.mHasAniEnded = !1, this.ensureInterpolator(), this.mCanStop = void 0 !== b ? b : !0, this.mName = "", this.mBeStop = !1, this.mLastStopTime = 0
    };
extend(Animation, Resource), Animation.prototype = {
    constructor: Animation,
    isAnimationStop: function() {
        return this.mBeStop
    },
    onStopAnimation: function(a) {
        if (this.mCanStop && this.mBeStop != a)
            if (this.mBeStop = a, this.mBeStop) this.mLastStopTime = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis();
            else if (-1 != this.mStartTime && 0 != this.mLastStopTime) {
            var b = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis(),
                c = b - this.mLastStopTime;
            this.mStartTime += c
        }
    },
    setName: function(a) {
        this.mName = a
    },
    getName: function() {
        return this.mName
    },
    clone: function() {
        var a = new Animation;
        return a
    },
    reset: function() {
        this.mInitialized = !1, 2 != this.mVersion && (this.mCycleFlip = !1, this.mRepeated = 0), this.mMore = !0, this.mOneMoreTime = !0, this.mUpdate = !0
    },
    cancel: function() {
        this.mStarted && !this.mEnded && (this.fireAnimationEnd(), this.mEnded = !0), this.mStartTime = -1, this.mMore = !1, this.mOneMoreTime = !1
    },
    detach: function() {
        this.mStarted && !this.mEnded && (this.mEnded = !0, this.fireAnimationEnd())
    },
    isInitialized: function() {
        return this.mInitialized
    },
    initialize: function(a, b, c, d) {
        this.reset(), this.mInitialized = !0
    },
    setInterpolator: function(a, b) {
        0 != this.mInterpolator && this.mBeFreeInterpolator && (this.mInterpolator = null), this.mInterpolator = a, this.mBeFreeInterpolator = b
    },
    setStartOffset: function(a) {
        this.mStartOffset = a
    },
    setDuration: function(a) {
        this.mDuration = a
    },
    restrictDuration: function(a) {
        if (this.mStartOffset > a) return this.mStartOffset = a, this.mDuration = 0, void(this.mRepeatCount = 0);
        var b = this.mDuration + this.mStartOffset;
        return b > a && (this.mDuration = a - this.mStartOffset, b = a), this.mDuration <= 0 ? (this.mDuration = 0, void(this.mRepeatCount = 0)) : void((this.mRepeatCount < 0 || this.mRepeatCount > a || b * this.mRepeatCount > a) && (this.mRepeatCount = a / b - 1, this.mRepeatCount < 0 && (this.mRepeatCount = 0)))
    },
    scaleCurrentDuration: function(a) {
        this.mDuration = this.mDuration * a, this.mStartOffset = this.mStartOffset * a
    },
    setStartTime: function(a) {
        this.mStartTime = a, this.mStarted = !1, this.mEnded = !1, this.mCycleFlip = !1, this.mRepeated = 0, this.mMore = !0
    },
    isRunning: function() {
        return !this.hasStarted() || this.hasStarted() && this.isAnimationStop() ? !1 : !0
    },
    run: function() {
        this.onStopAnimation(!1), this.startAnimation()
    },
    stop: function() {
        this.onStopAnimation(!0)
    },
    start: function() {
        this.setStartTime(-1)
    },
    startNow: function() {
        this.setStartTime(this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis())
    },
    setRepeatMode: function(a) {
        var b = a;
        "number" == typeof b ? this.mRepeatMode = a : (a = a.toLowerCase(), 0 == "reverse".localeCompare(a) ? this.mRepeatMode = Animation.REVERSE : this.mRepeatMode = Animation.RESTART)
    },
    setRepeatCount: function(a) {
        0 > a && (a = Animation.INFINITE), this.mRepeatCount = a
    },
    setResetMode: function(a) {
        this.mResetMode = a
    },
    isFillEnabled: function() {
        return this.mFillEnabled
    },
    setFillEnabled: function(a) {
        this.mFillEnabled = a
    },
    setFillBefore: function(a) {
        this.mFillBefore = a
    },
    setFillAfter: function(a) {
        this.mFillAfter = a
    },
    setZAdjustment: function(a) {
        this.mZAdjustment = a
    },
    setBakgroundColor: function(a) {
        this.mBackgroundColor = a
    },
    preTransform: function() {},
    getScaleFactor: function() {
        return this.mScaleFactor
    },
    setDetachWallpaper: function(a) {
        this.mDetachWallpaper = a
    },
    getInterpolator: function() {
        return this.mInterpolator
    },
    getStartTime: function() {
        return this.mStartTime
    },
    getDuration: function() {
        return this.mDuration
    },
    getStartOffset: function() {
        return this.mStartOffset
    },
    getRepeatMode: function() {
        return this.mRepeatMode
    },
    getRepeatCount: function() {
        return this.mRepeatCount
    },
    getFillBefore: function() {
        return this.mFillBefore
    },
    getFillAfter: function() {
        return this.mFillAfter
    },
    getZAdjustment: function() {
        return this.mZAdjustment
    },
    getBakgroundColor: function() {
        return this.mBackgroundColor
    },
    getDetachWallpaper: function() {
        return this.mDetachWallpaper
    },
    willChangeTransformationMatrix: function() {
        return !0
    },
    willChangeBounds: function() {
        return !0
    },
    ensureInterpolator: function() {
        null == this.mInterpolator && (this.mInterpolator = new AccelerateDecelerateInterpolator)
    },
    computeDurationHint: function() {
        return (this.getStartOffset() + this.getDuration()) * (this.getRepeatCount() + 1)
    },
    getTransformation: function(a, b) {
        if (void 0 !== b && (this.mScaleFactor = b), 1 == this.mVersion) {
            this.preTransform(), -1 == this.mStartTime && (this.mStartTime = a);
            var c, d = this.getStartOffset(),
                e = this.mDuration;
            0 != e ? (this.mRepeated > 0 && (d = 0), c = (a - (this.mStartTime + d)) / e) : c = a < this.mStartTime ? 0 : 1;
            var f = c >= 1;
            if (this.mMore = !f, c > 1 && (c = 1), this.mFillEnabled || (c = Math.max(Math.min(c, 1), 0)), (c >= 0 || this.mFillBefore) && (1 >= c || this.mFillAfter)) {
                if (!this.mStarted && (this.fireAnimationStart(), this.mStarted = !0, this.mIgnoreFirst)) return this.mMore;
                var g = c;
                this.mFillEnabled && (c = Math.max(Math.min(c, 1), 0)), this.mCycleFlip && (c = 1 - c);
                var h = this.mInterpolator.getInterpolation(c);
                this.applyTransformation(h), this.fireAnimationProgress(g)
            }
            return f && (this.mRepeatCount == this.mRepeated ? this.mEnded || (this.mEnded = !0, this.fireAnimationEnd()) : (this.mRepeatCount > 0 && this.mRepeated++, this.mRepeatMode == Animation.REVERSE && (this.mCycleFlip = !this.mCycleFlip), this.mStartTime = -1, this.mMore = !0, this.fireAnimationRepeat())), !this.mMore && this.mOneMoreTime ? (this.mOneMoreTime = !1, !0) : this.mMore
        }
        this.preTransform(), -1 == this.mStartTime && (this.mStartTime = a);
        var c, d = this.getStartOffset(),
            e = this.mDuration,
            f = !1;
        if (0 == e) return !1;
        if (null == this.parentAniSet) {
            this.mRepeated > 0 && (d = 0), c = (a - (this.mStartTime + d)) / e;
            var i = a - this.mStartTime;
            this.mCurrLifeTime = i <= this.getStartOffset() ? i : this.getStartOffset() + this.getDuration() * c, f = c >= 1, c > 1 && (c = 1)
        }
        if (null != this.parentAniSet && !this.parentAniSet.mCycleFlip) {
            var j = a - this.parentAniSet.mStartTime,
                k = -1;
            k = j - this.getStartOffset() - this.getDuration() * this.mRepeated, c = k / e, f = c >= 1, c > 1 && (c = 1), 0 > k ? this.mCurrLifeTime = j : this.mCurrLifeTime = k > this.getDuration() ? this.getStartOffset() + this.getDuration() : this.getStartOffset() + k
        }
        if (null != this.parentAniSet && this.parentAniSet.mCycleFlip) {
            var j = a - this.parentAniSet.mStartTime,
                k = -1;
            k = j - (this.parentAniSet.mMaxDuration - e * (this.mRepeatCount + 1) - this.getStartOffset()) - e * this.mRepeated, c = 1 - k / e, f = c >= 1, c > 1 && (c = 1), 0 > k ? (this.mIsOnReverseSetStartOffset = !0, this.mCurrLifeTime = 0) : (this.mIsOnReverseSetStartOffset = !1, this.mCurrLifeTime = this.getStartOffset() + k), f = k > e ? !0 : !1
        }
        if (this.mStarted || this.mHasAniStarted || (this.mHasAniStarted = !0, this.mHasAniEnded = !1), c >= 0 && 1 >= c) {
            !this.mStarted && this.mHasAniStarted && (this.mStarted = !0, this.fireAnimationStart()), this.mCycleFlip && (c = 1 - c), c = Math.max(Math.min(c, 1), 0);
            var h = this.mInterpolator.getInterpolation(c);
            this.applyTransformation(h), this.fireAnimationProgress(c)
        }
        return (this.mStartRepeatSetting < this.mStopRepeatSetting || this.mStartRepeatSetting == this.mStopRepeatSetting && this.mStartTimeSetting <= this.mStopTimeSetting) && this.mStopTimeSetting <= this.mCurrLifeTime && this.mStopRepeatSetting == this.mRepeated && (this.mCanStop = !0, this.mBeStop = !0, this.mStopTimeSetting = -1, this.mStopRepeatSetting = -1, this.mEnded = !0, this.mHasAniStarted = !1, this.mHasAniEnded = !0, this.fireAnimationEnd()), f && (this.mRepeatCount == this.mRepeated ? (this.mCanStop = !0, this.mBeStop = !0, this.mEnded || (this.mEnded = !0, this.mHasAniStarted = !1, this.mHasAniEnded = !0, this.fireAnimationEnd())) : (this.mRepeatCount > 0 && this.mRepeated++, this.mRepeatMode == Animation.REVERSE && (this.mCycleFlip = !this.mCycleFlip), this.mStartTime = -1, this.fireAnimationRepeat())), !this.mMore && this.mOneMoreTime ? (this.mOneMoreTime = !1, !0) : this.mMore
    },
    fireAnimationStart: function() {
        for (var a = 0; a < this.mListeners.length; a++) null != this.mListeners[a].OnAnimationStart && this.mListeners[a].OnAnimationStart(this)
    },
    fireAnimationRepeat: function() {
        for (var a = 0; a < this.mListeners.length; a++) null != this.mListeners[a].OnAnimationRepeat && this.mListeners[a].OnAnimationRepeat(this)
    },
    fireAnimationEnd: function() {
        for (var a = 0; a < this.mListeners.length; a++) null != this.mListeners[a].OnAnimationEnd && this.mListeners[a].OnAnimationEnd(this)
    },
    fireAnimationProgress: function(a) {
        for (var b = 0; b < this.mListeners.length; b++) null != this.mListeners[b].OnAnimationProgress && this.mListeners[b].OnAnimationProgress(this, a)
    },
    updateAnimation: function() {
        if (!(!this.mUpdate || this.mCanStop && this.mBeStop)) {
            var a = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis(),
                b = this.isInitialized();
            b || this.initialize(0, 0, 100, 100);
            this.getTransformation(a, 1)
        }
    },
    startAnimation: function() {
        1 == this.mVersion ? (this.setStartTime(Animation.START_ON_FIRST_FRAME), this.getStartTime() == Animation.START_ON_FIRST_FRAME && this.setStartTime(this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis()), this.reset()) : 2 == this.mVersion && this.startPlay(0, 0)
    },
    hasStarted: function() {
        return this.mStarted
    },
    hasEnded: function() {
        return this.mEnded
    },
    applyTransformation: function(a) {},
    resolveSize: function(a, b, c, d) {
        switch (a) {
            case Animation.ABSOLUTE:
                return b;
            case Animation.RELATIVE_TO_SELF:
                return c * b;
            case Animation.RELATIVE_TO_PARENT:
                return d * b;
            default:
                return b
        }
    },
    initializeInvalidateRegion: function(a, b, c, d) {},
    hasAlpha: function() {
        return !1
    },
    beReverse: function() {
        return this.mCycleFlip
    },
    setRelavie: function(a) {
        this.mRelative = a
    },
    setIgnore: function(a) {
        this.mIgnoreFirst = a
    },
    onResize: function() {},
    startPlay: function(a, b) {
        if (this.mHasAniStarted = !1, this.mHasAniEnded = !1, 0 > a || a > this.getStartOffset() + this.getDuration()) return !1;
        if (0 > b || b > this.mRepeatCount && -1 != this.mRepeatCount) return !1;
        this.mRepeated = b, this.mBeStop = !1, this.mCanStop = !0, this.mUpdate = !0;
        var c = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis();
        return this.mStartRepeatSetting = b, this.mStartTimeSetting = a, this.mStartTime = c - a, this.mStarted = !1, this.mEnded = !1, this.mCurrLifeTime = a, this.mRepeatMode == Animation.REVERSE ? 0 == b ? this.mCycleFlip = !1 : this.mCycleFlip = b % 2 == 0 ? !1 : !0 : this.mCycleFlip = !1, this.mMore = !0, !0
    },
    stopPlay: function(a, b) {
        if (0 > a || a > this.getStartOffset() + this.getDuration()) return !1;
        if (0 > b || b > this.mRepeatCount && -1 != this.mRepeatCount) return !1;
        this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis();
        return -1 == this.getCurrentRepeats() || b > this.getCurrentRepeats() || b == this.getCurrentRepeats() && a >= this.getCurrentAnimationLifeTime() ? (this.mStopTimeSetting = a, this.mStopRepeatSetting = b, !0) : !1
    },
    pause: function() {
        !this.mHasAniEnded && this.mHasAniStarted && (this.mCanStop = !0, 1 != this.mBeStop && (this.mBeStop = !0, this.mLastStopTime = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis()))
    },
    resume: function() {
        if (!this.mHasAniEnded && this.mHasAniStarted && (this.mCanStop = !0, 0 != this.mBeStop && (this.mBeStop = !1, -1 != this.mStartTime && 0 != this.mLastStopTime))) {
            var a = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis(),
                b = a - this.mLastStopTime;
            this.mStartTime += b
        }
    },
    getCurrentAnimationLifeTime: function() {
        return this.mCurrLifeTime
    },
    isActive: function() {
        return !(this.mBeStop || this.mIsOnReverseSetStartOffset || !this.mHasAniEnded && !this.mHasAniStarted)
    },
    getCurrentRepeats: function() {
        return this.mRepeated
    },
    hasAnimationStarted: function() {
        return this.mHasAniStarted
    },
    hasAnimationEnded: function() {
        return this.mHasAniEnded
    },
    setVersion: function(a) {
        this.mVersion = a, 2 == a && (null == this.parentAniSet ? this.mBeStop = !0 : null != this.parentAniSet && 2 == this.parentAniSet.mVersion && 1 == this.parentAniSet.mBeStop && (this.mBeStop = !0))
    },
    _isAnimationStop: function() {
        return this.mBeStop
    },
    _onStopAnimation: function(a) {
        if (this.mCanStop && this.mBeStop != a)
            if (this.mBeStop = a, this.mBeStop) this.mLastStopTime = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis();
            else if (-1 != this.mStartTime && 0 != this.mLastStopTime) {
            var b = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis(),
                c = b - this.mLastStopTime;
            this.mStartTime += c
        }
    },
    _setName: function(a) {
        this.mName = a
    },
    _getName: function() {
        return this.mName
    },
    _clone: function() {
        var a = new Animation;
        return a
    },
    _reset: function() {
        this.mInitialized = !1, 2 != this.mVersion && (this.mCycleFlip = !1, this.mRepeated = 0), this.mMore = !0, this.mOneMoreTime = !0, this.mUpdate = !0
    },
    _cancel: function() {
        this.mStarted && !this.mEnded && (this.fireAnimationEnd(), this.mEnded = !0), this.mStartTime = -1, this.mMore = !1, this.mOneMoreTime = !1
    },
    _detach: function() {
        this.mStarted && !this.mEnded && (this.mEnded = !0, this.fireAnimationEnd())
    },
    _isInitialized: function() {
        return this.mInitialized
    },
    _initialize: function(a, b, c, d) {
        this.reset(), this.mInitialized = !0
    },
    _setInterpolator: function(a, b) {
        null != this.mInterpolator && this.mBeFreeInterpolator && (this.mInterpolator = null), this.mInterpolator = a, this.mBeFreeInterpolator = b
    },
    _setStartOffset: function(a) {
        this.mStartOffset = a
    },
    _setDuration: function(a) {
        this.mDuration = a
    },
    _restrictDuration: function(a) {
        if (this.mStartOffset > a) return this.mStartOffset = a, this.mDuration = 0, void(this.mRepeatCount = 0);
        var b = this.mDuration + this.mStartOffset;
        return b > a && (this.mDuration = a - this.mStartOffset, b = a), this.mDuration <= 0 ? (this.mDuration = 0, void(this.mRepeatCount = 0)) : void((this.mRepeatCount < 0 || this.mRepeatCount > a || b * this.mRepeatCount > a) && (this.mRepeatCount = a / b - 1, this.mRepeatCount < 0 && (this.mRepeatCount = 0)))
    },
    _scaleCurrentDuration: function(a) {
        this.mDuration = this.mDuration * a, this.mStartOffset = this.mStartOffset * a
    },
    _setStartTime: function(a) {
        this.mStartTime = a, this.mStarted = !1, this.mEnded = !1, this.mCycleFlip = !1, this.mRepeated = 0, this.mMore = !0
    },
    _isRunning: function() {
        return !this.hasStarted() || this.hasStarted() && this.isAnimationStop() ? !1 : !0
    },
    _run: function() {
        this.onStopAnimation(!1), this.startAnimation()
    },
    _stop: function() {
        this.onStopAnimation(!0)
    },
    _start: function() {
        this.setStartTime(-1)
    },
    _startNow: function() {
        this.setStartTime(this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis())
    },
    _setRepeatMode: function(a) {
        var b = a;
        "number" == typeof b ? this.mRepeatMode = parseInt(a) : (a = a.toLowerCase(), 0 == "reverse".localeCompare(a) ? this.mRepeatMode = Animation.REVERSE : this.mRepeatMode = Animation.RESTART)
    },
    _setRepeatCount: function(a) {
        0 > a && (a = Animation.INFINITE), this.mRepeatCount = a
    },
    _setResetMode: function(a) {
        this.mResetMode = a
    },
    _isFillEnabled: function() {
        return this.mFillEnabled
    },
    _setFillEnabled: function(a) {
        this.mFillEnabled = a
    },
    _setFillBefore: function(a) {
        this.mFillBefore = a
    },
    _setFillAfter: function(a) {
        this.mFillAfter = a
    },
    _setZAdjustment: function(a) {
        this.mZAdjustment = a
    },
    _setBakgroundColor: function(a) {
        this.mBackgroundColor = a
    },
    _preTransform: function() {},
    _getScaleFactor: function() {
        return this.mScaleFactor
    },
    _setDetachWallpaper: function(a) {
        this.mDetachWallpaper = a
    },
    _getInterpolator: function() {
        return this.mInterpolator
    },
    _getStartTime: function() {
        return this.mStartTime
    },
    _getDuration: function() {
        return this.mDuration
    },
    _getStartOffset: function() {
        return this.mStartOffset
    },
    _getRepeatMode: function() {
        return this.mRepeatMode
    },
    _getRepeatCount: function() {
        return this.mRepeatCount
    },
    _getFillBefore: function() {
        return this.mFillBefore
    },
    _getFillAfter: function() {
        return this.mFillAfter
    },
    _getZAdjustment: function() {
        return this.mZAdjustment
    },
    _getBakgroundColor: function() {
        return this.mBackgroundColor
    },
    _getDetachWallpaper: function() {
        return this.mDetachWallpaper
    },
    _willChangeTransformationMatrix: function() {
        return !0
    },
    _willChangeBounds: function() {
        return !0
    },
    _ensureInterpolator: function() {
        null == this.mInterpolator && (this.mInterpolator = new AccelerateDecelerateInterpolator)
    },
    _computeDurationHint: function() {
        return (this.getStartOffset() + this.getDuration()) * (this.getRepeatCount() + 1)
    },
    _getTransformation: function(a, b) {
        if (void 0 !== b && (this.mScaleFactor = b), 1 == this.mVersion) {
            this.preTransform(), -1 == this.mStartTime && (this.mStartTime = a);
            var c, d = this.getStartOffset(),
                e = this.mDuration;
            0 != e ? (this.mRepeated > 0 && (d = 0), c = (a - (this.mStartTime + d)) / e) : c = a < this.mStartTime ? 0 : 1;
            var f = c >= 1;
            if (this.mMore = !f, c > 1 && (c = 1), this.mFillEnabled || (c = Math.max(Math.min(c, 1), 0)), (c >= 0 || this.mFillBefore) && (1 >= c || this.mFillAfter)) {
                if (!this.mStarted && (this.fireAnimationStart(), this.mStarted = !0, this.mIgnoreFirst)) return this.mMore;
                var g = c;
                this.mFillEnabled && (c = Math.max(Math.min(c, 1), 0)), this.mCycleFlip && (c = 1 - c);
                var h = this.mInterpolator.getInterpolation(c);
                this.applyTransformation(h), this.fireAnimationProgress(g)
            }
            return f && (this.mRepeatCount == this.mRepeated ? this.mEnded || (this.mEnded = !0, this.fireAnimationEnd()) : (this.mRepeatCount > 0 && this.mRepeated++, this.mRepeatMode == Animation.REVERSE && (this.mCycleFlip = !this.mCycleFlip), this.mStartTime = -1, this.mMore = !0, this.fireAnimationRepeat())), !this.mMore && this.mOneMoreTime ? (this.mOneMoreTime = !1, !0) : this.mMore
        }
        this.preTransform(), -1 == this.mStartTime && (this.mStartTime = a);
        var c, d = this.getStartOffset(),
            e = this.mDuration,
            f = !1;
        if (0 == e) return !1;
        if (null == this.parentAniSet) {
            this.mRepeated > 0 && (d = 0), c = (a - (this.mStartTime + d)) / e;
            var i = a - this.mStartTime;
            this.mCurrLifeTime = i <= this.getStartOffset() ? i : this.getStartOffset() + this.getDuration() * c, f = c >= 1, c > 1 && (c = 1)
        }
        if (null != this.parentAniSet && !this.parentAniSet.mCycleFlip) {
            var j = a - this.parentAniSet.mStartTime,
                k = -1;
            k = j - this.getStartOffset() - this.getDuration() * this.mRepeated, c = k / e, f = c >= 1, c > 1 && (c = 1), 0 > k ? this.mCurrLifeTime = j : this.mCurrLifeTime = k > this.getDuration() ? this.getStartOffset() + this.getDuration() : this.getStartOffset() + k
        }
        if (null != this.parentAniSet && this.parentAniSet.mCycleFlip) {
            var j = a - this.parentAniSet.mStartTime,
                k = -1;
            k = j - (this.parentAniSet.mMaxDuration - e * (this.mRepeatCount + 1) - this.getStartOffset()) - e * this.mRepeated, c = 1 - k / e, f = c >= 1, c > 1 && (c = 1), 0 > k ? (this.mIsOnReverseSetStartOffset = !0, this.mCurrLifeTime = 0) : (this.mIsOnReverseSetStartOffset = !1, this.mCurrLifeTime = this.getStartOffset() + k), f = k > e ? !0 : !1
        }
        if (this.mStarted || this.mHasAniStarted || (this.mHasAniStarted = !0, this.mHasAniEnded = !1), c >= 0 && 1 >= c) {
            !this.mStarted && this.mHasAniStarted && (this.mStarted = !0, this.fireAnimationStart());
            var g = c;
            this.mCycleFlip && (c = 1 - c), c = Math.max(Math.min(c, 1), 0);
            var h = this.mInterpolator.getInterpolation(c);
            this.applyTransformation(h), this.fireAnimationProgress(c)
        }
        return (this.mStartRepeatSetting < this.mStopRepeatSetting || this.mStartRepeatSetting == this.mStopRepeatSetting && this.mStartTimeSetting <= this.mStopTimeSetting) && this.mStopTimeSetting <= this.mCurrLifeTime && this.mStopRepeatSetting == this.mRepeated && (this.mCanStop = !0, this.mBeStop = !0, this.mStopTimeSetting = -1, this.mStopRepeatSetting = -1, this.mEnded = !0, this.mHasAniStarted = !1, this.mHasAniEnded = !0, this.fireAnimationEnd()), f && (this.mRepeatCount == this.mRepeated ? (this.mCanStop = !0, this.mBeStop = !0, this.mEnded || (this.mEnded = !0, this.mHasAniStarted = !1, this.mHasAniEnded = !0, this.fireAnimationEnd())) : (this.mRepeatCount > 0 && this.mRepeated++, this.mRepeatMode == Animation.REVERSE && (this.mCycleFlip = !this.mCycleFlip), this.mStartTime = -1, this.fireAnimationRepeat())), !this.mMore && this.mOneMoreTime ? (this.mOneMoreTime = !1, !0) : this.mMore
    },
    _updateAnimation: function() {
        if (!(!this.mUpdate || this.mCanStop && this.mBeStop)) {
            var a = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis(),
                b = this.isInitialized();
            b || this.initialize(0, 0, 100, 100);
            this.getTransformation(a, 1)
        }
    },
    _startAnimation: function() {
        1 == this.mVersion ? (this.setStartTime(Animation.START_ON_FIRST_FRAME), this.getStartTime() == Animation.START_ON_FIRST_FRAME && this.setStartTime(this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis()), this.reset()) : 2 == this.mVersion && this.startPlay(0, 0)
    },
    _hasStarted: function() {
        return this.mStarted
    },
    _hasEnded: function() {
        return this.mEnded
    },
    _applyTransformation: function(a) {},
    _resolveSize: function(a, b, c, d) {
        switch (a) {
            case Animation.ABSOLUTE:
                return b;
            case Animation.RELATIVE_TO_SELF:
                return c * b;
            case Animation.RELATIVE_TO_PARENT:
                return d * b;
            default:
                return b
        }
    },
    _initializeInvalidateRegion: function(a, b, c, d) {},
    _hasAlpha: function() {
        return !1
    },
    _beReverse: function() {
        return this.mCycleFlip
    },
    _setRelavie: function(a) {
        this.mRelative = a
    },
    _setIgnore: function(a) {
        this.mIgnoreFirst = a
    },
    _onResize: function() {},
    _startPlay: function(a, b) {
        if (this.mHasAniStarted = !1, this.mHasAniEnded = !1, 0 > a || a > this.getStartOffset() + this.getDuration()) return !1;
        if (0 > b || b > this.mRepeatCount && -1 != this.mRepeatCount) return !1;
        this.mRepeated = b, this.mBeStop = !1, this.mCanStop = !0, this.mUpdate = !0;
        var c = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis();
        return this.mStartRepeatSetting = b, this.mStartTimeSetting = a, this.mStartTime = c - a, this.mStarted = !1, this.mEnded = !1, this.mCurrLifeTime = a, this.mRepeatMode == Animation.REVERSE ? 0 == b ? this.mCycleFlip = !1 : this.mCycleFlip = b % 2 == 0 ? !1 : !0 : this.mCycleFlip = !1, this.mMore = !0, !0
    },
    _stopPlay: function(a, b) {
        if (0 > a || a > this.getStartOffset() + this.getDuration()) return !1;
        if (0 > b || b > this.mRepeatCount && -1 != this.mRepeatCount) return !1;
        this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis();
        return -1 == this.getCurrentRepeats() || b > this.getCurrentRepeats() || b == this.getCurrentRepeats() && a >= this.getCurrentAnimationLifeTime() ? (this.mStopTimeSetting = a, this.mStopRepeatSetting = b, !0) : !1
    },
    _pause: function() {
        !this.mHasAniEnded && this.mHasAniStarted && (this.mCanStop = !0, 1 != this.mBeStop && (this.mBeStop = !0, this.mLastStopTime = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis()))
    },
    _resume: function() {
        if (!this.mHasAniEnded && this.mHasAniStarted && (this.mCanStop = !0, 0 != this.mBeStop && (this.mBeStop = !1, -1 != this.mStartTime && 0 != this.mLastStopTime))) {
            var a = this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis(),
                b = a - this.mLastStopTime;
            this.mStartTime += b
        }
    },
    _getCurrentAnimationLifeTime: function() {
        return this.mCurrLifeTime
    },
    _isActive: function() {
        return !(this.mBeStop || this.mIsOnReverseSetStartOffset || !this.mHasAniEnded && !this.mHasAniStarted)
    },
    _getCurrentRepeats: function() {
        return this.mRepeated
    },
    _hasAnimationStarted: function() {
        return this.mHasAniStarted
    },
    _hasAnimationEnded: function() {
        return this.mHasAniEnded
    },
    _setVersion: function(a) {
        this.mVersion = a, 2 == a && (null == this.parentAniSet ? this.mBeStop = !0 : null != this.parentAniSet && 2 == this.parentAniSet.mVersion && 1 == this.parentAniSet.mBeStop && (this.mBeStop = !0))
    },
    registerOnAnimationStartHandler: function(a) {
        this.mListener.mAnimationStartListener.push(a)
    },
    registerOnAnimationEndHandler: function(a) {
        this.mListener.mAnimationEndListener.push(a)
    },
    registerOnAnimationProgressHandler: function(a) {
        this.mListener.mAnimationProgressListener.push(a)
    },
    registerOnAnimationRepeateHandler: function(a) {
        this.mListener.mAnimationRepeatListener.push(a)
    },
    setAnimationDelegate: function(a) {
        for (var b = 0; b < this.mListeners.length;) {
            if (this.mListeners[b] == a) return;
            b++
        }
        this.mListeners.push(a)
    },
    removeAnimationDelegate: function(a) {
        for (var b = 0; b < this.mListeners.length;) {
            if (this.mListeners[b] == a) return void this.mListeners.splice(b, 1);
            b++
        }
    },
    speedUp: function(a, b) {
        var c = this.getDuration(),
            d = c;
        d = b ? b / a : c / a;
        var e = this.getCurrentAnimationLifeTime() / c * d;
        this.setDuration(d), this.startPlay(e, this.getCurrentRepeats())
    }
}, Animation.E3D_INFINITE = -1, Animation.INFINITE = -1, Animation.RESTART = 1, Animation.REVERSE = 2, Animation.START_ON_FIRST_FRAME = -1, Animation.E3D_ABSOLUTE = 0, Animation.ABSOLUTE = 0, Animation.RELATIVE_TO_SELF = 1, Animation.RELATIVE_TO_PARENT = 2, Animation.RESETMODE_NONE = 0, Animation.RESETMODE_ORIGINAL = 1, Animation.RESETMODE_UNIT = 2, Animation.ZORDER_NORMAL = 0, Animation.ZORDER_TOP = 1, Animation.ZORDER_BOTTOM = -1;
var ValueAnimation = function(a, b, c, d, e, f) {
    f = void 0 === f ? !0 : f, Animation.call(this, a, f), this.mFromIntValue = b, this.mToIntValue = c, this.mFromFloatValue = d, this.mToFloatValue = e, this.mEnableIntValueAnimation = !0, this.mEnableFloatValueAnimation = !0, this.mIntValue = -1, this.mFloatValue = -1
};
extend(ValueAnimation, Animation), ValueAnimation.prototype._init = function() {
    this.mEnableFloatValueAnimation = !1, this.mEnableIntValueAnimation = !1, this.mIntValue = this.mFromIntValue, this.mFloatValue = this.mFromFloatValue
}, ValueAnimation.prototype.enableIntValueAnimation = function(a, b, c) {
    this.mEnableIntValueAnimation != a && (this.mEnableIntValueAnimation = a, a && (this.mFromIntValue = b, this.mToIntValue = c))
}, ValueAnimation.prototype.enableFloatValueAnimation = function(a, b, c) {
    this.mEnableFloatValueAnimation != a && (this.mEnableIntValueAnimation = a, a && (this.mFromFloatValue = b, this.mToFloatValue = c))
}, ValueAnimation.prototype.setFromIntValue = function(a) {
    this.mFromIntValue = a, this.mEnableIntValueAnimation = !0, this.mIntValue = this.mFromIntValue
}, ValueAnimation.prototype.setToIntValue = function(a) {
    this.mToIntValue = a, this.mEnableIntValueAnimation = !0
}, ValueAnimation.prototype.setFromFloatValue = function(a) {
    this.mFromFloatValue = a, this.mEnableFloatValueAnimation = !0, this.mFloatValue = this.mFromFloatValue
}, ValueAnimation.prototype.setToFloatValue = function(a) {
    this.mToFloatValue = a, this.mEnableFloatValueAnimation = !0
}, ValueAnimation.prototype.resetIntValueAnimation = function(a, b) {
    this.mFromIntValue = a, this.mToIntValue = b, this.mEnableIntValueAnimation = !0, this.mIntValue = this.mFromIntValue
}, ValueAnimation.prototype.resetFloatValueAnimation = function(a, b) {
    this.mFromFloatValue = a, this.mToFloatValue = b, this.mEnableFloatValueAnimation = !0, this.mFloatValue = this.mFromFloatValue
}, ValueAnimation.prototype.applyTransformation = function(a) {
    this.mEnableIntValueAnimation && (this.mFromIntValue != this.mToIntValue ? this.mIntValue = parseInt(this.mFromIntValue + (this.mToIntValue - this.mFromIntValue) * a) : this.mIntValue = this.mFromIntValue), this.mEnableFloatValueAnimation && (this.mFromFloatValue != this.mToFloatValue ? this.mFloatValue = this.mFromFloatValue + (this.mToFloatValue - this.mFromFloatValue) * a : this.mFloatValue = this.mFromFloatValue)
}, ValueAnimation.prototype.getIntValue = function() {
    return this.mIntValue
}, ValueAnimation.prototype.getFloatValue = function() {
    return this.mFloatValue
};
var AnimationSet = function(a, b, c) {
    Animation.call(this, a, c), this.setFlag(AnimationSet.PROPERTY_SHARE_INTERPOLATOR_MASK, b), this.mStartTime = 0, this.mFlags = 0, this.mHasAlpha = !1, this.mLastEnd = !0, this.mDirty = !0, this.mStoredOffsets = 0, this.mMaxDuration = 0, this.mIsReverse = 0, this.mAnimations = []
};
extend(AnimationSet, Animation), AnimationSet.prototype.clone = function() {}, AnimationSet.prototype.enableShareInterpolator = function(a) {
    this.setFlag(AnimationSet.PROPERTY_SHARE_INTERPOLATOR_MASK, a)
}, AnimationSet.prototype.setFlag = function(a, b) {
    b ? this.mFlags |= a : this.mFlags &= ~a, this.mStartTime = 0, this.mFlags = 0, this.mStoredOffsets = 0, this.mMaxDuration = 0, this.mIsReverse = 0, this.mAnimations = []
}, AnimationSet.prototype.setFillAfter = function(a) {
    this.mFlags |= AnimationSet.PROPERTY_FILL_AFTER_MASK, this._setFillAfter(a)
}, AnimationSet.prototype.setFillBefore = function(a) {
    this.mFlags |= AnimationSet.PROPERTY_FILL_BEFORE_MASK, this._setFillBefore(a)
}, AnimationSet.prototype.setRepeatMode = function(a) {
    this.mFlags |= AnimationSet.PROPERTY_REPEAT_MODE_MASK, this._setRepeatMode(a)
}, AnimationSet.prototype.setRepeatMode = function(a) {
    this.mFlags |= AnimationSet.PROPERTY_REPEAT_MODE_MASK, this._setRepeatMode(a)
}, AnimationSet.prototype.setStartOffset = function(a) {
    this.mFlags |= AnimationSet.PROPERTY_START_OFFSET_MASK, this._setStartOffset(a)
}, AnimationSet.prototype.hasAlpha = function() {
    if (this.mDirty) {
        this.mDirty = !1, this.mHasAlpha = !1;
        for (var a in this.mAnimations) {
            var b = this.mAnimations[a];
            if (b.hasAlpha()) {
                this.mHasAlpha = !0;
                break
            }
        }
    }
    return this.mHasAlpha
}, AnimationSet.prototype.setDuration = function(a) {
    this.mFlags |= AnimationSet.PROPERTY_DURATION_MASK, this._setDuration(a), this.mLastEnd = this.mStartOffset + this.mDuration
}, AnimationSet.prototype.addAnimation = function(a) {
    this.mAnimations.push(a);
    var b = 0 == (this.mFlags & AnimationSet.PROPERTY_MORPH_MATRIX_MASK);
    b && a.willChangeTransformationMatrix() && (this.mFlags |= AnimationSet.PROPERTY_MORPH_MATRIX_MASK);
    var c = 0 == (this.mFlags & AnimationSet.PROPERTY_CHANGE_BOUNDS_MASK);
    c && a.willChangeBounds() && (this.mFlags |= AnimationSet.PROPERTY_CHANGE_BOUNDS_MASK), (this.mFlags & AnimationSet.PROPERTY_DURATION_MASK) == AnimationSet.PROPERTY_DURATION_MASK ? this.mLastEnd = this.mStartOffset + this.mDuration : 1 == this.mAnimations.length ? (this.mDuration = a.getStartOffset() + a.getDuration(), this.mLastEnd = this.mStartOffset + this.mDuration) : (this.mLastEnd = Math.max(this.mLastEnd, a.getStartOffset() + a.getDuration()), this.mDuration = this.mLastEnd - this.mStartOffset), a.parentAniSet = this, this.mDirty = !0
}, AnimationSet.prototype.startPlay = function(a, b) {
    this._startPlay(a, b);
    for (var c in this.mAnimations) {
        var d = this.mAnimations[c];
        d.setStartTime(0), d.mBeStop = !1
    }
    return !0
}, AnimationSet.prototype.setStartTime = function(a) {
    this._setStartTime(a);
    for (var b in this.mAnimations) {
        var c = this.mAnimations[b];
        c.setStartTime(a)
    }
}, AnimationSet.prototype.getStartTime = function() {
    var a = 0x8000000000000000;
    for (var b in this.mAnimations) {
        var c = this.mAnimations[b];
        a = Math.min(a, c.getStartTime())
    }
    return a
}, AnimationSet.prototype.restrictDuration = function(a) {
    this._restrictDuration(a);
    for (var b in this.mAnimations) {
        var c = this.mAnimations[b];
        c.restrictDuration(a)
    }
}, AnimationSet.prototype.getDuration = function() {
    var a = 0,
        b = (this.mFlags & AnimationSet.PROPERTY_DURATION_MASK) == AnimationSet.PROPERTY_DURATION_MASK;
    if (b) a = this.mDuration;
    else
        for (var c in this.mAnimations) {
            var d = this.mAnimations[c];
            a = Math.max(a, d.getDuration() * (d.mRepeatCount + 1) + d.getStartOffset())
        }
    return a
}, AnimationSet.prototype.computeDurationHint = function() {
    var a = 0;
    for (var b in this.mAnimations) {
        var c = this.mAnimations[b],
            d = c.computeDurationHint();
        d > a && (a = d)
    }
    return a
}, AnimationSet.prototype.initializeInvalidateRegion = function(a, b, c, d) {}, AnimationSet.prototype.getTransformation = function(a) {
    if (1 == this.mVersion) {
        var b = !1,
            c = !1,
            d = !0;
        for (var e in this.mAnimations) {
            var f = this.mAnimations[e];
            f.hasEnded() || (b = f.getTransformation(a, this.getScaleFactor()) || b), c = c || f.hasStarted(), d = f.hasEnded() && d
        }
        return c && !this.mStarted && (this.mStarted = !0, this.fireAnimationStart()), d != this.mEnded && (this.mRepeatCount != this.mRepeated ? (this.mRepeatCount > 0 && this.mRepeated++, this.setStartTime(this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis()), this.fireAnimationRepeat()) : (this.mEnded = d, this.fireAnimationEnd())), b
    }
    if (2 == this.mVersion) {
        -1 == this.mStartTime && (this.mStartTime = a);
        var g, h = this.getStartOffset(),
            i = this.mMaxDuration;
        0 != i ? (this.mRepeated > 0 && (h = 0), g = (a - (this.mStartTime + h)) / i) : g = a < this.mStartTime ? 0 : 1, g = Math.max(Math.min(g, 1), 0), this.fireAnimationProgress(g);
        var j = a - this.mStartTime;
        this.mCurrLifeTime = j <= this.getStartOffset() ? j : this.getStartOffset() + this.mMaxDuration * g;
        var b = !1,
            c = !1,
            d = !0;
        for (var e in this.mAnimations) {
            var k = this.mAnimations[e];
            b = k.getTransformation(a, this.getScaleFactor()) || b, c = c || k.hasStarted(), d = k.hasEnded() && d
        }
        if ((this.mStartRepeatSetting < this.mStopRepeatSetting || this.mStartRepeatSetting == this.mStopRepeatSetting && this.mStartTimeSetting <= this.mStopTimeSetting) && this.mStopTimeSetting <= this.mCurrLifeTime && this.mStopRepeatSetting == this.mRepeated && (this.mCanStop = !0, this.mBeStop = !0, this.mRoot.debug && console.log(this.mName, this.mBeStop, "284"), this.mStopTimeSetting = -1, this.mStopRepeatSetting = -1, this.mHasAniStarted = !1, this.mHasAniEnded = !0, this.mEnded = d, this.fireAnimationEnd()), this.mStarted || this.mHasAniStarted || (this.mHasAniStarted = !0, this.mHasAniEnded = !1, this.fireAnimationStart()), c && !this.mStarted && (this.mStarted = !0), d != this.mEnded)
            if (this.mRepeatCount != this.mRepeated) {
                var l = this.mRepeated,
                    m = this.mCycleFlip;
                this.setStartTime(this.mRoot.mAnimationManager.getAnimationUtil().getCurrentAnimationTimeMillis()), this.mRepeatCount > 0 && (l++, this.mRepeated = l), this.mRepeatMode == Animation.REVERSE && (this.mCycleFlip = !m, this.mIsReverse = !this.mIsReverse), this.fireAnimationRepeat()
            } else this.mEnded = d, this.mHasAniStarted = !1, this.mHasAniEnded = !0, this.mCanStop = !0, this.mBeStop = !0, this.mRoot.debug && console.log(this.mName, this.mBeStop, "315"), this.fireAnimationEnd();
        return b
    }
    return !1
}, AnimationSet.prototype.scaleCurrentDuration = function(a) {
    for (var b in this.mAnimations) {
        var c = this.mAnimations[b];
        c.scaleCurrentDuration(a)
    }
}, AnimationSet.prototype.initialize = function(a, b, c, d) {
    this._initialize(a, b, c, d);
    var e = (this.mFlags & AnimationSet.PROPERTY_DURATION_MASK) == AnimationSet.PROPERTY_DURATION_MASK,
        f = (this.mFlags & AnimationSet.PROPERTY_FILL_AFTER_MASK) == AnimationSet.PROPERTY_FILL_AFTER_MASK,
        g = (this.mFlags & AnimationSet.PROPERTY_FILL_BEFORE_MASK) == AnimationSet.PROPERTY_FILL_BEFORE_MASK,
        h = (this.mFlags & AnimationSet.PROPERTY_REPEAT_MODE_MASK) == AnimationSet.PROPERTY_REPEAT_MODE_MASK,
        i = (this.mFlags & AnimationSet.PROPERTY_SHARE_INTERPOLATOR_MASK) == AnimationSet.PROPERTY_SHARE_INTERPOLATOR_MASK,
        j = (this.mFlags & AnimationSet.PROPERTY_START_OFFSET_MASK) == AnimationSet.PROPERTY_START_OFFSET_MASK;
    i && this.ensureInterpolator();
    var k = this.mDuration,
        l = this.mFillAfter,
        m = this.mFillBefore,
        n = this.mRepeatMode,
        o = this.mInterpolator,
        p = this.mStartOffset,
        q = this.mAnimations.length,
        r = this.mStoredOffsets,
        s = r.length;
    j ? (0 == r || s != q) && (r = s, this.mStoredOffsets = s) : 0 != r && (r = 0, this.mStoredOffsets = 0);
    for (var t in this.mAnimations) {
        var u = this.mAnimations[t];
        if (e && u.setDuration(k), f && u.setFillAfter(l), g && u.setFillBefore(m), h && u.setRepeatMode(n), i && u.setInterpolator(o, !1), j) {
            var v = u.getStartOffset();
            u.setStartOffset(v + p), r[t] = v
        }
        u.initialize(a, b, c, d)
    }
}, AnimationSet.prototype.reset = function() {
    this._reset(), this.restoreChildrenStartOffset()
}, AnimationSet.prototype.getAnimations = function() {
    return this.mAnimations
}, AnimationSet.prototype.willChangeTransformationMatrix = function() {
    return (this.mFlags & AnimationSet.PROPERTY_MORPH_MATRIX_MASK) == AnimationSet.PROPERTY_MORPH_MATRIX_MASK
}, AnimationSet.prototype.willChangeBounds = function() {
    return (this.mFlags & AnimationSet.PROPERTY_CHANGE_BOUNDS_MASK) == AnimationSet.PROPERTY_CHANGE_BOUNDS_MASK
}, AnimationSet.prototype.onResize = function(a, b) {
    var c;
    for (var d in this.mAnimations) c = this.mAnimations[d], c.onResize(a, b)
}, AnimationSet.prototype.restoreChildrenStartOffset = function() {
    var a = this.mStoredOffsets;
    if (0 != a) {
        for (var b in this.mAnimations) {
            var c = this.mAnimations[b];
            c.setStartOffset(a[b])
        }
    }
}, AnimationSet.prototype.findAnimation = function(a) {
    var b;
    for (var c in this.mAnimations)
        if (b = this.mAnimations[c], 0 === b.getName().localeCompare(a)) return b;
    return null
}, AnimationSet.prototype.setAniSetDuration = function(a) {
    return !1
}, AnimationSet.prototype.setMaxDuration = function() {
    var a = 0;
    for (var b in this.mAnimations) {
        var c = this.mAnimations[b],
            d = c.getStartOffset() + c.getDuration() * (c.mRepeatCount + 1);
        a = d > a ? d : a
    }
    this.mMaxDuration = a, this.mDuration = this.mMaxDuration, this.mStartOffset = 0
}, AnimationSet.prototype.speedUp = function(a, b) {
    var c = this.mMaxDuration,
        d = c;
    d = b ? b / a : c / a;
    var e = this.getCurrentAnimationLifeTime() * d / c;
    this.mMaxDuration = d;
    for (var f in this.mAnimations) {
        var g = this.mAnimations[f],
            h = g.getStartOffset(),
            i = h * d / c;
        g.setStartOffset(i);
        var j = g.getDuration(),
            k = j * d / c;
        g.setDuration(k)
    }
    this.mMaxDuration = this.getDuration(), this.startPlay(e, this.getCurrentRepeats())
}, AnimationSet.PROPERTY_FILL_AFTER_MASK = 1, AnimationSet.PROPERTY_FILL_BEFORE_MASK = 2, AnimationSet.PROPERTY_REPEAT_MODE_MASK = 4, AnimationSet.PROPERTY_START_OFFSET_MASK = 8, AnimationSet.PROPERTY_SHARE_INTERPOLATOR_MASK = 16, AnimationSet.PROPERTY_DURATION_MASK = 32, AnimationSet.PROPERTY_MORPH_MATRIX_MASK = 64, AnimationSet.PROPERTY_CHANGE_BOUNDS_MASK = 128;
var TranslateAnimation = function(a, b, c) {
    Animation.call(this, a, c), this.mTarget = b, this.mFromXType = Animation.ABSOLUTE, this.mToXType = Animation.ABSOLUTE, this.mFromYType = Animation.ABSOLUTE, this.mToYType = Animation.ABSOLUTE, this.mFromZType = Animation.ABSOLUTE, this.mToZType = Animation.ABSOLUTE, this.mRelative = !1, this.mFromXDelta = null, this.mToXDelta = null, this.mFromYDelta = null, this.mToYDelta = null, this.mFromZDelta = null, this.mToZDelta = null, this.mFromXDelta_Raw = 0, this.mToXDelta_Raw = 0, this.mFromYDelta_Raw = 0, this.mToYDelta_Raw = 0, this.mFromZDelta_Raw = 0, this.mToZDelta_Raw = 0, this.mScreenWidth = this.mRoot.mPhoneWidth || 0, this.mScreenHeight = this.mRoot.mPhoneHeight || 0, this.mIsCoordinateRelativeToScreen = !1, this.mIsDirty = !0, this.mEnableXTranslate = !1, this.mEnableYTranslate = !1, this.mEnableZTranslate = !1
};
extend(TranslateAnimation, Animation), TranslateAnimation.prototype.updateCoordinateData = function() {
    this.mIsCoordinateRelativeToScreen ? (this.mFromXDelta = this.mScreenWidth * this.mFromXDelta_Raw, this.mToXDelta = this.mScreenWidth * this.mToXDelta_Raw, this.mFromYDelta = this.mScreenHeight * this.mFromYDelta_Raw, this.mToYDelta = this.mScreenHeight * this.mToYDelta_Raw, this.mFromZDelta = this.mFromZDelta_Raw, this.mToZDelta = this.mToZDelta_Raw) : (this.mFromXDelta = this.mFromXDelta_Raw, this.mToXDelta = this.mToXDelta_Raw, this.mFromYDelta = this.mFromYDelta_Raw, this.mToYDelta = this.mToYDelta_Raw, this.mFromZDelta = this.mFromZDelta_Raw, this.mToZDelta = this.mToZDelta_Raw), this.mIsDirty = !1
}, TranslateAnimation.prototype.setIsCoordinateRelativeToScreen = function(a) {
    this.mIsCoordinateRelativeToScreen = a, this.mIsDirty = !0
}, TranslateAnimation.prototype.enableXTranslate = function(a, b, c) {
    this.mEnableXTranslate != a && (this.mEnableXTranslate = a, a && (this.mFromXDelta_Raw = b, this.mToXDelta_Raw = c), this.mIsDirty = !0)
}, TranslateAnimation.prototype.enableYTranslate = function(a, b, c) {
    this.mEnableYTranslate != a && (this.mEnableYTranslate = a, a && (this.mFromYDelta_Raw = b, this.mToYDelta_Raw = c), this.mIsDirty = !0)
}, TranslateAnimation.prototype.enableZTranslate = function(a, b, c) {
    this.mEnableZTranslate != a && (this.mEnableZTranslate = a, a && (this.mFromZDelta_Raw = b, this.mToZDelta_Raw = c), this.mIsDirty = !0)
}, TranslateAnimation.prototype.setFromXDelta = function(a) {
    this.mFromXDelta_Raw = a, this.mEnableXTranslate = !0, this.mIsDirty = !0
}, TranslateAnimation.prototype.setToXDelta = function(a) {
    this.mToXDelta_Raw = a, this.mEnableXTranslate = !0, this.mIsDirty = !0
}, TranslateAnimation.prototype.setFromYDelta = function(a) {
    this.mFromYDelta_Raw = a, this.mEnableYTranslate = !0, this.mIsDirty = !0
}, TranslateAnimation.prototype.setToYDelta = function(a) {
    this.mToYDelta_Raw = a, this.mEnableYTranslate = !0, this.mIsDirty = !0
}, TranslateAnimation.prototype.setFromZDelta = function(a) {
    this.mFromZDelta_Raw = a, this.mEnableZTranslate = !0, this.mIsDirty = !0
}, TranslateAnimation.prototype.setToZDelta = function(a) {
    this.mToZDelta_Raw = a, this.mEnableZTranslate = !0, this.mIsDirty = !0
}, TranslateAnimation.prototype.resetXTranslateDelta = function(a, b) {
    this.mFromXDelta_Raw = a, this.mToXDelta_Raw = b, this.mIsDirty = !0
}, TranslateAnimation.prototype.resetYTranslateDelta = function(a, b) {
    this.mFromYDelta_Raw = a, this.mToYDelta_Raw = b, this.mIsDirty = !0
}, TranslateAnimation.prototype.resetZTranslateDelta = function(a, b) {
    this.mFromZDelta_Raw = a, this.mToZDelta_Raw = b, this.mIsDirty = !0
}, TranslateAnimation.prototype.onResize = function(a, b) {
    this.mScreenWidth = a, this.mScreenHeight = b, this.mIsDirty = !0
}, TranslateAnimation.prototype.applyTransformation = function(a) {
    this.mIsDirty && this.updateCoordinateData();
    var b, c, d, e = this.mTarget;
    b = this.mEnableXTranslate ? this.mFromXDelta != this.mToXDelta ? this.mFromXDelta + (this.mToXDelta - this.mFromXDelta) * a + (this.mRelative ? e.getPosition().x : 0) : this.mFromXDelta + (this.mRelative ? e.getPosition().x : 0) : e.getPosition().x, c = this.mEnableYTranslate ? this.mFromYDelta != this.mToYDelta ? this.mFromYDelta + (this.mToYDelta - this.mFromYDelta) * a + (this.mRelative ? e.getPosition().y : 0) : this.mFromYDelta + (this.mRelative ? e.getPosition().y : 0) : e.getPosition().y, d = this.mEnableZTranslate ? this.mFromZDelta != this.mToZDelta ? this.mFromZDelta + (this.mToZDelta - this.mFromZDelta) * a + (this.mRelative ? e.getPosition().z : 0) : this.mFromZDelta + (this.mRelative ? e.getPosition().z : 0) : e.getPosition().z, this.mResetMode == Animation.RESETMODE_ORIGINAL ? e.setPosition(e.getOriginalPosition().add(new Vector3(b, c, d))) : this.mResetMode == Animation.RESETMODE_UNIT ? e.setPosition(b, c, d) : this.mResetMode == Animation.RESETMODE_NONE && e.setPosition(e.getPosition().add(new Vector3(b, c, d)))
}, TranslateAnimation.prototype.initialize = function(a, b, c, d) {
    this._initialize(a, b, c, d)
};
var ScaleAnimation = function(a, b, c, d, e, f, g, h, i) {
    Animation.call(this, a, i), this.mTarget = b, this.mPivotXType = Animation.ABSOLUTE, this.mPivotYType = Animation.ABSOLUTE, this.mPivotXValue = 0, this.mPivotYValue = 0, this.mFromXDelta_Raw = 1, this.mToXDelta_Raw = 1, this.mFromYDelta_Raw = 1, this.mToYDelta_Raw = 1, this.mFromZDelta_Raw = 1, this.mToZDelta_Raw = 1, this.mFromXDelta = 0, this.mFromYDelta = 0, this.mFromZDelta = 0, this.mToXDelta = 0, this.mToYDelta = 0, this.mToZDelta = 0, this.mPivotX = 0, this.mPivotY = 0, this.mIsDirty = !0
};
extend(ScaleAnimation, Animation), ScaleAnimation.prototype.initializePivotPoint = function() {
    this.mPivotXType == Animation.ABSOLUTE && (this.mPivotX = this.mPivotXValue), this.mPivotYType == Animation.ABSOLUTE && (this.mPivotY = this.mPivotYValue)
}, ScaleAnimation.prototype.setFromXDelta = function(a) {
    this.mFromXDelta_Raw = a, this.mIsDirty = !0
}, ScaleAnimation.prototype.setToXDelta = function(a) {
    this.mToXDelta_Raw = a, this.mIsDirty = !0
}, ScaleAnimation.prototype.setFromYDelta = function(a) {
    this.mFromYDelta_Raw = a, this.mIsDirty = !0
}, ScaleAnimation.prototype.setToYDelta = function(a) {
    this.mToYDelta_Raw = a, this.mIsDirty = !0
}, ScaleAnimation.prototype.setFromZDelta = function(a) {
    this.mFromZDelta_Raw = a, this.mIsDirty = !0
}, ScaleAnimation.prototype.setToZDelta = function(a) {
    this.mToZDelta_Raw = a, this.mIsDirty = !0
}, ScaleAnimation.prototype.updateCoordinateData = function() {
    this.mFromXDelta = this.mFromXDelta_Raw, this.mToXDelta = this.mToXDelta_Raw, this.mFromYDelta = this.mFromYDelta_Raw, this.mToYDelta = this.mToYDelta_Raw, this.mFromZDelta = this.mFromZDelta_Raw, this.mToZDelta = this.mToZDelta_Raw
}, ScaleAnimation.prototype.applyTransformation = function(a) {
    this.mIsDirty && this.updateCoordinateData();
    var b = this.mTarget,
        c = 1,
        d = 1,
        e = 1;
    this.getScaleFactor();
    (1 != this.mFromXDelta || 1 != this.mToXDelta) && (c = this.mFromXDelta + (this.mToXDelta - this.mFromXDelta) * a), (1 != this.mFromYDelta || 1 != this.mToYDelta) && (d = this.mFromYDelta + (this.mToYDelta - this.mFromYDelta) * a), (1 != this.mFromZDelta || 1 != this.mToZDelta) && (e = this.mFromZDelta + (this.mToZDelta - this.mFromZDelta) * a), b.setScale(c, d, e)
}, ScaleAnimation.prototype.resolveScale = function(a, b, c, d, e) {
    return a
}, ScaleAnimation.prototype.initialize = function(a, b, c, d) {
    this._initialize(a, b, c, d)
};
var RotateAnimation = function(a, b, c, d, e, f, g) {
    Animation.call(this, a, f), this.mTarget = b, this.mPivotXType = Animation.ABSOLUTE, this.mPivotYType = Animation.ABSOLUTE, this.mPivotXValue = 0, this.mPivotYValue = 0, this.mDegreeOffset = 0, this.mAniMode = RotateAnimation.DEGREE, this.mVelocity = 0, this.mLastTime = 0, this.mFromDegrees = 0, this.mToDegrees = 0, this.mCurDegrees = 0, this.isRelativeToOrientationBeenSet = !1, this.mPivotX = 0, this.mPivotY = 0, this.mAxis = new Vector3(1, 0, 0), this.mTransformSpace = TS_LOCAL
};
extend(RotateAnimation, Animation), RotateAnimation.prototype.reset = function() {
    this.mLastTime = 0, this.mCurDegrees = 0, this._reset()
}, RotateAnimation.prototype.initializePivotPoint = function() {
    this.mPivotXType == Animation.ABSOLUTE && (this.mPivotX = this.mPivotXValue), this.mPivotYType == Animation.ABSOLUTE && (this.mPivotY = this.mPivotYValue)
}, RotateAnimation.prototype.preTransform = function() {
    -1 == this.mStartTime && this.mRelative && (this.mRelativeToOrientation = this.mTarget.getOrientation())
}, RotateAnimation.prototype.getTransformation = function(a) {
    if (this.mAniMode == RotateAnimation.DEGREE) this._getTransformation(a);
    else if (this.mAniMode == RotateAnimation.VELOCITY) {
        0 == this.mLastTime && (this.mLastTime = a);
        var b = a - this.mLastTime;
        this._applyTransformation(b), this.mListener && this.mListener.onAnimationProgress(this, b), this.mLastTime = a
    }
    return !0
}, RotateAnimation.prototype._applyTransformation = function(a) {
    var b = this.mTarget,
        c = this.mCurDegrees + this.mVelocity * a;
    c > Math.TWO_PI && (c -= Math.TWO_PI), c < -Math.TWO_PI && (c += Math.TWO_PI);
    var d = c + this.mDegreeOffset;
    b.resetOrientation(), b.rotate(this.mAxis, d, this.mTransformSpace), this.mCurDegrees = c
}, RotateAnimation.prototype.applyTransformation = function(a) {
    var b = this.mTarget,
        c = this.mFromDegrees + (this.mToDegrees - this.mFromDegrees) * a;
    if (this.mResetMode == Animation.RESETMODE_ORIGINAL) b.setOrientation(b.getOrientation());
    else if (this.mResetMode == Animation.RESETMODE_UNIT) {
        if (this.mRelative) {
            var d = new Quaternion;
            return d.setFromAxisAngle(c, this.mAxis), b.rotate(d, this.mTransformSpace), void(this.mCurDegrees = c)
        }
        b.resetOrientation()
    }
    b.rotate(this.mAxis, c, this.mTransformSpace), this.mCurDegrees = c
}, RotateAnimation.prototype.initialize = function(a, b, c, d) {
    this._initialize(a, b, c, d)
}, RotateAnimation.prototype.getFromDegrees = function() {
    return this.mFromDegrees
}, RotateAnimation.prototype.setFromDegrees = function(a) {
    this.mFromDegrees = a
}, RotateAnimation.prototype.getToDegrees = function() {
    return this.mToDegrees
}, RotateAnimation.prototype.setToDegrees = function(a) {
    this.mToDegrees = a
}, RotateAnimation.prototype.setAniMode = function(a) {
    a = a.toLowerCase(), 0 == "degree".localeCompare(a) ? this.mAniMode = RotateAnimation.DEGREE : 0 == "velocity".localeCompare(a) && (this.mAniMode = RotateAnimation.VELOCITY)
}, RotateAnimation.prototype.setVelocity = function(a) {
    this.mVelocity = a
}, RotateAnimation.prototype.getVelocity = function() {
    return this.mVelocity
}, RotateAnimation.prototype.setDegreesOffset = function(a) {
    this.mDegreeOffset = a
}, RotateAnimation.prototype.getCurDegrees = function() {
    return this.mCurDegrees
}, RotateAnimation.prototype.setAxis = function(a) {
    this.mAxis.copy(a)
}, RotateAnimation.prototype.setTransformSpace = function(a) {
    this.mTransformSpace = a
}, RotateAnimation.prototype.setTransformSpace = function(a) {
    a = a.toLowerCase(), "ts_local" == a ? this.mTransformSpace = TS_LOCAL : "ts_world" == a ? this.mTransformSpace = TS_WORLD : "ts_not_add" == a ? this.mTransformSpace = TS_NOT_ADD : this.mTransformSpace = TS_PARENT
}, RotateAnimation.DEGREE = 0, RotateAnimation.VELOCITY = 1;
var TexCoordSetAnimation = function(a, b, c) {
    Animation.call(this, a, c), this.mTarget = b, this.mTextureCoords = []
};
extend(TexCoordSetAnimation, Animation), TexCoordSetAnimation.prototype.applyTransformation = function(a) {
    if (this.mTarget) {
        var b = this.mTextureCoords.length,
            c = -1;
        c = 0 >= a ? 0 : a >= 1 ? b - 1 : parseInt(a * b) % b, this.mTextureCoords[c] && this.mTarget.mManipulator.updateTexCoords(this.mTextureCoords[c])
    }
}, TexCoordSetAnimation.prototype.setTarget = function(a) {
    this.mTarget = a
}, TexCoordSetAnimation.prototype.setTextureCoordSets = function(a) {
    this.mTextureCoords = a
}, TexCoordSetAnimation.prototype.setStoppedFrame = function(a) {
    a %= this.mTextureCoords.length, this.mTarget && this.mTarget.mGameObject.eRect.updateTexCoords(this.mTextureCoords[a])
};
var TexAlphaModifierAnimation = function(a) {
    Animation.call(this, a), this.mPass = null, this.mFromAlpha = 0, this.mToAlpha = 0
};
extend(TexAlphaModifierAnimation, Animation), TexAlphaModifierAnimation.prototype.applyTransformation = function(a) {
    var b = this.mFromAlpha + (this.mToAlpha - this.mFromAlpha) * a;
    this.mPass.setShininess(b), this.mPass.setColorModifierAlpha(b)
}, TexAlphaModifierAnimation.prototype.setFromAlpha = function(a) {
    this.mFromAlpha = a
}, TexAlphaModifierAnimation.prototype.setToAlpha = function(a) {
    this.mToAlpha = a
}, TexAlphaModifierAnimation.prototype.setTarget = function(a) {
    this.mPass = a
};
var TexCoordModifierAnimation = function(a, b, c, d, e, f, g) {
    Animation.call(this, a), this.mTextureLayer = b, this.mTransU = c || !1, this.mTransV = d || !1, this.mScaleU = e || !1, this.mScaleV = f || !1, this.mRotate = g || !1, this.uvMoveSortMode = 0, this.mFrameEnd = -1, this.mFrameStart = -1, this.mStack = -1, this.mSlice = -1, this.mFromScaleU = null, this.mToScaleU = null, this.mFromScaleV = null, this.mToScaleV = null, this.mFromTranslateU = null, this.mToTranslateU = null, this.mFromTranslateV = null, this.mToTranslateV = null, this.mFromRotate = null, this.mToRotate = null
};
extend(TexCoordModifierAnimation, Animation), TexCoordModifierAnimation.prototype.applyTransformation = function(a) {
    var b;
    if (0 == this.uvMoveSortMode) this.mRoot.debug && console.log(this.mName, a), this.mTransU && (b = this.mFromTranslateU + (this.mToTranslateU - this.mFromTranslateU) * a, this.setValue(TexCoordModifierAnimation.TRANS_U, b)), this.mTransV && (b = this.mFromTranslateV + (this.mToTranslateV - this.mFromTranslateV) * a, this.setValue(TexCoordModifierAnimation.TRANS_V, b)), this.mScaleU && (b = this.mFromScaleU + (this.mToScaleU - this.mFromScaleU) * a, this.setValue(TexCoordModifierAnimation.SCALE_U, b)), this.mScaleV && (b = this.mFromScaleV + (this.mToScaleV - this.mFromScaleV) * a, this.setValue(TexCoordModifierAnimation.SCALE_V, b)), this.mRotate && (b = this.mFromRotate + (this.mToRotate - this.mFromRotate) * a, this.setValue(TexCoordModifierAnimation.ROTATE, b));
    else if (1 == this.uvMoveSortMode) {
        var c = this.mFrameEnd - this.mFrameStart + 1,
            d = Math.floor(a * c),
            e = Math.floor((d + this.mFrameStart) / this.mSlice),
            f = (d + this.mFrameStart) % this.mSlice,
            g = f / this.mSlice;
        this.setValue(TexCoordModifierAnimation.TRANS_U, g);
        var h = -e / this.mStack;
        this.setValue(TexCoordModifierAnimation.TRANS_V, h)
    } else if (2 == this.uvMoveSortMode) {
        var c = this.mFrameEnd - this.mFrameStart + 1,
            d = Math.floor(a * c),
            e = Math.floor((d + this.mFrameStart) / this.mStack),
            f = (d + this.mFrameStart) % this.mStack,
            g = e / this.mSlice;
        this.setValue(TexCoordModifierAnimation.TRANS_U, g);
        var h = -f / this.mStack;
        this.setValue(TexCoordModifierAnimation.TRANS_V, h)
    }
}, TexCoordModifierAnimation.prototype.getValue = function() {
    var a = this.mTextureLayer.getTextureTransform();
    return this.mTransU ? a[3] : this.mTransV ? a[7] : this.mScaleU ? a[0] : this.mScaleV ? a[5] : 0
}, TexCoordModifierAnimation.prototype.setValue = function(a, b) {
    TexCoordModifierAnimation.TRANS_U == a ? this.mTextureLayer.setTextureUScroll(b) : TexCoordModifierAnimation.TRANS_V == a ? this.mTextureLayer.setTextureVScroll(b) : TexCoordModifierAnimation.SCALE_U == a ? this.mTextureLayer.setTextureUScale(b) : TexCoordModifierAnimation.SCALE_V == a ? this.mTextureLayer.setTextureVScale(b) : TexCoordModifierAnimation.ROTATE == a && this.mTextureLayer.setTextureRotate(b * Math.TWO_PI)
}, TexCoordModifierAnimation.prototype.setFromScaleU = function(a) {
    this.mFromScaleU = a, this.mScaleU = !0
}, TexCoordModifierAnimation.prototype.getFromScaleU = function() {
    return this.mFromScaleU
}, TexCoordModifierAnimation.prototype.setToScaleU = function(a) {
    this.mToScaleU = a, this.mScaleU = !0
}, TexCoordModifierAnimation.prototype.getToScaleU = function() {
    return this.mToScaleU
}, TexCoordModifierAnimation.prototype.setFromScaleV = function(a) {
    this.mFromScaleV = a, this.mScaleV = !0
}, TexCoordModifierAnimation.prototype.getFromScaleV = function() {
    return this.mFromScaleV
}, TexCoordModifierAnimation.prototype.setToScaleV = function(a) {
    this.mToScaleV = a, this.mScaleV = !0
}, TexCoordModifierAnimation.prototype.getToScaleV = function() {
    return this.mToScaleV
}, TexCoordModifierAnimation.prototype.setFromTranslateU = function(a) {
    this.mFromTranslateU = a, this.mTransU = !0
}, TexCoordModifierAnimation.prototype.getFromTranslateU = function() {
    return this.mFromTranslateU
}, TexCoordModifierAnimation.prototype.setToTranslateU = function(a) {
    this.mToTranslateU = a, this.mTransU = !0
}, TexCoordModifierAnimation.prototype.getToTranslateU = function() {
    return this.mToTranslateU
}, TexCoordModifierAnimation.prototype.setFromTranslateV = function(a) {
    this.mFromTranslateV = a, this.mTransV = !0
}, TexCoordModifierAnimation.prototype.getFromTranslateV = function() {
    return this.mFromTranslateV
}, TexCoordModifierAnimation.prototype.setToTranslateV = function(a) {
    this.mToTranslateV = a, this.mTransV = !0
}, TexCoordModifierAnimation.prototype.getToTranslateV = function() {
    return this.mToTranslateV
}, TexCoordModifierAnimation.prototype.setFromRotate = function(a) {
    this.mFromRotate = a, this.mRotate = !0
}, TexCoordModifierAnimation.prototype.getFromRotate = function() {
    return this.mFromRotate
}, TexCoordModifierAnimation.prototype.setToRotate = function(a) {
    this.mToRotate = a, this.mRotate = !0
}, TexCoordModifierAnimation.prototype.getToRotate = function() {
    return this.mToRotate
}, TexCoordModifierAnimation.prototype.setUVMoveSortMode = function(a) {
    this.uvMoveSortMode = a
}, TexCoordModifierAnimation.prototype.getUVMoveSortMode = function() {
    return this.uvMoveSortMode
}, TexCoordModifierAnimation.prototype.setStack = function(a) {
    a >= 0 && (this.mStack = a)
}, TexCoordModifierAnimation.prototype.getStack = function() {
    return this.mStack
}, TexCoordModifierAnimation.prototype.setSlice = function(a) {
    a >= 0 && (this.mSlice = a)
}, TexCoordModifierAnimation.prototype.getSlice = function() {
    return this.mSlice
}, TexCoordModifierAnimation.prototype.setStartFrame = function(a) {
    a >= 0 && (this.mFrameStart = a)
}, TexCoordModifierAnimation.prototype.getStartFrame = function() {
    return this.mFrameStart
}, TexCoordModifierAnimation.prototype.setEndFrame = function(a) {
    a >= 0 && (this.mFrameEnd = a)
}, TexCoordModifierAnimation.prototype.getEndFrame = function() {
    return this.mFrameEnd
}, TexCoordModifierAnimation.TRANS_U = 0, TexCoordModifierAnimation.TRANS_V = 1, TexCoordModifierAnimation.SCALE_U = 2, TexCoordModifierAnimation.SCALE_V = 3, TexCoordModifierAnimation.ROTATE = 4;
var BinaryParse = function(a) {
    this.offset = 0, this.binaryBuff = a, this.dView = new DataView(a), this.byteLength = this.binaryBuff.byteLength
};
BinaryParse.prototype = {
    constructor: BinaryParse,
    Read16: function() {
        if (this.byteLength < 1 + this.offset) return void 0;
        var a = this.dView.getUint8(this.offset++),
            b = this.dView.getUint8(this.offset++),
            c = b << 8 | a;
        return c
    },
    Read32: function() {
        if (this.byteLength < 3 + this.offset) return void 0;
        var a = this.dView.getUint8(this.offset++),
            b = this.dView.getUint8(this.offset++),
            c = this.dView.getUint8(this.offset++),
            d = this.dView.getUint8(this.offset++),
            e = d << 24 | c << 16 | b << 8 | a;
        return e
    },
    ReadName: function() {
        return this.Read32()
    },
    ReadLen: function() {
        return this.Read32()
    },
    ReadMark: function(a) {
        var b, c;
        return void 0 === (b = this.ReadName()) ? !1 : void 0 === (c = this.ReadLen()) ? !1 : (a.nName = b, a.nLen = c, !0)
    },
    ReadMeshName: function(a) {
        if (0 >= a || this.byteLength < this.offset + a) return void 0;
        var b = String.fromCharCode.apply(null, new Uint8Array(this.binaryBuff, this.offset, a));
        return b = e3d.trim0(b), this.offset = this.offset + a, b
    },
    readAsArrayBuffer: function(a, b) {
        var c = a.slice(this.offset, this.offset + b),
            d = new Uint32Array(c, 0, b / 4);
        return this.offset = this.offset + b, d
    },
    ReadAfterAlloc32: function(a) {
        var b = this.binaryBuff.slice(this.offset, this.offset + a),
            c = new Float32Array(b, 0, a / 4);
        return this.offset = this.offset + a, c
    },
    skip: function(a) {
        return this.offset += a, this.offset > this.byteLength ? !1 : !0
    }
};
var KeyFramesParseInst = function(a, b) {
    this.mRoot = a, this.binaryParse = null, this.keyFramesManager = b
};
KeyFramesParseInst.prototype = {
    parseKeyFrames: function(a, b) {
        b.binaryParse = new BinaryParse(a);
        for (var c, d, e = {}; b.binaryParse.ReadMark(e);) switch (c = e.nName, d = e.nLen, c) {
            case ePODFileKeyFrame:
                if (!b.readKeyFrame()) return;
                break;
            default:
                b.binaryParse.skip(d)
        }
    },
    readKeyFrame: function() {
        for (var a = null, b = 0, c = null, d = 0, e = 0, f = {}; this.binaryParse.ReadMark(f);) switch (d = f.nName, e = f.nLen, this.mRoot.debug && console.log(f), d) {
            case ePODFileKeyFrame | PVRTMODELPOD_TAG_END:
                return this.keyFramesManager.addKeyFrames(a, c), !0;
            case ePODFileKeyFrameName:
                a = this.binaryParse.ReadMeshName(e);
                break;
            case ePODFileKeyFrameNum:
                b = this.binaryParse.Read32();
                break;
            case ePODFileKeyFrameData:
                c = this.binaryParse.ReadAfterAlloc32(e);
                break;
            default:
                this.binaryParse.skip(e)
        }
        return !1
    }
};
var KeyFramesManager = function(a) {
    ResourceManager.call(this), this.mRoot = a, this.src = "", this.mKeyFramesMap = {}
};
KeyFramesManager.prototype = {
    constructor: KeyFramesManager,
    load: function(a) {
        var b = new KeyFramesParseInst(this.mRoot, this);
        this.mRoot.mArchive.binaryLoad(this.src, b.parseKeyFrames, a.mPrefix, b)
    },
    addKeyFrames: function(a, b) {
        var c = this.mKeyFramesMap[a];
        return c || (this.mKeyFramesMap[a] = b), !0
    },
    findKeyFrames: function(a) {
        for (var b in this.mKeyFramesMap)
            if (b == a) return this.mKeyFramesMap[b];
        return null
    },
    releaseAllKeyFrames: function() {
        var a = null;
        for (var b in this.mKeyFramesMap) a = this.mKeyFramesMap[b], a = null;
        this.mKeyFramesMap = []
    },
    releaseResourceByGroupName: function(a) {},
    releaseResourceByGroupId: function(a) {
        for (var b in this.mKeyFramesMap) this.mKeyFramesMap[b].mGroupId === a && delete this.mKeyFramesMap[b]
    }
};
var KeyFramesTranslateAnimation = function(a, b, c) {
    Animation.call(this, a, c), this.mTarget = b, this.mIsCoordinateRelativeToScreen = !1, this.mIsDirty = !0, this.mScreenWidth = this.mRoot.mPhoneWidth, this.mScreenHeight = this.mRoot.mPhoneHeight, this.frameDatas = 0, this.numFrames = 0, this.kfsName = 0
};
extend(KeyFramesTranslateAnimation, Animation), KeyFramesTranslateAnimation.prototype.setFrameDatas = function(a) {
    this.frameDatas = a
}, KeyFramesTranslateAnimation.prototype.setIsCoordinateRelativeToScreen = function(a) {
    this.mIsCoordinateRelativeToScreen = a, this.mIsDirty = !0
}, KeyFramesTranslateAnimation.prototype.onResize = function(a, b) {
    this.mScreenWidth = a, this.mScreenHeight = b, this.mIsDirty = !0
}, KeyFramesTranslateAnimation.prototype.setTransformSpace = function(a) {
    a = a.toLowerCase(), "ts_local" == a ? this.mTransformSpace = TS_LOCAL : "ts_world" == a ? this.mTransformSpace = TS_WORLD : "ts_not_add" == a ? this.mTransformSpace = TS_NOT_ADD : this.mTransformSpace = TS_PARENT
}, KeyFramesTranslateAnimation.prototype.setFrames = function(a, b) {
    if (this.kfsName = b, this.kfsName) {
        if (this.numFrames = a, !this.mRoot.getKeyFramesManager()) return !1;
        var c = this.mRoot.getKeyFramesManager().findKeyFrames(b);
        if (c) return this.setFrameDatas(c), !0
    }
    return !1
}, KeyFramesTranslateAnimation.prototype.applyTransformation = function(a) {
    if (!this.frameDatas) return void console.error("frameData is null keyframesName=" + this.kfsName);
    var b, c, d, e = this.mTarget;
    if (0 > a && (a = 0), a > 1 && (a = 1), this.kfsName && this.numFrames) {
        var f = this.numFrames * a,
            g = Math.ceil(f),
            h = g - 1,
            i = f - h;
        if (!this.frameDatas) return;
        h >= this.numFrames - 1 ? (b = this.frameDatas[3 * (this.numFrames - 1)], c = this.frameDatas[3 * (this.numFrames - 1) + 1], d = this.frameDatas[3 * (this.numFrames - 1) + 2]) : 0 >= g ? (b = this.frameDatas[0], c = this.frameDatas[1], d = this.frameDatas[2]) : (b = (this.frameDatas[3 * g] - this.frameDatas[3 * h]) * i + this.frameDatas[3 * h], c = (this.frameDatas[3 * g + 1] - this.frameDatas[3 * h + 1]) * i + this.frameDatas[3 * h + 1], d = (this.frameDatas[3 * g + 2] - this.frameDatas[3 * h + 2]) * i + this.frameDatas[3 * h + 2])
    } else b = e.getPosition().x, c = e.getPosition().y, d = e.getPosition().z;
    this.mIsCoordinateRelativeToScreen && (b = this.mScreenWidth * b, c = this.mScreenHeight * c), this.mResetMode == Animation.RESETMODE_ORIGINAL ? e.setPosition(e.getOriginalPosition() + Vector3(b, c, d)) : this.mResetMode == Animation.RESETMODE_UNIT ? e.setPosition(b, c, d) : this.mResetMode == Animation.RESETMODE_NONE && e.setPosition(e.getPosition() + Vector3(b, c, d))
}, KeyFramesTranslateAnimation.prototype.initialize = function(a, b, c, d) {
    this._initialize(a, b, c, d)
};
var KeyFramesRotateAnimation = function(a, b, c) {
    Animation.call(this, a, c), this.mTarget = b, this.mIsCoordinateRelativeToScreen = !1, this.mIsDirty = !0, this.mScreenWidth = 0, this.mScreenHeight = 0, this.frameDatas = 0, this.numFrames = 0, this.kfsName = 0, this.mTransformSpace = TS_LOCAL
};
extend(KeyFramesRotateAnimation, Animation), KeyFramesRotateAnimation.prototype.MatrixQuaternionSlerpF = function(a, b, c, d) {
    var e, f, g, h;
    if (0 > d || d > 1) return a.x = 0, a.y = 0, a.z = 0, void(a.w = 1);
    if (e = b.w * c.w + b.x * c.x + b.y * c.y + b.z * c.z, 0 > e) {
        var i = new Quaternion;
        return i.x = -c.x, i.y = -c.y, i.z = -c.z, i.w = -c.w, void this.MatrixQuaternionSlerpF(a, b, i, d)
    }
    return e = e > 1 ? 1 : e, f = Math.acos(e), 0 == f ? (a.x = b.x, a.y = b.y, a.z = b.z, void(a.w = b.w)) : (g = Math.sin((1 - d) * f) / Math.sin(f), h = Math.sin(d * f) / Math.sin(f), a.x = g * b.x + h * c.x, a.y = g * b.y + h * c.y, a.z = g * b.z + h * c.z, a.w = g * b.w + h * c.w, void this.MatrixQuaternionNormalizeF(a))
}, KeyFramesRotateAnimation.prototype.MatrixQuaternionNormalizeF = function(a) {
    var b, c;
    c = a.w * a.w + a.x * a.x + a.y * a.y + a.z * a.z, b = Math.sqrt(c), 0 != b && (b = 1 / b, a.x *= b, a.y *= b, a.z *= b, a.w *= b)
}, KeyFramesRotateAnimation.prototype.setIsCoordinateRelativeToScreen = function(a) {
    this.mIsCoordinateRelativeToScreen = a, this.mIsDirty = !0
}, KeyFramesRotateAnimation.prototype.onResize = function(a, b) {
    this.mScreenWidth = a, this.mScreenHeight = b, this.mIsDirty = !0
}, KeyFramesRotateAnimation.prototype.setTransformSpace = function(a) {
    a = a.toLowerCase(), "ts_local" == a ? this.mTransformSpace = TS_LOCAL : "ts_world" == a ? this.mTransformSpace = TS_WORLD : "ts_not_add" == a ? this.mTransformSpace = TS_NOT_ADD : this.mTransformSpace = TS_PARENT
}, KeyFramesRotateAnimation.prototype.setFrameDatas = function(a) {
    this.frameDatas = a
}, KeyFramesRotateAnimation.prototype.setFrames = function(a, b) {
    if (this.kfsName = b, this.kfsName) {
        if (this.numFrames = a, !this.mRoot.getKeyFramesManager()) return !1;
        var c = this.mRoot.getKeyFramesManager().findKeyFrames(b);
        if (c) return this.setFrameDatas(c), !0
    }
    return !1
}, KeyFramesRotateAnimation.prototype.applyTransformation = function(a) {
    if (!this.frameDatas) return void console.error("frameData is null keyframesName=" + this.kfsName);
    var b = this.mTarget,
        c = new Quaternion;
    if (this.kfsName && this.numFrames) {
        var d = this.numFrames * a,
            e = Math.ceil(d),
            f = e - 1,
            g = d - f;
        if (this.frameDatas) {
            var h = this.numFrames - 1;
            if (f >= h) c.x = this.frameDatas[4 * h], c.y = this.frameDatas[4 * h + 1], c.z = this.frameDatas[4 * h + 2], c.w = this.frameDatas[4 * h + 3];
            else if (0 >= e) c.x = this.frameDatas[0], c.y = this.frameDatas[1], c.z = this.frameDatas[2], c.w = this.frameDatas[3];
            else {
                var i = new Quaternion,
                    j = new Quaternion;
                if (i.x = this.frameDatas[4 * e], i.y = this.frameDatas[4 * e + 1], i.z = this.frameDatas[4 * e + 2], i.w = this.frameDatas[4 * e + 3], j.x = this.frameDatas[4 * f], j.y = this.frameDatas[4 * f + 1], j.z = this.frameDatas[4 * f + 2], j.w = this.frameDatas[4 * f + 3], this.MatrixQuaternionSlerpF(c, j, i, g), 0 == c.x && 0 == c.y && 0 == c.z && 1 == c.w);
            }
        } else;
        this.mIsCoordinateRelativeToScreen, this.mResetMode == Animation.RESETMODE_ORIGINAL ? b.setOrientation(b.getOriginalOrientation()) : this.mResetMode == Animation.RESETMODE_UNIT && (b.resetOrientation(), b.rotate(c, this.mTransformSpace))
    }
}, KeyFramesRotateAnimation.prototype.initialize = function(a, b, c, d) {
    this._initialize(a, b, c, d)
};
var KeyFramesScaleAnimation = function(a, b, c) {
    Animation.call(this, a, c), this.mTarget = b, this.mRelative = !1, this.mIsCoordinateRelativeToScreen = !1, this.mIsDirty = !0, this.mScreenWidth = 0, this.mScreenHeight = 0, this.frameDatas = 0, this.numFrames = 0, this.kfsName = 0
};
extend(KeyFramesScaleAnimation, Animation), KeyFramesScaleAnimation.prototype.setIsCoordinateRelativeToScreen = function(a) {
    this.mIsCoordinateRelativeToScreen = a, this.mIsDirty = !0
}, KeyFramesScaleAnimation.prototype.onResize = function(a, b) {
    this.mScreenWidth = a, this.mScreenHeight = b, this.mIsDirty = !0
}, KeyFramesScaleAnimation.prototype.setTransformSpace = function(a) {
    a = a.toLowerCase(), "ts_local" == a ? this.mTransformSpace = TS_LOCAL : "ts_world" == a ? this.mTransformSpace = TS_WORLD : "ts_not_add" == a ? this.mTransformSpace = TS_NOT_ADD : this.mTransformSpace = TS_PARENT
}, KeyFramesScaleAnimation.prototype.setFrameDatas = function(a) {
    this.frameDatas = a
}, KeyFramesScaleAnimation.prototype.setFrames = function(a, b) {
    if (this.kfsName = b, this.kfsName) {
        if (this.numFrames = a, !this.mRoot.getKeyFramesManager()) return !1;
        var c = this.mRoot.getKeyFramesManager().findKeyFrames(b);
        if (c) return this.setFrameDatas(c), !0
    }
    return !1
}, KeyFramesScaleAnimation.prototype.applyTransformation = function(a) {
    if (!this.frameDatas) return void console.error("frameData is null keyframesName=" + this.kfsName);
    var b, c, d, e = this.mTarget;
    if (this.kfsName && this.numFrames) {
        var f = this.numFrames * a,
            g = Math.ceil(f) - 1,
            h = g - 1,
            i = f - g;
        if (this.frameDatas) {
            var j = this.numFrames - 1;
            g >= j ? (b = this.frameDatas[7 * j], c = this.frameDatas[7 * j + 1], d = this.frameDatas[7 * j + 2]) : 0 >= g ? (b = this.frameDatas[0], c = this.frameDatas[1], d = this.frameDatas[2]) : (b = (this.frameDatas[7 * g] - this.frameDatas[7 * h]) * i + this.frameDatas[7 * h], c = (this.frameDatas[7 * g + 1] - this.frameDatas[7 * h + 1]) * i + this.frameDatas[7 * h + 1], d = (this.frameDatas[7 * g + 2] - this.frameDatas[7 * h + 2]) * i + this.frameDatas[7 * h + 2])
        } else;
        this.mIsCoordinateRelativeToScreen, e.setScale(b, c, d)
    }
}, KeyFramesScaleAnimation.prototype.initialize = function(a, b, c, d) {
    this._initialize(a, b, c, d)
};
var SequenceFrameAnimation = function(a, b, c) {
    Animation.call(this, a, c), this.mTarget = b, this._textureUnitState = this.mTarget.getRenderer().getMaterial().getPass(0).getTextureUnitState(0), this._textureUnitState._getAnimController().setEnabled(!1)
};
extend(SequenceFrameAnimation, Animation), SequenceFrameAnimation.prototype.applyTransformation = function(a) {
    if (!(a >= 1) && this.mTarget) {
        var b = this._textureUnitState.getNumFrames(),
            c = parseInt(a * b) % b;
        this._textureUnitState.getCurrentFrame() != c && this._textureUnitState.setCurrentFrame(c)
    }
};
var Path = function() {
    this.mPathName = "", this.mControlPoints = []
};
Path.prototype = {
    constructor: Path,
    getPosition: function(a) {},
    addControlPoint: function(a) {},
    generatePath: function() {},
    releaseResource: function() {}
};
var PathAnimation = function(a, b, c) {
    Animation.call(this, a, c), this.mTarget = b, this.mPath = null, this.mHeadDirection = new Vector3(0, 1, 0), this.mNowDirect = new Vector3, this.mPreDirect = new Vector3(0, 1, 0), this.lastRotPosition = null, this.mIsRotAuto = !1
};
extend(PathAnimation, Animation), PathAnimation.prototype.applyTransformation = function(a) {
    if (a >= 0 && 1 >= a && null != this.mPath && null != this.mTarget) {
        var b = new Vector3,
            c = this.mPath.getPosition(a);
        if (b.x = c.x, b.y = c.y, b.z = c.z, null == this.lastRotPosition && this.mIsRotAuto && (this.lastRotPosition = new Vector3(b.x, b.y, b.z)), this.mIsRotAuto) {
            var d = new Vector3;
            d.x = this.lastRotPosition.x, d.y = this.lastRotPosition.y, d.z = this.lastRotPosition.z;
            var e = 1e-4;
            this.mNowDirect.x = b.x - d.x + 1e-4, this.mNowDirect.y = b.y - d.y + 2e-4, this.mNowDirect.z = b.z - d.z + 3e-4;
            var f = !this.mNowDirect.directionEquals(this.mPreDirect, e),
                g = this.mNowDirect.length() >= e;
            if (f && g) {
                var h = this.mPreDirect.cross(this.mNowDirect),
                    i = this.mPreDirect.angleBetween(this.mNowDirect);
                Math.degrees(i);
                h.normalise(), this.mTarget.resetOrientation(), this.mTarget.rotate(h, i), this.lastRotPosition.x = b.x, this.lastRotPosition.y = b.y, this.lastRotPosition.z = b.z
            }
        }
        this.mRelative ? this.mTarget.setPosition(b.x * this.mRoot.mPhoneWidth, b.y * this.mRoot.mPhoneHeight, 0) : this.mTarget.setPosition(b)
    }
}, PathAnimation.prototype.setRotAuto = function(a) {
    this.mIsRotAuto = a
}, PathAnimation.prototype.setHeadDirection = function(a) {
    return null == a ? !1 : (this.mHeadDirection.x = a.x, this.mHeadDirection.y = a.y, this.mHeadDirection.z = a.z, this.mPreDirect.x = this.mHeadDirection.x, this.mPreDirect.y = this.mHeadDirection.y, this.mPreDirect.z = this.mHeadDirection.z, !0)
}, PathAnimation.prototype.getPath = function() {
    return this.mPath
}, PathAnimation.prototype.setPath = function(a) {
    return null == a ? !1 : (this.mPath = a, !0)
};
var PathBrokenLine = function() {
    Path.call(this), this.mPointLengthMap = {}
};
extend(PathBrokenLine, Path), PathBrokenLine.prototype.getPosition = function(a) {
    var b = new Vector3;
    if (0 >= a) return this.mControlPoints[0];
    if (a >= 1) return this.mControlPoints[this.mControlPoints.length - 1];
    var c = 0,
        d = null,
        e = null,
        f = 0;
    for (var g in this.mPointLengthMap) {
        var h = (this.mPointLengthMap[g], parseFloat(g.substr(1)));
        if (h > a) {
            d = this.mControlPoints[c - 1], e = this.mControlPoints[c];
            return b.x = d.x + (e.x - d.x) * (a - f) / (h - f), b.y = d.y + (e.y - d.y) * (a - f) / (h - f), b.z = d.z + (e.z - d.z) * (a - f) / (h - f), b
        }
        f = h, c++
    }
    return b
}, PathBrokenLine.prototype.addControlPoint = function(a) {
    if (null == a) return !1;
    var b = new Vector3(a.x, a.y, a.z);
    if (this.mControlPoints.length > 0) {
        var c = this.mControlPoints[this.mControlPoints.length - 1].x - b.x,
            d = this.mControlPoints[this.mControlPoints.length - 1].y - b.y,
            e = this.mControlPoints[this.mControlPoints.length - 1].z - b.z;
        (Math.abs(c) > 0 || Math.abs(d) > 0 || Math.abs(e) > 0) && this.mControlPoints.push(b)
    } else this.mControlPoints.push(b);
    return !0
}, PathBrokenLine.prototype.generatePath = function() {
    this.mPointLengthMap = {};
    var a = null,
        b = 0;
    for (var c in this.mControlPoints) {
        var d = this.mControlPoints[c];
        null != a && (b += a.distance(d)), a = d
    }
    a = null;
    var e = 0;
    for (var c in this.mControlPoints) {
        var d = this.mControlPoints[c],
            f = 0,
            g = 0;
        null != a ? (g = a.distance(d), e += g, f = e / b) : (f = 0, g = 0), a = d, this.mPointLengthMap["_" + f] = g
    }
    return !0
}, PathBrokenLine.prototype.releaseResource = function() {
    for (var a in this.mControlPoints) a && (a = null);
    this.mControlPoints = [], this.mTangents = []
};
var PathManager = function() {
    ResourceManager.call(this), this.mPathMap = {}
};
extend(PathManager, ResourceManager), PathManager.prototype = {
    constructor: PathManager,
    createPath: function(a, b) {
        var c = null;
        return "BrokenLine" == b ? c = new PathBrokenLine : "Spline" == b ? c = new PathSpline : "SimpleBezier" == b && (c = new PathSimpleBezier), null != c && (c.mPathName = a, this.addPath(c)), c
    },
    addPath: function(a) {
        var b = this.findPath(a.mPathName);
        return b ? !1 : (this.mPathMap[a.mPathName] = a, !0)
    },
    findPath: function(a) {
        for (var b in this.mPathMap)
            if (b == a) return this.mPathMap[a];
        return 0
    },
    releaseResources: function() {
        var a = null;
        for (var b in this.mPathMap) a = this.mPathMap[b];
        this.mPathMap = {}
    },
    releaseResourceByGroupName: function(a) {},
    releaseResourceByGroupId: function(a) {
        var b = null;
        for (var c in this.mPathMap) b = this.mPathMap[c], b.mGroupId === a && b.releaseResources()
    }
};
var PathSimpleBezier = function() {
    Path.call(this), this.mBezierMap = {}, this.delta = 1e-7, this.delta_t = .0125, this.mFixedControlPoints = []
};
extend(PathSimpleBezier, Path), PathSimpleBezier.prototype.getPosition = function(a) {
    if (0 >= a) return this.mControlPoints[0];
    if (a >= 1) return this.mControlPoints[this.mControlPoints.length - 1];
    var b = this.calculateBezierPoint(a);
    return b
}, PathSimpleBezier.prototype.addControlPoint = function(a) {
    if (null == a) return !1;
    var b = new Vector3(a.x, a.y, a.z);
    return this.mControlPoints.push(b), !0
}, PathSimpleBezier.prototype.generatePath = function() {
    return this.getBezierMap(), !0
}, PathSimpleBezier.prototype.getBezierMap = function() {
    var a = this.mControlPoints.length;
    switch (a % 3) {
        case 0:
            var b = new Vector3,
                c = this.mControlPoints[this.mControlPoints.length - 1];
            b.x = this.delta + c.x, b.y = c.y, b.z = c.z, this.mControlPoints.push(b);
            break;
        case 1:
            break;
        case 2:
            var b = new Vector3,
                d = new Vector3,
                c = this.mControlPoints[this.mControlPoints.length - 1];
            b.x = this.delta + c.x, b.y = c.y, b.z = c.z, d.x = c.x, d.y = this.delta + c.y, d.z = c.z, this.mControlPoints.push(b), this.mControlPoints.push(d)
    }
    for (var e = this.mControlPoints.length, f = 0, g = [], h = [], i = 0; e - 1 > i; i += 3) {
        var j, k, l, m, n, o;
        j = this.mControlPoints[i].multiply(-1).add(this.mControlPoints[i + 1].sub(this.mControlPoints[i + 2]).multiply(3)).add(this.mControlPoints[i + 3]), k = this.mControlPoints[i].add(this.mControlPoints[i + 1].multiply(-2)).add(this.mControlPoints[i + 2]).multiply(3), l = this.mControlPoints[i].sub(this.mControlPoints[i + 1]).multiply(-3);
        var p = this.mControlPoints[i];
        m = new Vector3(p.x, p.y, p.z), n = new Vector3(p.x, p.y, p.z);
        for (var q = this.delta_t; q < 1 + this.delta_t / 2; q += this.delta_t) o = j.multiply(q).add(k).multiply(q).add(l).multiply(q).add(m), f += o.distance(n), n.x = o.x, n.y = o.y, n.z = o.z;
        var r = [];
        r.push(j), r.push(k), r.push(l), r.push(m), g.push(f), h.push(r)
    }
    for (var i = 0; i < g.length; i++) {
        var s = g[i],
            t = h[i],
            u = s / f;
        this.mBezierMap["_" + u] = t
    }
    return !0
}, PathSimpleBezier.prototype.calculateBezierPoint = function(a) {
    var b = 0,
        c = new Vector3;
    for (var d in this.mBezierMap) {
        var e = this.mBezierMap[d],
            f = parseFloat(d.substr(1));
        if (f > a) {
            var g = e[0],
                h = e[1],
                i = e[2],
                j = e[3],
                k = (a - b) / (f - b);
            k += this.delta_t;
            var l = g.multiply(k);
            return l = l.add(h), l = l.multiply(k), l = l.add(i), l = l.multiply(k), l = l.add(j), console.log(), l
        }
        b = f
    }
    return c
}, PathSimpleBezier.prototype.releaseResource = function() {
    this.mControlPoints = [], this.mBezierMap = [], this.mFixedControlPoints = []
};
var PathSpline = function() {
    Path.call(this), this.mCoeffs = new Matrix4(2, -2, 1, 1, -3, 3, -2, -1, 0, 0, 1, 0, 1, 0, 0, 0), this.mTangents = [], this.mAutoCalc = !0
};
extend(PathSpline, Path), PathSpline.prototype.getPosition = function(a) {
    new Vector3;
    if (0 >= a) return this.mControlPoints[0];
    if (a >= 1) return this.mControlPoints[this.mControlPoints.length - 1];
    var b = a * (this.mControlPoints.length - 1),
        c = parseInt(b);
    a = b - c;
    var d = this.interpolate(c, a);
    return d
}, PathSpline.prototype.addControlPoint = function(a) {
    if (null == a) return !1;
    var b = new Vector3(a.x, a.y, a.z);
    return this.mControlPoints.push(b), this.mAutoCalc && this.recalcTangents(), !0
}, PathSpline.prototype.generatePath = function() {
    return !0
}, PathSpline.prototype.interpolate = function(a, b) {
    if (a + 1 == this.mControlPoints.length) return this.mControlPoints[a];
    if (0 == b) return this.mControlPoints[a];
    if (1 == b) return this.mControlPoints[a + 1];
    var c, d;
    c = b * b, d = c * b;
    var e = new Vector4(d, c, b, 1),
        f = this.mControlPoints[a],
        g = this.mControlPoints[a + 1],
        h = this.mTangents[a],
        i = this.mTangents[a + 1],
        j = new Matrix4(f.x, f.y, f.z, 1, g.x, g.y, g.z, 1, h.x, h.y, h.z, 1, i.x, i.y, i.z, 1),
        k = e.multiply(this.mCoeffs),
        l = k.multiply(j);
    return new Vector3(l.x, l.y, l.z)
}, PathSpline.prototype.recalcTangents = function() {
    var a, b, c;
    if (b = this.mControlPoints.length, !(2 > b))
        for (c = this.mControlPoints[0] == this.mControlPoints[b - 1] ? !0 : !1, a = 0; b > a; a++) 0 == a ? c ? this.mTangents[a] = this.mControlPoints[1].sub(this.mControlPoints[b - 2]).multiply(.5) : this.mTangents[a] = this.mControlPoints[1].sub(this.mControlPoints[0]).multiply(.5) : a == b - 1 ? c ? this.mTangents[a] = this.mTangents[0] : this.mTangents[a] = this.mControlPoints[a].sub(this.mControlPoints[a - 1]).multiply(.5) : this.mTangents[a] = this.mControlPoints[a + 1].sub(this.mControlPoints[a - 1]).multiply(.5)
}, PathSpline.prototype.releaseResource = function() {
    for (var a in this.mControlPoints) a && (a = null);
    this.mControlPoints = [], this.mTangents = []
};
var AnimationUtils = function() {
    this.mIsPause = !1, this.mLastPauseTime = -1, this.mAnimSkipTimeSavePower = 0
};
AnimationUtils.prototype = {
    constructor: AnimationUtils,
    getCurrentAnimationTimeMillis: function() {
        return AnimationUtils.mTimer.getMilliseconds() - this.mAnimSkipTimeSavePower
    },
    pauseTime: function() {
        this.mIsPause || (this.mLastPauseTime = AnimationUtils.mTimer.getMilliseconds(), this.mIsPause = !0)
    },
    resumeTime: function() {
        this.mIsPause && (this.mAnimSkipTimeSavePower += AnimationUtils.mTimer.getMilliseconds() - this.mLastPauseTime, this.mLastPauseTime = -1, this.mIsPause = !1)
    },
    reset: function() {
        this.mIsPause = !1, this.mLastPauseTime = -1, this.mAnimSkipTimeSavePower = 0
    }
}, AnimationUtils.mTimer = new Timer, AnimationUtils.currentAnimationTimeMillis = function() {
    return AnimationUtils.mTimer.getMilliseconds()
};
var IMesh = function() {
        this.mAABB = new AxisAlignedBox, this.hitTest = function(a, b) {
            return !1
        }, this.setAlpha = function(a) {}, this.getBounds = function() {
            return this.mAABB
        }, this._setBounds = function(a, b) {
            this.mAABB = a;
            var c = this.mAABB.getMaximum(),
                d = this.mAABB.getMinimum();
            b || this.mAABB.setExtents(d, c)
        }
    },
    ParameterDef = function(a, b, c) {
        this.name = a, this.description = b, this.paramType = c
    },
    ParamCommand = function(a, b, c) {
        this.doGet = function() {}, this.doSet = function() {}
    },
    ParamDictionary = function() {
        this.mParamDefs = [], this.mParamCommands = {}, this.getParamCommand = function(a) {
            var b = this.mParamCommands[a];
            return b ? b : void 0
        }, this.addParameter = function(a, b) {
            this.mParamDefs.push(a), this.mParamCommands[a.name] = b
        }, this.getParameters = function() {
            return this.mParamDefs
        }
    },
    StringInterface = function() {
        this.msDictionary = {}, this.mParamDict = null, this.emptyList = [], this.createParamDictionary = function() {}, this.copyParametersTo = function(a) {
            var b = this.getParamDictionary();
            if (b)
                for (var c in b.mParamDefs) {
                    var d = b.mParamDefs[c];
                    a.setParameter(d.name, this.getParameter(d.name))
                }
        }, this.getParameter = function() {}, this.setParameterList = function(a) {}, this.setParameter = function(a, b) {
            var c = this.getParamDictionary();
            if (c) {
                var d = c.getParamCommand();
                if (d) return d.doSet(this, b), !0
            }
            return !1
        }, this.getParameters = function() {
            var a = this.getParamDictionary();
            return a ? a.getParameters() : this.emptyList
        }, this.getParamDictionary = function() {
            return this.mParamDict
        }
    },
    PT_BOOL = 0,
    PT_REAL = 1,
    PT_INT = 2,
    PT_UNSIGNED_INT = 3,
    PT_SHORT = 4,
    PT_UNSIGNED_SHORT = 5,
    PT_LONG = 6,
    PT_UNSIGNED_LONG = 7,
    PT_STRING = 8,
    PT_VECTOR3 = 9,
    PT_MATRIX3 = 10,
    PT_MATRIX4 = 11,
    PT_QUATERNION = 12,
    PT_COLOURVALUE = 13,
    PT_ENUM = 14,
    AxisAlignedBox = function() {
        this.mMinimum = new Vector3, this.mMaximum = new Vector3, this.mExtent = EXTENT_NULL, this.mCorners = null
    };
AxisAlignedBox.prototype = {
    constructor: AxisAlignedBox,
    getMinimum: function() {
        return this.mMinimum
    },
    getMaximum: function() {
        return this.mMaximum
    },
    setMinimum: function(a, b, c) {
        if (this.mExtent = EXTENT_FINITE, 3 == arguments.length) this.mMinimum.x = a, this.mMinimum.y = b, this.mMinimum.z = c;
        else if (1 == arguments.length) {
            var d = arguments[0];
            this.mMinimum.x = d.x, this.mMinimum.y = d.y, this.mMinimum.z = d.z
        }
    },
    setMinimumX: function(a) {
        this.mMinimum.x = a
    },
    setMinimumY: function(a) {
        this.mMinimum.y = a
    },
    setMinimumZ: function(a) {
        this.mMinimum.z = a
    },
    setMaximum: function(a, b, c) {
        if (this.mExtent = EXTENT_FINITE, 3 == arguments.length) this.mMaximum.x = a, this.mMaximum.y = b, this.mMaximum.z = c;
        else if (1 == arguments.length) {
            var d = arguments[0];
            this.mMaximum.x = d.x, this.mMaximum.y = d.y, this.mMaximum.z = d.z
        }
    },
    setMaximumX: function(a) {
        this.mMaximum.x = a
    },
    setMaximumY: function(a) {
        this.mMaximum.y = a
    },
    setMaximumZ: function(a) {
        this.mMaximum.z = a
    },
    setExtents: function(a, b, c, d, e, f) {
        if (this.mExtent = EXTENT_FINITE, 6 == arguments.length) this.mMinimum.x = a, this.mMinimum.y = b, this.mMinimum.z = c, this.mMaximum.x = d, this.mMaximum.y = e, this.mMaximum.z = f;
        else if (2 == arguments.length) {
            var g = arguments[0],
                h = arguments[1];
            this.mMinimum.x = g.x, this.mMinimum.y = g.y, this.mMinimum.z = g.z, this.mMaximum.x = h.x, this.mMaximum.y = h.y, this.mMaximum.z = h.z
        }
    },
    getAllCorners: function() {
        return this.mCorners || (this.mCorners = []), this.mCorners[0] = this.mMinimum, this.mCorners[1].x = this.mMinimum.x, this.mCorners[1].y = this.mMaximum.y, this.mCorners[1].z = this.mMinimum.z, this.mCorners[2].x = this.mMaximum.x, this.mCorners[2].y = this.mMaximum.y, this.mCorners[2].z = this.mMinimum.z, this.mCorners[3].x = this.mMaximum.x, this.mCorners[3].y = this.mMinimum.y, this.mCorners[3].z = this.mMinimum.z, this.mCorners[4] = this.mMaximum, this.mCorners[5].x = this.mMinimum.x, this.mCorners[5].y = this.mMaximum.y, this.mCorners[5].z = this.mMaximum.z, this.mCorners[6].x = this.mMinimum.x, this.mCorners[6].y = this.mMinimum.y, this.mCorners[6].z = this.mMaximum.z, this.mCorners[7].x = this.mMaximum.x, this.mCorners[7].y = this.mMinimum.y, this.mCorners[7].z = this.mMaximum.z, this.mCorners
    },
    getCorner: function(a) {
        switch (a) {
            case FAR_LEFT_BOTTOM:
                return this.mMinimum;
            case FAR_LEFT_TOP:
                return new Vector3(this.mMinimum.x, this.mMaximum.y, this.mMinimum.z);
            case FAR_RIGHT_TOP:
                return new Vector3(this.mMaximum.x, this.mMaximum.y, this.mMinimum.z);
            case FAR_RIGHT_BOTTOM:
                return new Vector3(this.mMaximum.x, this.mMinimum.y, this.mMinimum.z);
            case NEAR_RIGHT_BOTTOM:
                return new Vector3(this.mMaximum.x, this.mMinimum.y, this.mMaximum.z);
            case NEAR_LEFT_BOTTOM:
                return new Vector3(this.mMinimum.x, this.mMinimum.y, this.mMaximum.z);
            case NEAR_LEFT_TOP:
                return new Vector3(this.mMinimum.x, this.mMaximum.y, this.mMaximum.z);
            case NEAR_RIGHT_TOP:
                return this.mMaximum;
            default:
                return new Vector3
        }
    },
    toString: function() {},
    merge: function(a) {
        if (arguments[0] instanceof AxisAlignedBox) {
            if (a.mExtent == EXTENT_NULL || this.mExtent == EXTENT_INFINITE) return;
            if (a.mExtent == EXTENT_INFINITE) this.mExtent = EXTENT_INFINITE;
            else if (this.mExtent == EXTENT_NULL) this.setExtents(a.mMinimum, a.mMaximum);
            else {
                var b = this.mMinimum,
                    c = this.mMaximum;
                c.makeCeil(a.mMaximum), b.makeCeil(a.mMinimum), this.setExtents(b, c)
            }
        } else if (arguments[0] instanceof Vector3) {
            var d = arguments[0];
            switch (this.mExtent) {
                case EXTENT_NULL:
                    return void this.setExtents(d, d);
                case EXTENT_FINITE:
                    return this.mMaximum.makeCeil(d), void this.mMinimum.makeFloor(d);
                case EXTENT_INFINITE:
                    return
            }
        }
    },
    transform: function(a) {
        if (this.mExtent == EXTENT_FINITE) {
            var b = new Vector3,
                c = new Vector3,
                d = new Vector3;
            b = this.mMinimum, c = this.mMaximum, this.setNull(), d = b, this.merge(a.multiply(d)), d.z = c.z, this.merge(a.multiply(d)), d.y = c.y, this.merge(a.multiply(d)), d.z = b.z, this.merge(a.multiply(d)), d.x = c.x, this.merge(a.multiply(d)), d.z = c.z, this.merge(a.multiply(d)), d.y = b.y, this.merge(a.multiply(d)), d.z = b.z, this.merge(a.multiply(d))
        }
    },
    transformAffine: function(a) {
        if (a.isAffine()) return void console.error("assert(m.isAffine());");
        if (this.mExtent == EXTENT_FINITE) {
            var b = this.getCenter(),
                c = this.getHalfSize(),
                d = a.m,
                e = a.transformAffine(b),
                f = new Vector3(Math.abs(d[0]) * c.x + Math.abs(d[1]) * c.y + Math.abs(d[2]) * c.z, Math.abs(d[4]) * c.x + Math.abs(d[5]) * c.y + Math.abs(d[6]) * c.z, Math.abs(d[7]) * c.x + Math.abs(d[8]) * c.y + Math.abs(d[9]) * c.z);
            this.setExtents(e.sub(f), e.add(f))
        }
    },
    setNull: function() {
        this.mExtent = EXTENT_NULL
    },
    isNull: function() {
        return this.mExtent == EXTENT_NULL
    },
    isFinite: function() {
        return this.mExtent == EXTENT_INFINITE
    },
    setInfinite: function() {
        this.mExtent = EXTENT_INFINITE
    },
    isInfinite: function() {
        return this.mExtent == EXTENT_INFINITE
    },
    intersects: function(a) {},
    intersection: function(a) {
        if (this.isNull() || a.isNull()) return new AxisAlignedBox;
        if (this.isInfinite()) return a;
        if (a.isInfinite()) return this;
        var b = this.mMinimum,
            c = this.mMaximum;
        return b.makeCeil(a.getMinimum()), c.makeFloor(a.getMaximum()), b.x < c.x && b.y < c.y && b.z < c.z ? new AxisAlignedBox(b, c) : new AxisAlignedBox
    },
    volume: function() {
        switch (this.mExtent) {
            case EXTENT_NULL:
                return 0;
            case EXTENT_FINITE:
                var a = this.mMaximum.sub(this.mMinimum);
                return a.x * a.y * a.z;
            case EXTENT_INFINITE:
                return Math.POS_INFINITY;
            default:
                return console.error("Never reached"), 0
        }
    },
    scale: function(a) {
        if (this.mExtent == EXTENT_FINITE) {
            var b = this.mMinimum.multiply(a),
                c = this.mMaximum.multiply(a);
            this.setExtents(b, c)
        }
    },
    getCenter: function() {
        return new Vector3(.5 * (this.mMaximum.x + this.mMinimum.x), .5 * (this.mMaximum.y + this.mMinimum.y), .5 * (this.mMaximum.z + this.mMinimum.z))
    },
    getSize: function() {
        switch (this.mExtent) {
            case EXTENT_NULL:
                return new Vector3(0, 0, 0);
            case EXTENT_FINITE:
                return this.mMaximum.sub(this.mMinimum);
            case EXTENT_INFINITE:
                return new Vector3(Math.POS_INFINITY, Math.POS_INFINITY, Math.POS_INFINITY);
            default:
                return console.error("Never reached"), new Vector3(0, 0, 0)
        }
    },
    getHalfSize: function(a) {
        switch (this.mExtent) {
            case EXTENT_NULL:
                return new Vector3(0, 0, 0);
            case EXTENT_FINITE:
                return this.mMaximum.sub(this.mMinimum).multiply(.5);
            case EXTENT_INFINITE:
                return new Vector3(Math.POS_INFINITY, Math.POS_INFINITY, Math.POS_INFINITY);
            default:
                return console.error("Never reached"), new Vector3(0, 0, 0)
        }
    },
    contains: function(a) {
        if (this.isNull()) return !1;
        if (this.isInfinite()) return !0;
        if (arguments[0] instanceof Vector3) return this.mMinimum.x <= a.x && a.x <= this.mMaximum.x && this.mMinimum.y <= a.y && a.y <= this.mMaximum.y && this.mMinimum.z <= a.z && a.z <= this.mMaximum.z;
        if (arguments[0] instanceof AxisAlignedBox) {
            var b = arguments[0];
            return this.mMinimum.x <= b.mMinimum.x && this.mMinimum.y <= b.mMinimum.y && this.mMinimum.z <= b.mMinimum.z && b.mMaximum.x <= this.mMaximum.x && b.mMaximum.y <= this.mMaximum.y && b.mMaximum.z <= this.mMaximum.z
        }
    },
    squaredDistance: function(a) {
        if (this.contains(a)) return 0;
        var b = new Vector3(0, 0, 0);
        return a.x < this.mMinimum.x ? b.x = this.mMinimum.x - a.x : a.x > this.mMaximum.x && (b.x = a.x - this.mMaximum.x), a.y < this.mMinimum.y ? b.y = this.mMinimum.y - a.y : a.y > this.mMaximum.y && (b.y = a.y - this.mMaximum.y), a.z < this.mMinimum.z ? b.z = this.mMinimum.z - a.z : a.z > this.mMaximum.z && (b.z = a.z - this.mMaximum.z), b.squaredLength()
    },
    distance: function(a) {
        return Math.sqrt(this.squaredDistance(a))
    },
    copy: function(a) {},
    equals: function(a) {
        return this.mExtent != a.mExtent ? !1 : this.isFinite() ? this.mMinimum == a.mMinimum && this.mMaximum == a.mMaximum : !0
    },
    notEquals: function(a) {
        return !this.equals(a)
    }
};
var EXTENT_NULL = 0,
    EXTENT_FINITE = 1,
    EXTENT_INFINITE = 2,
    BOX_NULL, BOX_INFINITE = EXTENT_INFINITE,
    FAR_LEFT_BOTTOM = 0,
    FAR_LEFT_TOP = 1,
    FAR_RIGHT_TOP = 2,
    FAR_RIGHT_BOTTOM = 3,
    NEAR_RIGHT_BOTTOM = 7,
    NEAR_LEFT_BOTTOM = 6,
    NEAR_LEFT_TOP = 5,
    NEAR_RIGHT_TOP = 4,
    RenderOperation = function() {
        this.vertexData = null, this.operationType = RenderOperation.OT_TRIANGLE_LIST, this.useIndexes = !0, this.indexData = null, this.numberOfInstances = 1, this.useGlobalInstancingVertexBufferIsAvailable = !0
    };
RenderOperation.OT_POINT_LIST = 1, RenderOperation.OT_LINE_LIST = 2, RenderOperation.OT_LINE_STRIP = 3, RenderOperation.OT_TRIANGLE_LIST = 4, RenderOperation.OT_TRIANGLE_STRIP = 5, RenderOperation.OT_TRIANGLE_FAN = 6, RenderOperation.OT_PATCH_1_CONTROL_POINT = 7, RenderOperation.OT_PATCH_2_CONTROL_POINT = 8, RenderOperation.OT_PATCH_3_CONTROL_POINT = 9, RenderOperation.OT_PATCH_4_CONTROL_POINT = 10, RenderOperation.OT_PATCH_5_CONTROL_POINT = 11, RenderOperation.OT_PATCH_6_CONTROL_POINT = 12, RenderOperation.OT_PATCH_7_CONTROL_POINT = 13, RenderOperation.OT_PATCH_8_CONTROL_POINT = 14, RenderOperation.OT_PATCH_9_CONTROL_POINT = 15, RenderOperation.OT_PATCH_10_CONTROL_POINT = 16, RenderOperation.OT_PATCH_11_CONTROL_POINT = 17, RenderOperation.OT_PATCH_12_CONTROL_POINT = 18, RenderOperation.OT_PATCH_13_CONTROL_POINT = 19, RenderOperation.OT_PATCH_14_CONTROL_POINT = 20, RenderOperation.OT_PATCH_15_CONTROL_POINT = 21, RenderOperation.OT_PATCH_16_CONTROL_POINT = 22, RenderOperation.OT_PATCH_17_CONTROL_POINT = 23, RenderOperation.OT_PATCH_18_CONTROL_POINT = 24, RenderOperation.OT_PATCH_19_CONTROL_POINT = 25, RenderOperation.OT_PATCH_20_CONTROL_POINT = 26, RenderOperation.OT_PATCH_21_CONTROL_POINT = 27, RenderOperation.OT_PATCH_22_CONTROL_POINT = 28, RenderOperation.OT_PATCH_23_CONTROL_POINT = 29, RenderOperation.OT_PATCH_24_CONTROL_POINT = 30, RenderOperation.OT_PATCH_25_CONTROL_POINT = 31, RenderOperation.OT_PATCH_26_CONTROL_POINT = 32, RenderOperation.OT_PATCH_27_CONTROL_POINT = 33, RenderOperation.OT_PATCH_28_CONTROL_POINT = 34, RenderOperation.OT_PATCH_29_CONTROL_POINT = 35, RenderOperation.OT_PATCH_30_CONTROL_POINT = 36, RenderOperation.OT_PATCH_31_CONTROL_POINT = 37, RenderOperation.OT_PATCH_32_CONTROL_POINT = 38;
var ParticleVisualData = function() {};
ParticleVisualData.prototype = {
    constructor: ParticleVisualData
};
var Particle = function() {
    this.mParentSystem = null, this.mVisual = new ParticleVisualData, this.mMaxWidth = 0, this.mMaxHeight = 0, this.mOwnDimensions = !1, this.mWidth = 140, this.mHeight = 140, this.rotation = 0, this.position = new Vector3(0, 0, 0), this.direction = new Vector3, this.colour = new ColourValue(1, 1, 1, 1), this.timeToLive = 10, this.totalTimeToLive = 10, this.rotationSpeed = 0, this.particleType = Particle.Visual, this.mTexcoordIndex = 0, this.mRotateAxis = new Vector3(0, 0, 1), this.mIsDefaultRotAxis = !0, this.mName = "", this.mRandomFlag = 0, this.isClickable = !0
};
Particle.prototype = {
    constructor: Particle,
    setDimensions: function(a, b) {
        this.mOwnDimensions = !0;
        var c = !1;
        (this.mMaxWidth < 0 && this.mMaxHeight < 0 || a <= this.mMaxWidth && b <= this.mMaxHeight) && (this.mWidth = a, this.mHeight = b, c = !0), c && this.mParentSystem._notifyParticleResized()
    },
    setTexcoordIndex: function(a) {
        this.mTexcoordIndex = a
    },
    getTexcoordIndex: function() {
        return this.mTexcoordIndex
    },
    hasOwnDimensions: function() {
        return this.mOwnDimensions
    },
    getOwnWidth: function() {
        return this.mWidth
    },
    getOwnHeight: function() {
        return this.mHeight
    },
    setRotation: function(a) {
        this.rotation = a, 0 != this.rotation && this.mParentSystem._notifyParticleRotated()
    },
    getRotation: function() {
        return this.rotation
    },
    _notifyOwner: function(a) {
        this.mParentSystem = a
    },
    _notifyVisualData: function(a) {
        this.mVisual = a
    },
    getVisualData: function() {
        return this.mVisual
    },
    resetDimensions: function() {
        this.mOwnDimensions = !1
    }
}, Particle.Visual = 0, Particle.Emitter = 1;
var ParticleAffector = function(a) {
    this.mType = "", this.mParent = a
};
ParticleAffector.prototype = {
    constructor: ParticleAffector,
    addBaseParameters: function() {},
    _initParticle: function(a) {},
    _affectParticles: function(a, b) {},
    getType: function() {
        return this.mType
    }
};
var ParticleAffectorFactory = function() {
    this.mAffectors = []
};
ParticleAffectorFactory.prototype = {
    constructor: ParticleAffectorFactory,
    getName: function() {},
    createAffector: function(a) {},
    destroyAffector: function(a) {}
};
var ParticleEmitter = function(a) {
    StringInterface.call(this), Particle.call(this), this.mParent = a || new ParticleSystem, this.mPosition = new Vector3, this.mEmissionRate = 10, this.mType = "", this.mDirection = new Vector3, this.mUp = new Vector3, this.mAngle = 0, this.mMinSpeed = 1, this.mMaxSpeed = 1, this.mMinTTL = 5, this.mMaxTTL = 5, this.mColourRangeStart = ColourValue.White, this.mColourRangeEnd = ColourValue.White, this.mEnabled = !0, this.mStartTime = 0, this.mDurationMin = 0, this.mDurationMax = 0, this.mDurationRemain = 0, this.mRepeatDelayMin = 0, this.mRepeatDelayMax = 0, this.mRepeatDelayRemain = 0, this.mRemainder = 0, this.mRandomRangeStart = -10, this.mRandomRangeEnd = 10, this.mEmittedEmitter = "", this.mEmitted = !1, this.mMaxWidth = -1, this.mMaxHeight = -1, this.mIsMaxSizeFixed = !1, this.mMaxSizeFactor = -1, this.mIsPositionFixed = !0, this.mPositionXFactor = -1, this.mPositionYFactor = -1, this.mMinTexcoordIndex = 0, this.mMaxTexcoordIndex = 0, this.mIsAngleDirectionSysc = !1, this.mDirection = new Vector3(1, 0, 0), this.mDirection.normalise(), this.mUp = this.mDirection.perpendicular(), this.mUp.normalise()
};
ParticleEmitter.prototype = {
    constructor: ParticleEmitter,
    setPosition: function(a, b, c) {
        if (1 == arguments.length) this.mPosition.copy(arguments[0]);
        else {
            var d = new Vector3(a, b, c);
            this.mPosition.copy(d)
        }
    },
    getPosition: function() {
        return this.mPosition
    },
    setDirection: function(a) {
        this.mDirection = a, this.mDirection.normalise(), this.mUp = this.mDirection.perpendicular(), this.mUp.normalise()
    },
    getDirection: function() {
        return this.mDirection
    },
    setAngle: function(a) {
        this.mAngle = Math.radians(a)
    },
    getAngle: function() {
        return this.mAngle
    },
    setParticleVelocity: function(a, b) {
        1 == arguments.length ? (this.mMinSpeed = arguments[0], this.mMaxSpeed = arguments[0]) : 2 == arguments.length && (this.mMinSpeed = a, this.mMaxSpeed = b)
    },
    setMinParicleVelocity: function(a) {
        this.mMinSpeed = a
    },
    setMaxParicleVelocity: function(a) {
        this.mMaxSpeed = a
    },
    getParticleVelocity: function() {
        return this.mMinSpeed
    },
    getMinParticleelocity: function() {
        return this.mMinSpeed
    },
    getMaxParticleVelocity: function() {
        return this.mMaxSpeed
    },
    setEmissionRate: function(a) {
        this.mEmissionRate = a
    },
    getEmissionRate: function() {
        return this.mEmissionRate
    },
    setTimeToLive: function(a, b) {
        1 == arguments.length ? (this.mMinTTL = arguments[0], this.mMaxTTL = arguments[0]) : 2 == arguments.length && (this.mMinTTL = a, this.mMaxTTL = b)
    },
    setMinTimeToLive: function(a) {
        this.mMinTTL = a
    },
    setMaxTimeToLive: function(a) {
        this.mMaxTTL = a
    },
    getTimeToLive: function() {
        return this.mMinTTL
    },
    getMinTimeToLive: function() {
        return this.mMinTTL
    },
    getMaxTimeToLive: function() {
        return this.mMaxTTL
    },
    setColour: function(a, b) {
        1 == arguments.length ? (this.mColourRangeStart = arguments[0], this.mColourRangeEnd = arguments[0]) : 2 == arguments.length && (this.mColourRangeStart = a, this.mColourRangeEnd = b)
    },
    setColourRangeStart: function(a) {
        this.mColourRangeStart = a
    },
    setColourRangeEnd: function(a) {
        this.mColourRangeEnd = a
    },
    getColour: function() {
        return this.mColourRangeStart
    },
    getColourRangeStart: function() {
        return this.mColourRangeEnd
    },
    getColourRangeEnd: function() {
        return this.mColourRangeEnd
    },
    _getEmissionCount: function(a) {},
    initParticle: function(a) {
        a.resetDimensions(), a.mTexcoordIndex = this.genTexcoordIndex(), "" != this.mEmittedEmitter ? a.mName = this.mEmittedEmitter : a.mName = this.mName, a.isClickable = !0, a.mRandomFlag = Math.rangeRandom(this.mRandomRangeStart, this.mRandomRangeEnd), a.mMaxWidth = this.mMaxWidth, a.mMaxHeight = this.mMaxHeight
    },
    _initParticle: function(a) {
        a.resetDimensions(), a.mTexcoordIndex = this.genTexcoordIndex(), "" != this.mEmittedEmitter ? a.mName = this.mEmittedEmitter : a.mName = this.mName, a.isClickable = !0, a.mRandomFlag = Math.rangeRandom(this.mRandomRangeStart, this.mRandomRangeEnd), a.mMaxWidth = this.mMaxWidth, a.mMaxHeight = this.mMaxHeight
    },
    getType: function() {
        return this.mType
    },
    setEnabled: function(a) {
        this.mEnabled = a, this.initDurationRepeat()
    },
    getEnabled: function() {
        return this.mEnabled
    },
    setStartTime: function(a) {
        this.setEnabled(!1), this.mStartTime = a
    },
    getStartTime: function() {
        return this.mStartTime
    },
    setDuration: function(a, b) {
        1 == arguments.length ? (this.mDurationMin = arguments[0], this.mDurationMax = arguments[0], this.initDurationRepeat()) : 2 == arguments.length && (this.mDurationMin = a, this.mDurationMax = b, this.initDurationRepeat())
    },
    setMinDuration: function(a) {
        this.mDurationMin = a, this.initDurationRepeat()
    },
    setMaxDuration: function(a) {
        this.mDurationMax = a, this.initDurationRepeat()
    },
    getDuration: function() {
        return this.mDurationMin
    },
    getMinDuration: function() {
        return this.mDurationMin
    },
    getMaxDuration: function() {
        return this.mDurationMax
    },
    setRepeatDelay: function(a, b) {
        1 == arguments.length ? (this.mRepeatDelayMin = arguments[0], this.mRepeatDelayMax = arguments[0]) : 2 == arguments.length && (this.mRepeatDelayMin = a, this.mRepeatDelayMax = b), this.initDurationRepeat()
    },
    setMinRepeatDelay: function(a) {
        this.mRepeatDelayMin = a, this.initDurationRepeat()
    },
    setMaxRepeatDelay: function(a) {
        this.mRepeatDelayMax = a, this.initDurationRepeat()
    },
    getRepeateDelay: function() {
        return this.mRepeatDelayMin
    },
    getMinRepeateDelay: function() {
        return this.mRepeatDelayMin
    },
    getMaxRepeateDelay: function() {
        return this.mRepeatDelayMax
    },
    getName: function() {
        return this.mName
    },
    setName: function(a) {
        this.mName = a
    },
    getEmittedEmitter: function() {
        return this.mEmittedEmitter
    },
    setEmittedEmitter: function(a) {
        this.mEmittedEmitter = a
    },
    isEmitted: function() {
        return this.mEmitted
    },
    setEmitted: function(a) {
        this.mEmitted = a
    },
    genTexcoordIndex: function() {
        return this.mMinTexcoordIndex != this.mMaxTexcoordIndex ? parseInt(Math.rangeRandom(this.mMinTexcoordIndex, this.mMaxTexcoordIndex)) : this.mMinTexcoordIndex
    },
    getMinTexcoordIndex: function() {
        return this.mMinTexcoordIndex
    },
    setMinTexcoordIndex: function(a) {
        this.mMinTexcoordIndex = a
    },
    getMaxTexcoordIndex: function() {
        return this.mMaxTexcoordIndex
    },
    setMaxTexcoordIndex: function(a) {
        return this.mMaxTexcoordIndex = a
    },
    setTexcoordIndex: function(a) {
        this.mMinTexcoordIndex = a, this.mMaxTexcoordIndex = a, this.mTexcoordIndex = a
    },
    enableAngleDirecitonSync: function(a) {
        this.mIsAngleDirectionSysc = a
    },
    isAngleDirecitonSync: function() {
        return this.mIsAngleDirectionSysc
    },
    getMaxWidth: function() {
        return this.mMaxWidth
    },
    setMaxWidth: function(a) {
        this.mMaxWidth = a
    },
    getMaxHeight: function() {
        return this.mMaxHeight
    },
    setMaxHeight: function(a) {
        this.mMaxHeight = a
    },
    getMaxSizeFactor: function() {
        return this.mMaxSizeFactor
    },
    setMaxSizeFactor: function(a) {
        this.mMaxSizeFactor = a
    },
    isMaxSizeFixed: function() {
        return this.mIsMaxSizeFixed
    },
    enableMaxSizeFixed: function(a) {
        this.mIsMaxSizeFixed = a
    },
    getPositionFactor: function() {
        return this.mPositionXFactor
    },
    setPositionFactor: function(a) {
        this.mPositionXFactor = a, this.mIsPositionFixed = !1
    },
    getPositionXFactor: function() {
        return this.mPositionXFactor
    },
    setPositionXFactor: function(a) {
        this.mPositionXFactor = a, this.mIsPositionFixed = !1
    },
    getPositionYFactor: function() {
        return this.mPositionYFactor
    },
    setPositionYFactor: function(a) {
        this.mPositionYFactor = a, this.mIsPositionFixed = !1
    },
    getPositionZFactor: function() {
        return this.mPositionZFactor
    },
    setPositionZFactor: function(a) {
        this.mPositionZFactor = a, this.mIsPositionFixed = !1
    },
    RecalcuMaxSize: function(a, b) {
        this.mIsMaxSizeFixed || this.mMaxSizeFactor > 0 && (this.mMaxWidth = this.mMaxSizeFactor * a, this.mMaxHeight = this.mMaxSizeFactor * b)
    },
    RecalcuPosition: function(a, b) {
        this.mIsPositionFixed || (this.mPosition.x = this.mPositionXFactor * a, this.mPosition.y = this.mPositionYFactor * b)
    },
    _resize: function(a, b) {
        this.RecalcuMaxSize(a, b), this.RecalcuPosition(a, b)
    },
    resize: function(a, b) {
        this.RecalcuMaxSize(a, b), this.RecalcuPosition(a, b)
    },
    copyParametersTo: function(a) {
        this.mIsMaxSizeFixed || this.mMaxSizeFactor > 0 && (a.mMaxWidth = this.mMaxWidth, a.mMaxHeight = this.mMaxHeight), this.mIsPositionFixed || (a.mPosition.x = this.mPosition.x, a.mPosition.y = this.mPosition.y)
    },
    genEmissionDirection: function(a) {
        if (0 != this.mAngle) {
            var b = Math.random() * this.mAngle;
            a.copy(this.mDirection.randomDeviant(b, this.mUp))
        } else a.copy(this.mDirection)
    },
    genEmissionVelocity: function(a) {
        var b;
        return b = this.mMinSpeed != this.mMaxSpeed ? this.mMinSpeed + Math.random() * (this.mMaxSpeed - this.mMinSpeed) : this.mMinSpeed, a.copy(a.multiply(b)), a
    },
    genEmissionTTL: function() {
        return this.mMaxTTL != this.mMinTTL ? this.mMinTTL + Math.random() * (this.mMaxTTL - this.mMinTTL) : this.mMinTTL
    },
    genConstantEmissionCount: function(a) {
        var b;
        return this.mEnabled ? (this.mRemainder += this.mEmissionRate * a, b = parseInt(this.mRemainder), this.mRemainder -= b, this.mDurationMax && (this.mDurationRemain -= a, this.mDurationRemain <= 0 && this.setEnabled(!1)), b) : (this.mRepeatDelayMax && (this.mRepeatDelayRemain -= a, this.mRepeatDelayRemain <= 0 && this.setEnabled(!0)), this.mStartTime && (this.mStartTime -= a, this.mStartTime <= 0 && (this.setEnabled(!0), this.mStartTime = 0)), 0)
    },
    genEmissionColour: function(a) {
        a = a || new ColourValue(1, 1, 1, 1), this.mColourRangeStart.equals(this.mColourRangeEnd) ? a.copy(this.mColourRangeStart) : (a.r = this.mColourRangeStart.r + Math.random() * (this.mColourRangeStart.r - this.mColourRangeEnd.r), a.g = this.mColourRangeStart.g + Math.random() * (this.mColourRangeStart.g - this.mColourRangeEnd.g), a.b = this.mColourRangeStart.b + Math.random() * (this.mColourRangeStart.b - this.mColourRangeEnd.b), a.a = this.mColourRangeStart.a + Math.random() * (this.mColourRangeStart.a - this.mColourRangeEnd.a))
    },
    addBaseParameters: function() {},
    initDurationRepeat: function() {
        this.mEnabled ? this.mDurationMin == this.mDurationMax ? this.mDurationRemain = this.mDurationMin : this.mDurationRemain = Math.rangeRandom(this.mDurationMin, this.mDurationMax) : this.mRepeatDelayMin == this.mRepeatDelayMax ? this.mRepeatDelayRemain = this.mRepeatDelayMin : this.mRepeatDelayRemain = Math.rangeRandom(this.mRepeatDelayMax, this.mRepeatDelayMin)
    }
};
var ParticleEmitterFactory = function() {
    this.mEmitters = []
};
ParticleEmitterFactory.prototype = {
    constructor: ParticleEmitterFactory,
    getName: function() {},
    createEmitter: function(a) {},
    destroyEmitter: function(a) {}
};
var ParticleSystem = function(a, b) {
    IMesh.call(this), StringInterface.call(this), this.mRoot = a, this.mParticleSystemManager = this.mRoot.mParticleSystemManager, this.requested = [], this.mParentGo = null, this.mUVSSetStr = "", this.mParticlesType = 0, this.mBoundingRadius = 0, this.mBoundsAutoUpdate = !0, this.mBoundsUpdateTime = 10, this.mUpdateRemainTime = 0, this.mName = "", this.mBeStop = !1, this.mStacks = 1, this.mSlices = 1, this.mResourceGroupName = b || "", this.mMaterialName = "", this.mIsRendererConfigured = !1, this.mDefaultWidth = 0, this.mDefaultHeight = 0, this.mSpeedFactor = 1, this.mIterationInterval = 0, this.mIterationIntervalSet = !1, this.mSorted = !1, this.mLocalSpace = !1, this.mNonvisibleTimeout = 0, this.mNonvisibleTimeoutSet = !1, this.mTimeSinceLastVisible = 0, this.mLastVisibleFrame = 0, this.mEmittedEmitterPoolInitialised = !1, this.mIsEmitting = !0, this.mIsAlwaysGeneratePartices = !1, this.mStickToFinger = !1, this.mHasTouchEvent = !0, this.mDynamicBinding = !1, this.mIsDefaultDimensionsFixed = !0, this.mDefaultWidthFactor = -1, this.mDefaultHeightFactor = -1, this.mAspectratio = -1, this.mIsEmitDelaySet = !1, this.mMinEmitDelayTime = 0, this.mMaxEmitDelayTime = 0, this.mEmitRemainTime = 0, this.mIsEmitDelaying = !0, this.msDefaultIterationInterval = 0, this.msDefaultNonvisibleTimeout = 0, this.mActiveParticles = [], this.mFreeParticles = [], this.mParticlePool = [], this.mEmittedEmitterPool = {}, this.mFreeEmittedEmitters = {}, this.mActiveEmittedEmitters = [], this.mEmitters = [], this.mAffectors = [], this.mRenderer = null, this.mCullIndividual = !1, this.mRendererType = "", this.mPoolSize = 0, this.mCurrentValidSize = 0, this.mMinValidSize = 0, this.mMaxValidSize = 0, this.mEmittedEmitterPoolSize = 0, this.mOrigin = null, this.setRenderer("billboard"), this.setDefaultDimensions(100, 100), this.setParticleQuota(10), this.setEmittedEmitterQuota(3)
};
extend(ParticleSystem, StringInterface), ParticleSystem.prototype.getParentGameObject = function() {
    return this.mParentGo
}, ParticleSystem.prototype.setParentGameObject = function(a) {
    this.mRenderer.setCurrentParentGameObject(a), this.mParentGo = a
}, ParticleSystem.prototype.setRenderer = function(a) {
    this.mRenderer && (this.destroyVisualParticles(0, this.mParticlePool.length), this.mParticleSystemManager._destroyRenderer(this.mRenderer), this.mRenderer = 0), a && (this.mRenderer = this.mParticleSystemManager._createRenderer(a), this.mIsRendererConfigured = !1), this.mRenderer && (this.mRenderer.currentParticleSystem = this)
}, ParticleSystem.prototype.getRenderer = function() {
    return this.mRenderer
}, ParticleSystem.prototype.getRendererName = function() {
    return this.mRenderer ? this.mRenderer.getType() : ""
}, ParticleSystem.prototype.addEmitter = function(a) {
    var b = this.mParticleSystemManager._createEmitter(a, this);
    return null != b && this.mEmitters.push(b), b
}, ParticleSystem.prototype.getEmitter = function(a) {
    return this.mEmitters[a]
}, ParticleSystem.prototype.getNumEmitters = function() {
    return this.mEmitters.length
}, ParticleSystem.prototype.removeEmitter = function(a) {
    var b = this.mEmitters[a];
    this.mParticleSystemManager._destroyEmitter(b), this.mEmitters.splice(a, 1)
}, ParticleSystem.prototype.removeAllEmitters = function() {
    var a;
    for (var b in this.mEmitters) a = this.mEmitters[b], this.mParticleSystemManager._destroyEmitter(a), delete this.mEmitters[b];
    this.mEmitters.length = 0
}, ParticleSystem.prototype.addAffector = function(a) {
    var b = this.mParticleSystemManager._createAffector(a, this);
    return null != b && this.mAffectors.push(b), b
}, ParticleSystem.prototype.getAffector = function(a) {
    return this.mAffectors[a]
}, ParticleSystem.prototype.getNumAffectors = function() {
    return this.mAffectors.length
}, ParticleSystem.prototype.removeAffector = function(a) {
    var b = this.mAffectors[a];
    this.mParticleSystemManager._destroyAffector(b), this.mAffectors.splice(a, 1)
}, ParticleSystem.prototype.removeAllAffectors = function() {
    for (var a in this.mAffectors) {
        var b = this.mAffectors[a];
        this.mParticleSystemManager._destroyAffector(b)
    }
    this.mAffectors.length = 0
}, ParticleSystem.prototype.clear = function() {
    this.mRenderer && this.mRenderer._notifyParticleCleared(this.mActiveParticles), this.mFreeParticles.concat(this.mActiveParticles.slices(0)), this.addActiveEmittedEmittersToFreeList(), this.mActiveEmittedEmitters.length = 0, this.mUpdateRemainTime = 0
}, ParticleSystem.prototype.getNumParticles = function() {
    return this.mActiveParticles.length
}, ParticleSystem.prototype.createParticle = function() {
    var a = null;
    return this.mFreeParticles.length > 0 && (a = this.mFreeParticles.shift(), this.mActiveParticles.push(a), a._notifyOwner(this)), a
}, ParticleSystem.prototype.createEmitterParticle = function(a) {
    var b, c = this.findFreeEmittedEmitter(a);
    return c && c.length > 0 && (b = c.shift(), b.particleType = Particle.Emitter, this.mActiveParticles.push(b), this.mActiveEmittedEmitters.push(b), b._notifyOwner(this)), b
}, ParticleSystem.prototype.getParticle = function(a) {
    return this.mActiveParticles[a]
}, ParticleSystem.prototype.getParticleQuota = function() {
    return this.mMaxValidSize
}, ParticleSystem.prototype.setParticleQuota = function(a, b) {
    if (1 == arguments.length) {
        var c = this.mParticlePool.length,
            d = arguments[0];
        d > c && (this.mPoolSize = d), this.mMinValidSize = d, this.mMaxValidSize = d
    } else if (2 == arguments.length) {
        var c = this.mParticlePool.length;
        b > c && (this.mPoolSize = b), this.mMinValidSize = a, this.mMaxValidSize = b
    }
}, ParticleSystem.prototype.getMinParticleQuota = function() {
    return this.mMinValidSize
}, ParticleSystem.prototype.setMinParticleQuota = function(a) {
    var b = this.mParticlePool.length;
    a > b && (this.mPoolSize = a), this.mMinValidSize = a
}, ParticleSystem.prototype.getMaxParticleQuota = function() {
    return this.mMaxValidSize
}, ParticleSystem.prototype.setMaxParticleQuota = function(a) {
    var b = this.mParticlePool.length;
    a > b && (this.mPoolSize = a), this.mMaxValidSize = a
}, ParticleSystem.prototype.genParticleQuota = function() {
    return this.mMinValidSize != this.mMaxValidSize ? e3d.genRandUint(this.mMinValidSize, this.mMaxValidSize) : this.mMinValidSize
}, ParticleSystem.prototype.getEmittedEmitterQuota = function() {
    return this.mEmittedEmitterPoolSize
}, ParticleSystem.prototype.setEmittedEmitterQuota = function(a) {
    var b = 0;
    for (var c in this.mEmittedEmitterPool) {
        var d = this.mEmittedEmitterPool[c];
        b += d.length
    }
    a > b && (this.mEmittedEmitterPoolSize = a)
}, ParticleSystem.prototype._update = function(a) {
    var b = this.mNonvisibleTimeoutSet ? this.mNonvisibleTimeout : this.msDefaultNonvisibleTimeout;
    if (b > 0) {
        var c = this.mRoot.getNextFrameNumber() - this.mLastVisibleFrame;
        if ((c > 1 || 0 > c) && (this.mTimeSinceLastVisible += a, this.mTimeSinceLastVisible >= b)) return
    }
    a *= this.mSpeedFactor, this.configureRenderer(), this.initialiseEmittedEmitters();
    var d = this.mIterationIntervalSet ? this.mIterationInterval : this.msDefaultIterationInterval;
    if (d > 0)
        for (this.mUpdateRemainTime += a; this.mUpdateRemainTime >= d;) this._expire(d), this._triggerAffectors(d), this._applyMotion(d), this.mIsEmitting && this._triggerEmitters(d), this.mUpdateRemainTime -= d;
    else this._expire(a), this._triggerAffectors(a), this._applyMotion(a), this.mIsEmitting && this._triggerEmitters(a);
    !this.mBoundsAutoUpdate && this.mBoundsUpdateTime > 0 && (this.mBoundsUpdateTime -= a), this._updateBounds()
}, ParticleSystem.prototype._getIterator = function() {
    return this.mActiveParticles
}, ParticleSystem.prototype.setMaterialName = function(a, b) {
    this.mMaterialName = a, this.mResourceGroupName = b
}, ParticleSystem.prototype.getMaterialName = function() {
    return this.mMaterialName
}, ParticleSystem.prototype._notifyCurrentCamera = function(a) {
    this.mTimeSinceLastVisible = 0, this.mSorted && this._sortParticles(a), this.mRenderer && (this.mIsRendererConfigured || this.configureRenderer(), this.mRenderer._notifyCurrentCamera(a))
}, ParticleSystem.prototype.fastForward = function(a, b) {
    for (var c = 0; a > c; c += b) this._update(b)
}, ParticleSystem.prototype.setSpeedFactor = function(a) {
    return this.mSpeedFactor = a
}, ParticleSystem.prototype.getSpeedFactor = function() {
    return this.mSpeedFactor
}, ParticleSystem.prototype.setIterationInterval = function(a) {}, ParticleSystem.prototype.getIterationInterval = function() {
    return this.mIterationInterval
}, ParticleSystem.prototype.setDefaultIterationInterval = function(a) {
    this.msDefaultIterationInterval = a
}, ParticleSystem.prototype.getDefaultIterationInterval = function() {
    return this.msDefaultIterationInterval
}, ParticleSystem.prototype.setNonVisibleUpdateTimeout = function(a) {}, ParticleSystem.prototype.getNonVisibleUpdateTimeout = function() {
    return this.mNonvisibleTimeout
}, ParticleSystem.prototype.setDefaultNonVisibleUpdateTimeout = function(a) {
    this.msDefaultNonvisibleTimeout = a
}, ParticleSystem.prototype.getDefaultNonVisibleUpdateTimeout = function() {
    return this.msDefaultNonvisibleTimeout
}, ParticleSystem.prototype._notifyParticleResized = function() {
    this.mRenderer && this.mRenderer._notifyParticleResized()
}, ParticleSystem.prototype._notifyParticleRotated = function() {
    this.mRenderer && this.mRenderer._notifyParticleRotated()
}, ParticleSystem.prototype.setDefaultDimensions = function(a, b) {
    this.mDefaultWidth = a, this.mDefaultHeight = b, this.mRenderer && this.mRenderer._notifyDefaultDimensions(a, b)
}, ParticleSystem.prototype.setDefaultWidth = function(a) {
    this.mDefaultWidth = a, this.mRenderer && this.mRenderer._notifyDefaultDimensions(this.mDefaultWidth, this.mDefaultHeight)
}, ParticleSystem.prototype.getDefaultWidth = function() {
    return this.mDefaultWidth
}, ParticleSystem.prototype.setDefaultHeight = function(a) {
    this.mDefaultHeight = a, this.mRenderer && this.mRenderer._notifyDefaultDimensions(this.mDefaultWidth, this.mDefaultHeight)
}, ParticleSystem.prototype.getDefaultHeight = function() {
    return this.mDefaultHeight
}, ParticleSystem.prototype.getCullIndividually = function() {
    return this.mCullIndividual
}, ParticleSystem.prototype.setCullIndividually = function(a) {
    this.mCullIndividual = a
}, ParticleSystem.prototype.getOrigin = function() {
    return this.mOrigin
}, ParticleSystem.prototype._notifyOrigin = function(a) {
    this.mOrigin = a
}, ParticleSystem.prototype.setRenderQueueGroup = function(a) {
    this.mRenderer && this.mRenderer.setRenderQueueGroup(a)
}, ParticleSystem.prototype.setSortingEnabled = function(a) {
    this.mSorted = a
}, ParticleSystem.prototype.getSortingEnabled = function(a) {
    return this.mSorted
}, ParticleSystem.prototype.setBoundsAutoUpdated = function(a, b) {
    this.mBoundsAutoUpdate = a, this.mBoundsUpdateTime = b
}, ParticleSystem.prototype.setKeepParticlesInLocalSpace = function(a) {
    this.mLocalSpace = a, this.mRenderer && this.mRenderer.setKeepParticlesInLocalSpace(a)
}, ParticleSystem.prototype.getKeepParticlesInLocalSpace = function() {
    return this.mLocalSpace
}, ParticleSystem.prototype._updateBounds = function() {}, ParticleSystem.prototype.setEmitting = function(a) {
    this.mIsEmitting = a
}, ParticleSystem.prototype.getEmitting = function() {
    return this.mIsEmitting
}, ParticleSystem.prototype.getTypeFlags = function() {
    return 0
}, ParticleSystem.prototype.getName = function() {
    return this.mName
}, ParticleSystem.prototype.getRenderOperation = function(a) {
    if (!this.mBeStop) {
        var b = this.mRoot.getDeltaTime();
        if (b *= .35, this._update(b), this.mRenderer) {
            var c = this.mRoot.getRenderFunction().getCamera();
            c && this._notifyCurrentCamera(c), this.mRenderer._updateRenderQueue(this.mActiveParticles, this.mCullIndividual), this.mRenderer.getClickListener() && (this.mActiveParticles.length > 0 ? this.mRenderer.getClickListener().onParticleSystemActive && this.mRenderer.getClickListener().onParticleSystemActive(this) : this.mRenderer.getClickListener().onParticleSystemIdle && this.mRenderer.getClickListener().onParticleSystemIdle(this))
        }
    }
    this.mActiveParticles.length > 0 && this.mRenderer.getRenderOperation(a)
}, ParticleSystem.prototype.setMesh = function(a) {
    this.mRenderer && this.mRenderer.setMesh(a)
}, ParticleSystem.prototype.setStacks = function(a) {
    this.mStacks = a, this.mRenderer && this.mRenderer._notifyStacksAndSlices(this.mStacks, this.mSlices)
}, ParticleSystem.prototype.setSlices = function(a) {
    this.mSlices = a, this.mRenderer && this.mRenderer._notifyStacksAndSlices(this.mStacks, this.mSlices)
}, ParticleSystem.prototype.getStacks = function() {
    return this.mStacks
}, ParticleSystem.prototype.getSlices = function() {
    return this.mSlices
}, ParticleSystem.prototype.getAlwaysGeneratePartices = function() {
    return this.mIsAlwaysGeneratePartices
}, ParticleSystem.prototype.setAlwaysGeneratePartices = function(a) {
    this.mIsAlwaysGeneratePartices = a
}, ParticleSystem.prototype.getStickToFinger = function() {
    return this.mStickToFinger
}, ParticleSystem.prototype.setStickToFinger = function(a) {
    this.mStickToFinger = a
}, ParticleSystem.prototype.hasTouchEvent = function(a) {
    return this.mHasTouchEvent
}, ParticleSystem.prototype.enableTouchEvent = function(a) {
    this.mHasTouchEvent = a
}, ParticleSystem.prototype.isDynamicBinding = function() {
    return this.mDynamicBinding
}, ParticleSystem.prototype.enableDynamicBinding = function(a) {
    this.mDynamicBinding = a
}, ParticleSystem.prototype.onStop = function(a) {
    this.mBeStop != a && (this.mBeStop = a, this.mBeStop && this.mRenderer.getClickListener() && this.mRenderer.getClickListener().onParticleSystemIdl && this.mRenderer.getClickListener().onParticleSystemIdle(this))
}, ParticleSystem.prototype.resize = function(a, b) {
    this.ResizeDefaultDimensions(a, b);
    var c;
    for (var d in this.mEmitters) c = this.mEmitters[d], c.resize(a, b);
    this.getRenderer() && this.getRenderer().setScreenHeight(2 * b / 3)
}, ParticleSystem.prototype.copyParametersFrom = function() {}, ParticleSystem.prototype.getEmitterNumber = function() {
    return this.mEmitters.length
}, ParticleSystem.prototype.getDefaultWidthFactor = function() {
    return this.mDefaultWidthFactor
}, ParticleSystem.prototype.setDefaultWidthFactor = function(a) {
    this.mDefaultWidthFactor = a, this.mIsDefaultDimensionsFixed = !1
}, ParticleSystem.prototype.getDefaultHeightFactor = function() {
    return this.mDefaultHeightFactor
}, ParticleSystem.prototype.setDefaultHeightFactor = function(a) {
    this.mDefaultHeightFactor = a, this.mIsDefaultDimensionsFixed = !1
}, ParticleSystem.prototype.getDefaultDimensionsFactor = function() {
    return this.mDefaultWidthFactor
}, ParticleSystem.prototype.setDefaultDimensionsFactor = function(a) {
    this.mDefaultWidthFactor = a, this.mDefaultHeightFactor = a, this.mIsDefaultDimensionsFixed = !1
}, ParticleSystem.prototype.getAspectratio = function() {
    return this.mAspectratio
}, ParticleSystem.prototype.setAspectratio = function(a) {
    this.mAspectratio = a
}, ParticleSystem.prototype.ResizeDefaultDimensions = function(a, b) {
    this.mIsDefaultDimensionsFixed || (this.mDefaultWidthFactor > 0 && (this.mDefaultWidth = this.mDefaultWidthFactor * a), this.mAspectratio > 0 ? this.mDefaultHeight = this.mAspectratio * this.mDefaultWidth : this.mDefaultHeight = this.mDefaultHeightFactor * b, this.mRenderer && this.mRenderer._notifyDefaultDimensions(this.mDefaultWidth, this.mDefaultHeight))
}, ParticleSystem.prototype.getMinEmitDelayTime = function() {
    return this.mMinEmitDelayTime
}, ParticleSystem.prototype.setMinEmitDelayTime = function(a) {
    this.mMinEmitDelayTime = a, this.mIsEmitDelaySet = !0
}, ParticleSystem.prototype.getMaxEmitDelayTime = function() {
    return this.mMaxEmitDelayTime
}, ParticleSystem.prototype.setMaxEmitDelayTime = function(a) {
    this.mMaxEmitDelayTime = a, this.mIsEmitDelaySet = !0
}, ParticleSystem.prototype.setEmitDelayTime = function(a, b) {
    this.mMinEmitDelayTime = a, this.mMaxEmitDelayTime = void 0 !== b ? b : a
}, ParticleSystem.prototype.getEmitDelayTime = function() {
    return this.mMinEmitDelayTime
}, ParticleSystem.prototype.genEmitDelayTime = function() {
    return this.mMinEmitDelayTime != this.mMaxEmitDelayTime ? this.mMinEmitDelayTime + Math.random() * (this.mMaxEmitDelayTime - this.mMinEmitDelayTime) : this.mMinEmitDelayTime
}, ParticleSystem.prototype.isEmitDelaySet = function() {
    return this.mIsEmitDelaySet
}, ParticleSystem.prototype.isEmitDelaying = function() {
    return this.mIsEmitDelaying
}, ParticleSystem.prototype._expire = function(a) {
    var b = null,
        c = null;
    for (var d in this.mActiveParticles)
        if (b = this.mActiveParticles[d], b.timeToLive < a)
            if (this.mRenderer._notifyParticleExpired(b), b.particleType == Particle.Visual) {
                var e = this.mActiveParticles.splice(d, 1);
                for (var f in e) this.mFreeParticles.push(e[f])
            } else {
                c = b;
                var g = this.findFreeEmittedEmitter(c.mName);
                g.push(c), this.removeFromActiveEmittedEmitters(c), this.mActiveParticles.splice(d, 1)
            }
    else b.timeToLive -= a
}, ParticleSystem.prototype._triggerEmitters = function(a) {
    if (this.mIsEmitDelaySet) {
        if (this.mActiveParticles.length > 0) return void(0 != this.mIsEmitDelaying && (this.mIsEmitDelaying = !1));
        if (this.mIsEmitDelaying || (this.mEmitRemainTime = this.genEmitDelayTime(), this.mIsEmitDelaying = !0), this.mEmitRemainTime -= a, this.mEmitRemainTime > 0) return
    }
    this.requested.length != this.mEmitters.length && (this.requested.length = this.mEmitters.length);
    var b, c, d, e;
    c = this.mEmitters.length, e = this.mFreeParticles.length, this.mCurrentValidSize = this.genParticleQuota();
    var f = this.mCurrentValidSize - this.mActiveParticles.length;
    if (0 > f && (f = 0), e > f && (e = f), 0 != e) {
        b = 0;
        var g;
        for (var h in this.mEmitters) g = this.mEmitters[h], g.isEmitted() || (this.requested[h] = g._getEmissionCount(a), b += this.requested[h]);
        var i;
        for (var h in this.mActiveEmittedEmitters) i = this.mActiveEmittedEmitters[h], b += i._getEmissionCount(a);
        var j = 1;
        if (b > e) {
            for (j = e / b, b = 0, d = 0; c > d; d++) this.requested[d] = this.requested[d] * j, b += this.requested[d];
            if (0 == b && e > 0 && this.mIsAlwaysGeneratePartices) {
                var k, l, m;
                for (k = e3d.genRandUint(1, e), l = 0; k > l; l++) m = e3d.genRandUint(0, c - 1), this.requested[m] = 1
            }
        }
        for (var h in this.mEmitters) g = this.mEmitters[h], g.isEmitted() || this._executeTriggerEmitters(g, this.requested[h], a);
        for (var h in this.mActiveEmittedEmitters) i = this.mActiveEmittedEmitters[h], this._executeTriggerEmitters(i, i._getEmissionCount(a * j), a)
    }
}, ParticleSystem.prototype._executeTriggerEmitters = function(a, b, c) {
    var d = 0;
    if (b)
        for (var e = c / b, f = 0; b > f; f++) {
            var g = null,
                h = a.getEmittedEmitter();
            if (g = h ? this.createEmitterParticle(h) : this.createParticle(), !g) return;
            a._initParticle(g), g.position = g.position.add(g.direction.multiply(d));
            for (var i in this.mAffectors) {
                var j = this.mAffectors[i];
                j._initParticle(g)
            }
            if (d += e, g.particleType == Particle.Emitter) {
                var k = g;
                k.setPosition(g.position)
            }
            this.mRenderer._notifyParticleEmitted(g)
        }
}, ParticleSystem.prototype._applyMotion = function(a) {
    var b = null,
        c = null;
    for (var d in this.mActiveParticles) b = this.mActiveParticles[d], b.position = b.position.add(b.direction.multiply(a)), b.particleType == Particle.Emitter && (c = b, c.setPosition(b.position))
}, ParticleSystem.prototype._triggerAffectors = function(a) {
    for (var b in this.mAffectors) {
        var c = this.mAffectors[b];
        c._affectParticles(this, a)
    }
}, ParticleSystem.prototype._sortParticles = function(a) {
    if (this.mRenderer) {
        var b = this.mRenderer._getSortMode();
        if (b == SM_DIRECTION) {
            a.getDerivedDirection()
        } else if (b == SM_DISTANCE) {
            a.getDerivedPosition()
        }
    }
}, ParticleSystem.prototype.increasePool = function(a) {
    for (var b = this.mParticlePool.length, c = b; a > c; c++) this.mParticlePool[c] = new Particle;
    this.mIsRendererConfigured && this.createVisualParticles(b, a)
}, ParticleSystem.prototype.increaseEmittedEmitterPool = function(a) {
    if (!(this.mEmittedEmitterPool.length < 1)) {
        var b = null,
            c = null,
            d = [],
            e = "",
            f = a / this.mEmittedEmitterPool.length,
            g = 0;
        for (var h in this.mEmittedEmitterPool) {
            e = h, d = this.mEmittedEmitterPool[h], b = null;
            for (var i in this.mEmitters)
                if (b = this.mEmitters[i], b && "" != e && e == b.getName()) {
                    g = d.size();
                    for (var j = g; f > j; j++) c = this.mParticleSystemManager._createEmitter(b.getType(), this), c && (c.setEmitted(b.isEmitted()), c.getDuration() > 0 && (c.getRepeatDelay() > 0 || c.getMinRepeatDelay() > 0 || c.getMinRepeatDelay() > 0) && c.setEnabled(!1), d.push(c))
                }
        }
    }
}, ParticleSystem.prototype.initParameters = function() {}, ParticleSystem.prototype.configureRenderer = function() {
    var a = this.mParticlePool.length,
        b = this.mPoolSize;
    if (b > a) {
        this.increasePool(b);
        for (var c = a; b > c; c++) this.mFreeParticles.push(this.mParticlePool[c]);
        this.mRenderer && this.mIsRendererConfigured && this.mRenderer._notifyParticleQuota(b)
    }
    this.mRenderer && !this.mIsRendererConfigured && (this.mRenderer._notifyParticleQuota(this.mParticlePool.length), "" == this.mUVSSetStr && this.mRenderer._notifyStacksAndSlices(this.mStacks, this.mSlices), this.mRenderer._notifyDefaultDimensions(this.mDefaultWidth, this.mDefaultHeight), this.createVisualParticles(0, this.mParticlePool.length), this.mRenderer.setKeepParticlesInLocalSpace(this.mLocalSpace), this.mIsRendererConfigured = !0)
}, ParticleSystem.prototype.createVisualParticles = function(a, b) {
    for (var c = a; b > c; c++) {
        var d = this.mParticlePool[c];
        d._notifyVisualData(this.mRenderer._createVisualData())
    }
}, ParticleSystem.prototype.destroyVisualParticles = function(a, b) {
    var c;
    for (var d in this.mParticlePool) c = this.mParticlePool[d], this.mRenderer._destroyVisualData(c.getVisualData()), c._notifyVisualData(0)
}, ParticleSystem.prototype.initialiseEmittedEmitters = function(a) {
    var b = 0;
    if (this.mEmittedEmitterPool.length)
        for (var c in this.mEmittedEmitterPool) b += this.mEmittedEmitterPool[c].length;
    else {
        if (this.mEmittedEmitterPoolInitialised) return;
        this.initialiseEmittedEmitterPool()
    }
    var d = this.mEmittedEmitterPoolSize;
    d > b && !this.mEmittedEmitterPool && (this.increaseEmittedEmitterPool(d), this.addFreeEmittedEmitters())
}, ParticleSystem.prototype.initialiseEmittedEmitterPool = function() {
    if (!this.mEmittedEmitterPoolInitialised) {
        var a, b;
        for (var c in this.mEmitters) {
            if (a = this.mEmitters[c], a && a.getEmittedEmitter()) {
                var d = new Array;
                this.mEmittedEmitterPool[a.getEmittedEmitter()] = d
            }
            for (var c in this.mEmitters) {
                if (b = this.mEmitters[c], a && b && a.getName() && a.getName() == b.getEmittedEmitter()) {
                    a.setEmitted(!0);
                    break
                }
                a.setEmitted(!1)
            }
        }
        this.mEmittedEmitterPoolInitialised = !0
    }
}, ParticleSystem.prototype.addFreeEmittedEmitters = function(a) {
    if (this.mEmittedEmitterPool) {
        var b = null,
            c = null,
            d = "";
        for (var e in this.mEmittedEmitterPool) {
            if (d = e, b = this.mEmittedEmitterPool[e], c = this.findFreeEmittedEmitter(d), !c) {
                var f = new Array;
                this.mFreeEmittedEmitters[d] = f, c = this.findFreeEmittedEmitter(d)
            }
            if (!c) return;
            for (var e in b) c.push(b[e])
        }
    }
}, ParticleSystem.prototype.removeAllEmittedEmitters = function() {
    var a, b;
    for (var c in this.mEmittedEmitterPool) {
        a = c, b = this.mEmittedEmitterPool[a];
        for (var d in b) this.mParticleSystemManager._destroyEmitter(b[d])
    }
    this.mEmittedEmitterPool = {}, this.mFreeEmittedEmitters = {}, this.mActiveEmittedEmitters = []
}, ParticleSystem.prototype.findFreeEmittedEmitter = function(a) {
    var b;
    return b = this.mFreeEmittedEmitters[a], b ? b : null
}, ParticleSystem.prototype.removeFromActiveEmittedEmitters = function(a) {
    var b;
    for (var c in this.mActiveEmittedEmitters) {
        b = this.mActiveEmittedEmitters[c], this.mActiveEmittedEmitters.splice(c, 1);
        break
    }
}, ParticleSystem.prototype.addActiveEmittedEmittersToFreeList = function() {
    for (var a in this.mActiveEmittedEmitters) {
        var b = this.mActiveEmittedEmitters[a],
            c = this.findFreeEmittedEmitter(b.getName());
        c && c.push(b)
    }
}, ParticleSystem.prototype._notifyReorganiseEmittedEmitterData = function() {
    this.removeAllEmittedEmitters(), this.mEmittedEmitterPoolInitialised = !1
}, ParticleSystem.prototype.setUVSSetString = function(a) {
    this.mUVSSetStr = a
}, ParticleSystem.prototype.getUVSSetString = function() {
    return this.mUVSSetStr
}, ParticleSystem.prototype.setTextureUVSSet = function(a, b) {
    this.mRenderer._notifyUVSSet(a, b)
}, ParticleSystem.prototype.getParticlesType = function() {
    return this.mRenderer.getParticlesType()
}, ParticleSystem.prototype.setParticlesType = function(a) {
    this.mRenderer.setParticlesType(a)
};
var IClickListener = function() {
        this.click = function(a) {}
    },
    ParticleSystemListener = function() {
        IClickListener.call(this), this.onParticleSystemActive = function() {}, this.onParticleSystemIdle = function() {}
    },
    ParticleSystemRenderer = function() {
        this.mClickListener = null, this.mHalfScreenHeight = 0, this.currentParticleSystem = null
    };
ParticleSystemRenderer.prototype = {
    constructor: ParticleSystemRenderer,
    setClickListener: function(a) {
        this.mClickListener = a
    },
    setCurrentParentGameObject: function() {},
    getClickListener: function() {
        return this.mClickListener
    },
    getType: function() {},
    setScreenHeight: function(a) {
        this.mHalfScreenHeight = a
    },
    getParticlesType: function() {},
    setParticlesType: function() {},
    getRenderOperation: function() {},
    _updateRenderQueue: function() {},
    OnTouchEvent: function() {},
    _notifyCurrentCamera: function() {},
    _notifyParticleRotated: function() {},
    _notifyParticleResized: function() {},
    _notifyParticleQuota: function() {},
    _notifyStacksAndSlices: function() {},
    _notifyDefaultDimensions: function() {},
    _notifyParticleEmitted: function() {},
    _notifyParticleExpired: function() {},
    _notifyParticleMoved: function() {},
    _notifyParticleCleared: function() {},
    _createVisualData: function() {
        return 0
    },
    _destroyVisualData: function() {},
    setRenderQueueGroup: function() {},
    setKeepParticlesInLocalSpace: function() {},
    _getSortMode: function() {},
    _notifyUVSSet: function() {}
};
var ParticleSystemRendererFactory = function() {},
    PT_BBT_POINT = 0,
    PT_BBT_ORIENTED_COMMON = 1,
    PT_BBT_ORIENTED_SELF = 2,
    PT_BBT_PERPENDICULAR_COMMON = 3,
    PT_BBT_PERPENDICULAR_SELF = 4,
    PT_BBT_NOCAMERA = 5,
    ParticleIterator = function() {
        this.mPos = 0, this.mStart = 0, this.mEnd = 0
    };
ParticleIterator.prototype = {
    constructor: ParticleIterator,
    set: function(a, b) {
        this.mStart = a, this.mPos = a, this.mEnd = b
    },
    end: function() {
        return this.mPos == this.mEnd
    },
    isEnd: function() {
        return this.mPos == this.mEnd
    },
    getNext: function() {
        return this.mPos++
    }
};
var ParticleSystemManager = function(a) {
    ResourceManager.call(this), this.mRoot = a, this.mActiveParticleSystem = {}, this.mSystemTemplates = {}, this.mEmitterFactories = {}, this.mAffectorFactories = {}, this.mRendererFactories = {}, this.mRendererFactories = [], this.mFactory = null, this._initialise()
};
ParticleSystemManager.prototype = {
    constructor: ParticleSystemManager,
    _initialise: function() {
        this._installRendererFactorys(), this._installEmitterAffectorFactorys()
    },
    _destroy: function() {
        this._destroyActiveParticleSystem(), this._destroyRendererFactorys(), this.mBillboardRendererFactory = null, this._destroyEmitterAffectorFactorys()
    },
    _installRendererFactorys: function() {
        this.mBillboardRendererFactory = new BillboardParticleRendererFactory, this.addRendererFactory(this.mBillboardRendererFactory)
    },
    _destroyRendererFactorys: function() {
        for (var a in this.mRendererFactories) delete this.mRendererFactories[a];
        this.mRendererFactories.length = 0
    },
    _installEmitterAffectorFactorys: function() {
        var a = new PointEmitterFactory;
        this.addEmitterFactory(a), a = new BoxEmitterFactory, this.addEmitterFactory(a);
        var b = new LinearForceAffectorFactory;
        this.addAffectorFactory(b), b = new ColourFaderAffectorFactory, this.addAffectorFactory(b), b = new ColourFaderAffectorFactory2, this.addAffectorFactory(b), b = new ColourInterpolatorAffectorFactory, this.addAffectorFactory(b), b = new ScaleAffectorFactory, this.addAffectorFactory(b), b = new RotationAffectorFactory, this.addAffectorFactory(b), b = new TextureFrameAffectorFactory, this.addAffectorFactory(b), b = new DirectionRandomiserAffectorFactory, this.addAffectorFactory(b), b = new RandomCurveAffectorFactory(this.mRoot), this.addAffectorFactory(b), b = new TextureAffectorFactory, this.addAffectorFactory(b)
    },
    _destroyEmitterAffectorFactorys: function() {
        for (var a in this.mEmitterFactories) delete this.mEmitterFactories[a];
        this.mEmitterFactories.length = 0;
        for (var a in this.mAffectorFactories) delete this.mAffectorFactories[a];
        this.mAffectorFactories.length = 0
    },
    _destroyActiveParticleSystem: function() {
        for (var a in this.mActiveParticleSystem) delete this.mActiveParticleSystem[a];
        this.mActiveParticleSystem.length = 0
    },
    addEmitterFactory: function(a) {
        var b = a.getName();
        b && (this.mEmitterFactories[b] = a)
    },
    addAffectorFactory: function(a) {
        var b = a.getName();
        b && (this.mAffectorFactories[b] = a)
    },
    addRendererFactory: function(a) {
        var b = a.getType();
        b && (this.mRendererFactories[b] = a)
    },
    addTemplate: function(a, b) {
        void 0 !== b && (this.mSystemTemplates[a] = b)
    },
    removeTemplate: function(a, b) {
        var c = this.mSystemTemplates[a];
        c && delete this.mSystemTemplates[a]
    },
    removeAllTemplates: function(a) {
        for (var b in this.mSystemTemplates) delete this.mSystemTemplates[b]
    },
    removeTemplatesByResourceGroup: function(a) {
        for (var b in this.mSystemTemplates) {
            var c = this.mSystemTemplates[b];
            c.getResourceGroupName() == a && this.mSystemTemplates.splice(b, 1)
        }
    },
    createTemplate: function(a, b) {
        var c = this.mSystemTemplates[a];
        if (!c) return null;
        var d = new ParticleSystem(this, a, b);
        return d
    },
    getTemplate: function(a) {
        var b = this.mSystemTemplates[a];
        return b ? b : null
    },
    getParticleSystem: function(a) {
        var b = this.mActiveParticleSystem[a];
        return b ? b : null
    },
    update: function() {
        for (var a in this.mActiveParticleSystem) this.mActiveParticleSystem[a].update()
    },
    getTemplateMap: function() {
        return this.mSystemTemplates
    },
    getActiveParticleSystemMap: function() {
        return this.mActiveParticleSystem
    },
    resize: function(a, b) {
        var c, d;
        for (var e in this.mActiveParticleSystem) c = e, d = this.mActiveParticleSystem[e], d && d.resize(a, b)
    },
    onTouchEvent: function(a, b, c, d) {
        var e = this.getActiveParticleSystemMap();
        for (var f in e) {
            var g = e[f];
            if (g.getRenderer().OnTouchEvent(a, b, c, d), g.getStickToFinger())
                if (a == e3d.TOUCH_UP || a == e3d.TOUCH_CANCEL) g.setEmitting(!1);
                else if (a == e3d.TOUCH_DOWN || a == e3d.TOUCH_MOVE) {
                g.setEmitting(!0);
                for (var h = 0; h < g.getNumEmitters(); ++h) g.getEmitter(h).setPosition(c, d, 0)
            }
        }
    },
    onStop: function(a) {
        for (var b in this.mActiveParticleSystem) {
            var c = this.mActiveParticleSystem[b];
            c.onStop(a)
        }
    },
    setParticleSystemListener: function(a, b) {
        for (var c in this.mActiveParticleSystem) {
            var d = this.mActiveParticleSystem[c];
            d && d.getRenderer() && d == a && d.getRenderer().setClickListener(b)
        }
    },
    createSystemImpl: function(a, b, c) {
        if (2 == arguments.length) {
            a = arguments[0];
            var d = arguments[1],
                e = this.getTemplate(d);
            if (!e) return null;
            var f = this.createSystemImpl(a, e.getParticleQuota(), e.getResourceGroupName());
            f = e
        } else if (3 == arguments.length) {
            a = arguments[0], b = arguments[1], c = arguments[2];
            var f = new ParticleSystem(this, a, c);
            f.setParticleQuota(b)
        }
        return f
    },
    destroySystemImpl: function(a) {
        a = null
    },
    _createEmitter: function(a, b) {
        var c = this.mEmitterFactories[a];
        return c ? c.createEmitter(b) : null
    },
    _destroyEmitter: function(a) {
        var b = this.mEmitterFactories[a.getType()];
        b && b.destroyEmitter(a)
    },
    _createAffector: function(a, b) {
        var c = this.mAffectorFactories[a];
        if (c) return c.createAffector(b)
    },
    _destroyAffector: function(a) {
        var b = this.mAffectorFactories[a.getType()];
        b && b.destroyAffector(a)
    },
    _createRenderer: function(a) {
        var b = this.mRendererFactories[a];
        if (b) return b.createInstance(this.mRoot, a)
    },
    _destroyRenderer: function(a) {
        var b = this.mRendererFactories[a];
        b && b.destroyInstance(a)
    },
    getLoadingOrder: function() {
        return 1e3
    },
    getAffectorFactoryIterator: function() {},
    getEmitterFactoryIterator: function() {},
    getRendererFactoryIterator: function() {},
    _getFactory: function() {
        return this.mFactory
    }
}, ParticleSystemManager.prototype.releaseResourceByGroupId = function(a) {
    var b;
    for (var c in this.mSystemTemplates) b = this.mSystemTemplates[c], b.mGroupId == a && delete this.mSystemTemplates[c];
    for (var c in this.mActiveParticleSystem) b = this.mActiveParticleSystem[c], b.mGroupId == a && delete this.mActiveParticleSystem[c];
    var d;
    for (var c in this.mEmitterFactories) {
        d = this.mEmitterFactories[c].mEmitters;
        for (var e = 0; e < d.length;) b = d[e], b.mGroupId == a ? this.mEmitterFactories[c].mEmitters.splice(parseInt(e), 1) : e++
    }
    var f;
    for (var c in this.mAffectorFactories) {
        f = this.mAffectorFactories[c].mAffectors;
        for (var e = 0; e < f.length;) b = f[e], b.mGroupId == a ? this.mAffectorFactories[c].mAffectors.splice(parseInt(e), 1) : e++
    }
    for (var c in this.mRendererFactories) b = this.mRendererFactories[c], b.mGroupId == a && this.mRendererFactories.splice(parseInt(c), 1)
};
var Billboard = function() {
    this.mOwnDimensions = !1, this.mUseTexcoordRect = !1, this.mTexcoordIndex = 0, this.mTexcoordRect = new TRect, this.mWidth = 0, this.mHeight = 0, this.mPosition = new Vector3(0, 0, 0), this.mDirection = new Vector3(0, 0, 0), this.mParentSet = null, this.mColour = new ColourValue(1, 1, 1, 1), this.mRotation = 0, this.mRotateAxis = new Vector3(0, 0, 1), this.mIsDefaultRotAxis = !0
};
Billboard.prototype = {
    constructor: Billboard,
    getRoation: function() {
        return this.mRotation
    },
    setRotation: function(a) {
        this.mRotation = a, 0 != this.mRotation && this.mParentSet._notifyBillboardRoated()
    },
    setPosition: function(a, b, c) {
        if (1 == arguments.length) this.mPosition.copy(arguments[0]);
        else {
            var d = new Vector3(a, b, c);
            this.mPosition.copy(d)
        }
    },
    getPosition: function() {
        return this.mPosition
    },
    setDimensions: function(a, b) {
        this.mOwnDimensions = !0, this.mWidth = a, this.mHeight = b, this.mParentSet._notifyBillboardResized()
    },
    resetDimensions: function() {
        this.mOwnDimensions = !1
    },
    setColour: function(a) {
        this.mColour.copy(a)
    },
    getColour: function() {
        return this.mColour
    },
    hasOwnDimensions: function() {
        return this.mOwnDimensions
    },
    getOwnWidth: function() {
        return this.mWidth
    },
    getOwnHeight: function() {
        return this.mHeight
    },
    _notifyOwner: function(a) {
        this.mParentSet = a
    },
    isUseTexcoordRect: function() {
        return this.mUseTexcoordRect
    },
    setTexcoordIndex: function(a) {
        this.mTexcoordIndex = a, this.mUseTexcoordRect = !1
    },
    getTexcoordIndex: function() {
        return this.mTexcoordIndex
    },
    setTexcoordRect: function(a, b, c, d) {
        1 == arguments.length ? this.mTexcoordRect.copy(arguments[0]) : 4 == arguments.length && this.mTexcoordRect.copy(new TRect(a, b, c, d))
    },
    getTexcoordRect: function() {
        return this.mTexcoordRect
    },
    setWidth: function(a) {
        this.mWidth = a, this.mOwnDimensions = !0, this.mParentSet._notifyBillboardResized()
    },
    setHeight: function(a) {
        this.mHeight = a, this.mOwnDimensions = !0, this.mParentSet._notifyBillboardResized()
    }
};
var BillboardSet = function(a, b, c) {
    IMesh.call(this), this.mRoot = a, this.mParentGameObject = null, this.mBoundingRadius = 0, this.mOriginType = BBO_CENTER, this.mRotationType = BBR_VERTEX, this.mDefaultWidth = 100, this.mDefaultHeight = 100, this.mMaterialName = "", this.mAllDefaultSize = !0, this.mAutoExtendPool = !0, this.mSortingEnabled = !1, this.mAccurateFacing = !1, this.mAllDefaultRotation = !0, this.mWorldSpace = !1, this.mActiveBillboards = [], this.mFreeBillboards = [], this.mBillboardPool = [], this.renderOperationVertexData = null, this.renderOperationIndexData = null, this.mVertexData = null, this.mMainBuf = null, this.mLockPtr = 0, this.mVOffset = [], this.mCurrentCamera = null, this.mLeftOff = 0, this.mRightOff = 0, this.mTopOff = 0, this.mBottomOff = 0, this.mCamX = new Vector3, this.mCamY = new Vector3, this.mCamDir = new Vector3, this.mCamQ = new Quaternion, this.mCamPos = new Vector3, this.mCullIndividual = !1, this.mTextureCoords = [], this.mBillboardType = BBT_POINT, this.mCommonDirection = new Vector3(0, 0, 1), this.mCommonUpVector = new Vector3(0, 1, 0), this.mNumVisibleBillboards = 0, this.mPointRendering = !1, this.useRGBA = !1, this.mBuffersCreated = !1, this.mPoolSize = void 0 !== b ? b : 0, this.mExternalData = void 0 !== c ? c : !1, this.mAutoUpdate = !0, this.mBillboardDataChanged = !0
};
extend(BillboardSet, IMesh), BillboardSet.prototype.billboardVisible = function() {
    return this.mCullIndividual ? !0 : !0
}, BillboardSet.prototype.increasePool = function() {
    if (2 == arguments.length || 3 == arguments.length) {
        var a = (arguments[0], arguments[1], 0);
        3 == arguments.length && (a = arguments[2])
    } else if (1 == arguments.length) {
        arguments[0], this.mBillboardPool.length
    }
}, BillboardSet.prototype.getParametricOffsets = function(a, b, c, d) {
    switch (this.mOriginType) {
        case BBO_TOP_LEFT:
            this.mLeftOff = 0, this.mRightOff = 1, this.mTopOff = 0, this.mBottomOff = -1;
            break;
        case BBO_TOP_CENTER:
            this.mLeftOff = -.5, this.mRightOff = .5, this.mTopOff = 0, this.mBottomOff = -1;
            break;
        case BBO_TOP_RIGHT:
            this.mLeftOff = -1, this.mRightOff = 0, this.mTopOff = 0, this.mBottomOff = -1;
            break;
        case BBO_CENTER_LEFT:
            this.mLeftOff = 0, this.mRightOff = 1, this.mTopOff = .5, d = -.5;
            break;
        case BBO_CENTER:
            this.mLeftOff = -.5, this.mRightOff = .5, this.mTopOff = .5, this.mBottomOff = -.5;
            break;
        case BBO_CENTER_RIGHT:
            this.mLeftOff = -1, this.mRightOff = 0, this.mTopOff = .5, this.mBottomOff = -.5;
            break;
        case BBO_BOTTOM_LEFT:
            this.mLeftOff = 0, this.mRightOff = 1, this.mTopOff = 1, this.mBottomOff = 0;
            break;
        case BBO_BOTTOM_CENTER:
            this.mLeftOff = -.5, this.mRightOff = .5, this.mTopOff = 1, this.mBottomOff = 0;
            break;
        case BBO_BOTTOM_RIGHT:
            this.mLeftOff = -1, this.mRightOff = 0, this.mTopOff = 1, this.mBottomOff = 0
    }
}, BillboardSet.prototype.genVertices = function(a, b, c) {
    var d, e = new Vector3Radius,
        f = new Vector3,
        g = new Vector3,
        h = new Vector3,
        i = new Vector3;
    d = b.mColour.multiplyScalar(255);
    var j = new TRect;
    if (j = b.mUseTexcoordRect || b.mTexcoordIndex < this.mTextureCoords.length ? b.mUseTexcoordRect ? b.mTexcoordRect : this.mTextureCoords[b.mTexcoordIndex] : this.mTextureCoords[0], this.mPointRendering) this.mVertexData[this.mLockPtr++] = b.mPosition.x, this.mVertexData[this.mLockPtr++] = b.mPosition.y, this.mVertexData[this.mLockPtr++] = b.mPosition.z, this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a;
    else if (this.mAllDefaultRotation || 0 == b.mRotation) this.mVertexData[this.mLockPtr++] = a[0].x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = a[0].y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = a[0].z + b.mPosition.z, this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = j.left, this.mVertexData[this.mLockPtr++] = j.top, this.mVertexData[this.mLockPtr++] = a[1].x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = a[1].y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = a[1].z + b.mPosition.z, this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = j.right, this.mVertexData[this.mLockPtr++] = j.top, this.mVertexData[this.mLockPtr++] = a[2].x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = a[2].y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = a[2].z + b.mPosition.z, this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = j.left, this.mVertexData[this.mLockPtr++] = j.bottom, this.mVertexData[this.mLockPtr++] = a[3].x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = a[3].y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = a[3].z + b.mPosition.z, this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = j.right, this.mVertexData[this.mLockPtr++] = j.bottom, c && (f = new Vector3(a[0].x + b.mPosition.x, a[0].y + b.mPosition.y, a[0].z + b.mPosition.z), g = new Vector3(a[1].x + b.mPosition.x, a[1].y + b.mPosition.y, a[1].z + b.mPosition.z), h = new Vector3(a[2].x + b.mPosition.x, a[2].y + b.mPosition.y, a[2].z + b.mPosition.z), i = new Vector3(a[3].x + b.mPosition.x, a[3].y + b.mPosition.y, a[3].z + b.mPosition.z));
    else if (this.mRotationType == BBR_VERTEX) {
        var k = new Matrix3;
        if (b.mIsDefaultRotAxis) {
            var l = a[3].sub(a[0]).cross(a[2].sub(a[1])).normalisedCopy();
            k.FromAxisAngle(l, b.mRotation)
        } else k.FromAxisAngle(b.mRotateAxis, b.mRotation);
        var m = new Vector3;
        m = k.multiply(a[0]), this.mVertexData[this.mLockPtr++] = m.x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = m.y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = m.z + b.mPosition.z, c && (f = new Vector3(m.x + b.mPosition.x, m.y + b.mPosition.y, m.z + b.mPosition.z)), this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = j.left, this.mVertexData[this.mLockPtr++] = j.top, m = k.multiply(a[1]), this.mVertexData[this.mLockPtr++] = m.x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = m.y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = m.z + b.mPosition.z, c && (g = new Vector3(m.x + b.mPosition.x, m.y + b.mPosition.y, m.z + b.mPosition.z)), this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = j.right, this.mVertexData[this.mLockPtr++] = j.top, m = k.multiply(a[2]), this.mVertexData[this.mLockPtr++] = m.x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = m.y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = m.z + b.mPosition.z, c && (h = new Vector3(m.x + b.mPosition.x, m.y + b.mPosition.y, m.z + b.mPosition.z)), this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = j.left, this.mVertexData[this.mLockPtr++] = j.bottom, m = k.multiply(a[3]), this.mVertexData[this.mLockPtr++] = m.x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = m.y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = m.z + b.mPosition.z, c && (i = new Vector3(m.x + b.mPosition.x, m.y + b.mPosition.y, m.z + b.mPosition.z)), this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = j.right, this.mVertexData[this.mLockPtr++] = j.bottom
    } else {
        var n = Math.cos(b.mRotation),
            o = Math.sin(b.mRotation),
            p = (j.right - j.left) / 2,
            q = (j.bottom - j.top) / 2,
            r = j.left + p,
            s = j.top + q,
            t = n * p,
            u = n * q,
            v = o * p,
            w = o * q;
        this.mVertexData[this.mLockPtr++] = a[0].x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = a[0].y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = a[0].z + b.mPosition.z, this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = r - t + w, this.mVertexData[this.mLockPtr++] = s - v - u, this.mVertexData[this.mLockPtr++] = a[1].x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = a[1].y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = a[1].z + b.mPosition.z, this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = r + t + w, this.mVertexData[this.mLockPtr++] = s + v - u, this.mVertexData[this.mLockPtr++] = a[2].x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = a[2].y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = a[2].z + b.mPosition.z, this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = r - t - w, this.mVertexData[this.mLockPtr++] = s - v + u, this.mVertexData[this.mLockPtr++] = a[3].x + b.mPosition.x, this.mVertexData[this.mLockPtr++] = a[3].y + b.mPosition.y, this.mVertexData[this.mLockPtr++] = a[3].z + b.mPosition.z, this.mVertexData[this.mLockPtr++] = d.r, this.mVertexData[this.mLockPtr++] = d.g, this.mVertexData[this.mLockPtr++] = d.b, this.mVertexData[this.mLockPtr++] = d.a, this.mVertexData[this.mLockPtr++] = r + t - w, this.mVertexData[this.mLockPtr++] = s + v + u, c && (f = new Vector3(a[0].x + b.mPosition.x, a[0].y + b.mPosition.y, a[0].z + b.mPosition.z), g = new Vector3(a[1].x + b.mPosition.x, a[1].y + b.mPosition.y, a[1].z + b.mPosition.z), h = new Vector3(a[2].x + b.mPosition.x, a[2].y + b.mPosition.y, a[2].z + b.mPosition.z), i = new Vector3(a[3].x + b.mPosition.x, a[3].y + b.mPosition.y, a[3].z + b.mPosition.z))
    }
    if (c) {
        e.lt = f, e.rt = g, e.lb = h, e.rb = i;
        var x = new Vector3;
        x = f, x = x.add(g), x = x.add(f), x = x.add(i), x = x.div(4), e.center = x, e.lt = f, g.x < f.x ? e.width = f.x - g.x : e.width = g.x - f.x, h.y < f.y ? e.height = f.y - h.y : e.height = h.y - f.y
    }
    return e
}, BillboardSet.prototype.genVertOffsets = function(a, b, c, d, e, f, g, h, i) {
    i = void 0 !== i ? i : new Array;
    var j = new Vector3,
        k = new Vector3,
        l = new Vector3,
        m = new Vector3;
    return j = g.multiply(a * e), k = g.multiply(b * e), l = h.multiply(c * f), m = h.multiply(d * f), i[0] = j.add(l), i[1] = k.add(l), i[2] = j.add(m), i[3] = k.add(m), i
}, BillboardSet.prototype._createBuffers = function() {
    var a = new VertexData(this.mRoot.getHardwareBufferManager());
    this.mPointRendering ? a.vertexCount = this.mPoolSize : a.vertexCount = 4 * this.mPoolSize, a.vertexStart = 0;
    var b = a.vertexDeclaration,
        c = a.vertexBufferBinding,
        d = 0;
    if (b.addElement(0, d, VET_FLOAT3, VES_POSITION), d += VertexElement.getTypeSize(VET_FLOAT3), b.addElement(0, d, VET_COLOUR, VES_DIFFUSE), d += VertexElement.getTypeSize(VET_COLOUR), this.mPointRendering || b.addElement(0, d, VET_FLOAT2, VES_TEXTURE_COORDINATES), this.mMainBuf = this.mRoot.getHardwareBufferManager().createVertexBuffer(b.getVertexSize(0), a.vertexCount, this.mAutoUpdate ? HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE : HBU_STATIC_WRITE_ONLY), this.mMainBuf.createDataBuffer(), c.setBinding(0, this.mMainBuf), this.mVertexData = this.mMainBuf.lock(), !this.mPointRendering) {
        var e = new IndexData(this.mRoot.getHardwareBufferManager());
        e.indexStart = 0, e.indexCount = 6 * this.mPoolSize, e.indexBuffer = this.mRoot.getHardwareBufferManager().createIndexBuffer(IT_16BIT, e.indexCount, HBU_STATIC_WRITE_ONLY), e.indexBuffer.createDataBuffer();
        for (var f, g, h = e.indexBuffer.lock(), i = 0; i < this.mPoolSize; ++i) f = 6 * i, g = 4 * i, h[f] = g, h[f + 1] = g + 1, h[f + 2] = g + 2, h[f + 3] = g + 1, h[f + 4] = g + 3, h[f + 5] = g + 2;
        e.indexBuffer.unlock()
    }
    this.renderOperationVertexData = a, this.renderOperationIndexData = e, this.mBuffersCreated = !0
}, BillboardSet.prototype._destroyBuffers = function() {
    this.mBuffersCreated = !1
}, BillboardSet.prototype.setParentGameObject = function(a) {
    return a ? void(this.mParentGameObject = a) : void console.log("BillboardSet::SetParentGameObject: can't set the mbillboard parent game object, the parent gameobject is null")
}, BillboardSet.prototype.createBillboard = function(a, b, c, d) {
    if (4 == arguments.length) return this.createBillboard(new Vector3(a, b, c), d);
    if (2 == arguments.length) {
        var e = arguments[0];
        if (d = arguments[1], this.mFreeBillboards.empty()) {
            if (!this.mAutoExtendPool) return 0;
            this.setPoolSize(2 * this.getPoolSize())
        }
        var f = this.mFreeBillboards.front();
        this.mActiveBillboards.splice(this.mActiveBillboards.end(), this.mFreeBillboards, this.mFreeBillboards.begin()), f.setPosition(e), f.setColour(d), f.mDirection = new Vector3(0, 0, 0), f.setRotation(0), f.setTexcoordIndex(0), f.resetDimensions(), f._notifyOwner(this);
        var g = Math.max(this.mDefaultWidth, this.mDefaultHeight),
            h = new Vector3(g, g, g);
        e.sub(h), e.add(h);
        return f
    }
}, BillboardSet.prototype.getNumBillboards = function() {
    return this.mActiveBillboards.length
}, BillboardSet.prototype.setAutoextend = function(a) {
    this.mAutoExtendPool = a
}, BillboardSet.prototype.getAutoextend = function() {
    return this.mAutoExtendPool
}, BillboardSet.prototype.setSortingEnabled = function(a) {
    this.mSortingEnabled = a
}, BillboardSet.prototype.getSortingEnabled = function() {
    return this.mSortingEnabled
}, BillboardSet.prototype.setPoolSize = function(a) {
    if (!this.mExternalData) {
        var b = this.mBillboardPool.length;
        if (b >= a) return;
        this.increasePool(a);
        for (var c in this.mBillboardPool) this.mFreeBillboards.push(this.mBillboardPool[c])
    }
    this.mPoolSize = a, this._destroyBuffers()
}, BillboardSet.prototype.getPoolSize = function() {
    return this.mBillboardPool.length
}, BillboardSet.prototype.clear = function() {
    this.mFreeBillboards.concat(this.mActiveBillboards.slice(0))
}, BillboardSet.prototype.getBillboard = function(a) {
    return a > this.mActiveBillboards.length && console.error("Billboard index out of bounds."), this.mActiveBillboards[a]
}, BillboardSet.prototype.removeBillboard = function(a) {
    a > this.mActiveBillboards.length && console.error("Billboard index out of bounds.");
    var b = this.mActiveBillboards.slice(a, 1);
    this.mFreeBillboards.push(b)
}, BillboardSet.prototype.setBillboardOrigin = function(a) {
    this.mOriginType = a
}, BillboardSet.prototype.getBillboardOrigin = function() {
    return this.mOriginType
}, BillboardSet.prototype.setBillboardRotationType = function(a) {
    this.mRotationType = a
}, BillboardSet.prototype.getBillboardRotationType = function() {
    return this.mRotationType
}, BillboardSet.prototype.setDefaultDimensions = function(a, b) {
    this.mDefaultWidth = a, this.mDefaultHeight = b
}, BillboardSet.prototype.setDefaultWidth = function(a) {
    this.mDefaultWidth = a
}, BillboardSet.prototype.getDefaultWidth = function() {
    return this.mDefaultWidth
}, BillboardSet.prototype.setDefaultHeight = function(a) {
    this.mDefaultHeight = a
}, BillboardSet.prototype.getDefaultHeight = function() {
    return this.mDefaultHeight
}, BillboardSet.prototype._notifyCurrentCamera = function(a) {
    if (this.mBillboardType != BBT_NOCAMERA && 0 != this.mParentGameObject && 0 != a) {
        this.mCurrentCamera = a, this.mCamQ = this.mCurrentCamera.getDerivedOrientation(), this.mCamPos = this.mCurrentCamera.getDerivedPosition();
        var b = this.mParentGameObject.getTransform(),
            c = b._getDerivedOrientation();
        this.mCamQ = c.UnitInverse().multiply(this.mCamQ), this.mCamPos = c.UnitInverse().multiply(this.mCamPos.sub(b._getDerivedPosition())).div(b._getDerivedScale()), this.mCamDir = this.mCamQ.multiply(new Vector3(0, 0, -1))
    }
}, BillboardSet.prototype.genBillboardAxes = function(a, b, c) {
    switch (c = void 0 !== c ? c : null, !this.mAccurateFacing || this.mBillboardType != BBT_POINT && this.mBillboardType != BBT_NOCAMERA && this.mBillboardType != BBT_ORIENTED_COMMON && this.mBillboardType != BBT_ORIENTED_SELF || (this.mCamDir = c.mPosition.sub(this.mCamPos),
        this.mCamDir.normalise()), this.mBillboardType) {
        case BBT_POINT:
        case BBT_NOCAMERA:
            this.mAccurateFacing ? (this.mCamY = this.mCamQ.multiply(new Vector3(0, 1, 0)), this.mCamX = this.mCamDir.cross(this.mCamY), this.mCamX.normalise(), this.mCamY = this.mCamX.cross(this.mCamDir)) : (this.mCamX = this.mCamQ.multiply(new Vector3(1, 0, 0)), this.mCamY = this.mCamQ.multiply(new Vector3(0, 1, 0)).multiply(-1));
            break;
        case BBT_ORIENTED_COMMON:
            this.mCamY = this.mCommonDirection, this.mCamX = this.mCamDir.cross(this.mCamY), this.mCamX.normalise();
            break;
        case BBT_PERPENDICULAR_SELF:
            this.mCamX = this.mCommonUpVector.cross(c.mDirection), this.mCamX.normalise(), this.mCamY = c.mDirection.cross(this.mCamX)
    }
}, BillboardSet.prototype.beginBillboards = function(a) {
    if (a = a || 0, this.mBuffersCreated || this._createBuffers(), this.mPointRendering || (this.getParametricOffsets(this.mLeftOff, this.mRightOff, this.mTopOff, this.mBottomOff), this.mBillboardType == BBT_ORIENTED_SELF || this.mBillboardType == BBT_PERPENDICULAR_SELF || this.mAccurateFacing && this.mBillboardType != BBT_PERPENDICULAR_COMMON || (this.genBillboardAxes(this.mCamX, this.mCamY), this.mVOffset = this.genVertOffsets(this.mLeftOff, this.mRightOff, this.mTopOff, this.mBottomOff, this.mDefaultWidth, this.mDefaultHeight, this.mCamX, this.mCamY))), this.mNumVisibleBillboards = 0, a) {
        a = Math.min(this.mPoolSize, a);
        var b;
        b = this.mPointRendering ? this.mVOffset.length : 4 * this.mVOffset.length, this.mLockPtr = 0
    } else this.mLockPtr = 0
}, BillboardSet.prototype.injectBillboard = function(a, b) {
    b = b || !1;
    var c = new Vector3Radius;
    if (this.mNumVisibleBillboards == this.mPoolSize) return c;
    if (!this.billboardVisible(this.mCurrentCamera, a)) return c;
    if (!this.mPointRendering && (this.mBillboardType == BBT_ORIENTED_SELF || this.mBillboardType == BBT_PERPENDICULAR_SELF || this.mAccurateFacing && this.mBillboardType != BBT_PERPENDICULAR_COMMON) && this.genBillboardAxes(this.mCamX, this.mCamY, a), this.mAllDefaultSize || this.mPointRendering) !this.mPointRendering && (this.mBillboardType == BBT_ORIENTED_SELF || this.mBillboardType == BBT_PERPENDICULAR_SELF || this.mAccurateFacing && this.mBillboardType != BBT_PERPENDICULAR_COMMON) && (this.mVOffset = this.genVertOffsets(this.mLeftOff, this.mRightOff, this.mTopOff, this.mBottomOff, this.mDefaultWidth, this.mDefaultHeight, this.mCamX, this.mCamY)), c = this.genVertices(this.mVOffset, a, b);
    else {
        new Array(4);
        this.mBillboardType == BBT_ORIENTED_SELF || this.mBillboardType == BBT_PERPENDICULAR_SELF || a.mOwnDimensions || this.mAccurateFacing && this.mBillboardType != BBT_PERPENDICULAR_COMMON ? (this.vOwnOffset = this.genVertOffsets(this.mLeftOff, this.mRightOff, this.mTopOff, this.mBottomOff, a.mWidth, a.mHeight, this.mCamX, this.mCamY), c = this.genVertices(this.vOwnOffset, a, b)) : c = this.genVertices(this.mVOffset, a, b)
    }
    return this.mNumVisibleBillboards++, c
}, BillboardSet.prototype.endBillboards = function() {
    this.mMainBuf.unlock()
}, BillboardSet.prototype.getRenderOperation = function(a) {
    if (!(this.mNumVisibleBillboards <= 0)) {
        var b = new RenderOperation;
        b.useIndexes = null == this.renderOperationIndexData ? !1 : 0 != this.renderOperationIndexData.indexCount, b.indexData = this.renderOperationIndexData, b.indexData.indexCount = 6 * this.mNumVisibleBillboards, b.indexData.indexStart = 0, b.vertexData = this.renderOperationVertexData, b.vertexData.vertexCount = 4 * this.mNumVisibleBillboards, b.operationType = RenderOperation.OT_TRIANGLE_LIST, a.push(b)
    }
}, BillboardSet.prototype.getWorldTransforms = function() {
    var a;
    return a = this.mWorldSpace ? new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) : new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
}, BillboardSet.prototype._notifyBillboardResized = function() {
    this.mAllDefaultSize = !1
}, BillboardSet.prototype._notifyBillboardRotated = function() {
    this.mAllDefaultRotation = !1
}, BillboardSet.prototype.getCullIndividually = function() {
    return this.mCullIndividual
}, BillboardSet.prototype.setCullIndividually = function(a) {
    this.mCullIndividual = a
}, BillboardSet.prototype.setBillboardType = function(a) {
    this.mBillboardType = a
}, BillboardSet.prototype.getBillboardType = function() {
    return this.mBillboardType
}, BillboardSet.prototype.setCommonDirection = function(a) {
    this.mCommonDirection = a
}, BillboardSet.prototype.getCommonDirection = function() {
    return this.mCommonDirection
}, BillboardSet.prototype.setCommonUpVector = function(a) {
    this.mCommonUpVector = a
}, BillboardSet.prototype.getCommonUpVector = function() {
    return this.mCommonUpVector
}, BillboardSet.prototype.setUseAccurateFacing = function(a) {
    this.mAccurateFacing = a
}, BillboardSet.prototype.getUseAccurateFacing = function() {
    return this.mAccurateFacing
}, BillboardSet.prototype.getSquaredViewDepth = function() {}, BillboardSet.prototype._updateBounds = function() {}, BillboardSet.prototype._sortBillboards = function(a) {}, BillboardSet.prototype._getSortMode = function() {
    return this.mAccurateFacing || this.mBillboardType == BillboardSet.BBT_PERPENDICULAR_SELF || this.mBillboardType == BillboardSet.BBT_PERPENDICULAR_COMMON ? SM_DISTANCE : SM_DIRECTION
}, BillboardSet.prototype.setBillboardsInWorldSpace = function(a) {
    this.mWorldSpace = a
}, BillboardSet.prototype.setTextureCoords = function(a, b) {
    return b && a ? (this.mTextureCoords = [], void this.mTextureCoords.concat(a)) : void this.setTextureStacksAndSlices(1, 1)
}, BillboardSet.prototype.setTextureStacksAndSlices = function(a, b) {
    0 == a && (a = 1), 0 == b && (b = 1), this.mTextureCoords = [];
    for (var c = 0, d = 0; a > d; ++d)
        for (var e = d / a, f = (d + 1) / a, g = 0; b > g; ++g) this.mTextureCoords[c] = {}, this.mTextureCoords[c].left = g / b, this.mTextureCoords[c].bottom = f, this.mTextureCoords[c].right = (g + 1) / b, this.mTextureCoords[c].top = e, ++c
}, BillboardSet.prototype.getTextureCoords = function(a) {}, BillboardSet.prototype.resize = function() {}, BillboardSet.prototype.setPointRenderingEnabled = function(a) {
    a = !1, 0 != this.mPointRendering && (this.mPointRendering = a, this._destroyBuffers())
}, BillboardSet.prototype.isPointRenderingEnabled = function() {
    return this.mPointRendering
}, BillboardSet.prototype.getTypeFlags = function() {
    return 0
}, BillboardSet.prototype.setAutoUpdate = function(a) {
    a != this.mAutoUpdate && (this.mAutoUpdate = a, this._destroyBuffers())
}, BillboardSet.prototype.getAutoUpdate = function() {
    return this.mAutoUpdate
}, BillboardSet.prototype.notifyBillboardDataChanged = function() {
    this.mBillboardDataChanged = !0
};
var BBO_TOP_LEFT = 0,
    BBO_TOP_CENTER = 1,
    BBO_TOP_RIGHT = 2,
    BBO_CENTER_LEFT = 3,
    BBO_CENTER = 4,
    BBO_CENTER_RIGHT = 5,
    BBO_BOTTOM_LEFT = 6,
    BBO_BOTTOM_CENTER = 7,
    BBO_BOTTOM_RIGHT = 8,
    BBR_VERTEX = 0,
    BBR_TEXCOORD = 1,
    BBT_POINT = 0,
    BBT_ORIENTED_COMMON = 1,
    BBT_ORIENTED_SELF = 2,
    BBT_PERPENDICULAR_COMMON = 3,
    BBT_PERPENDICULAR_SELF = 4,
    BBT_NOCAMERA = 5,
    BillboardSetManager = function() {
        ResourceManager.call(this), this.mBillboardSetMap = {}
    };
extend(BillboardSetManager, ResourceManager), BillboardSetManager.prototype.createBillboardSet = function(a) {
    var b = 0;
    for (var c in this.mBillboardSetMap) b++;
    if (0 == b) return 0;
    var d = new BillboardSet(100, !1);
    return d.setBillboardsInWorldSpace(!0), this.mBillboardSetMap[a] = d, d
}, BillboardSetManager.prototype.getBillboardSet = function(a) {
    var b = 0;
    for (var c in this.mBillboardSetMap) b++;
    return 0 == b ? 0 : this.mBillboardSetMap[a]
}, BillboardSetManager.prototype.releaseAllBillboardSets = function() {
    for (var a in this.mBillboardSetMap) var b = this.mBillboardSetMap[a]
}, BillboardSetManager.prototype.releaseResourceByGroupId = function(a) {
    var b = null;
    for (var c in this.mBillboardSetMap) b = this.mBillboardSetMap[c], b.mGroupId === a && this.mBillboardSetMap.splice(c, 1)
};
var rendererTypeName = "billboard",
    BillboardParticleRenderer = function(a) {
        ParticleSystemRenderer.call(this), this.mRoot = a, this.mBillboardSet = new BillboardSet(a, 0, !0), this.mBillboardSet.setBillboardsInWorldSpace(!0), this.mMotionEventList = []
    };
extend(BillboardParticleRenderer, ParticleSystemRenderer), BillboardParticleRenderer.prototype.setBillboardType = function(a) {
    this.mBillboardSet.setBillboardType(a)
}, BillboardParticleRenderer.prototype.getBillboardType = function() {
    return this.mBillboardSet.getBillboardType()
}, BillboardParticleRenderer.prototype.setUseAccurateFacing = function(a) {
    this.mBillboardSet.setUseAccurateFacing(a)
}, BillboardParticleRenderer.prototype.getUseAccurateFacing = function() {
    return this.mBillboardSet.getUseAccurateFacing()
}, BillboardParticleRenderer.prototype.setBillboardOrigin = function(a) {
    this.mBillboardSet.setBillboardOrigin(a)
}, BillboardParticleRenderer.prototype.getBillboardOrigin = function() {
    return this.mBillboardSet.getBillboardOrigin()
}, BillboardParticleRenderer.prototype.setBillboardRotationType = function(a) {
    this.mBillboardSet.setBillboardRotationType(a)
}, BillboardParticleRenderer.prototype.getBillboardRotationType = function() {
    return this.mBillboardSet.getBillboardRotationType()
}, BillboardParticleRenderer.prototype.setCommonDirection = function(a) {
    this.mBillboardSet.setCommonDirection(a)
}, BillboardParticleRenderer.prototype.getCommonDirection = function() {
    return this.mBillboardSet.getCommonDirection()
}, BillboardParticleRenderer.prototype.setCommonUpVector = function(a) {
    this.mBillboardSet.setCommonUpVector(a)
}, BillboardParticleRenderer.prototype.getCommonUpVector = function() {
    return this.mBillboardSet.getCommonUpVector()
}, BillboardParticleRenderer.prototype.setPointRenderingEnabled = function(a) {
    this.mBillboardSet.setPointRenderingEnabled(a)
}, BillboardParticleRenderer.prototype.isPointRenderingEnabled = function() {
    return this.mBillboardSet.isPointRenderingEnabled()
}, BillboardParticleRenderer.prototype.getType = function() {
    return rendererTypeName
}, BillboardParticleRenderer.prototype._updateRenderQueue = function(a, b) {
    if (!(a.length <= 0)) {
        var c = this.mMotionEventList.length;
        this.mBillboardSet.setCullIndividually(b), this.mBillboardSet.beginBillboards(a.length);
        var d = new Billboard;
        for (var e in a) {
            var f = a[e];
            d.mPosition = f.position, (this.mBillboardSet.getBillboardType() == BBT_ORIENTED_SELF || this.mBillboardSet.getBillboardType() == BBT_PERPENDICULAR_SELF) && (d.mDirection = f.direction, d.mDirection.normalise()), d.mColour = f.colour, d.mRotation = f.rotation, d.setTexcoordIndex(f.mTexcoordIndex), d.mIsDefaultRotAxis = f.mIsDefaultRotAxis, d.mRotateAxis.copy(f.mRotateAxis), 1 == (d.mOwnDimensions = f.mOwnDimensions) && (d.mWidth = f.mWidth, d.mHeight = f.mHeight);
            var g = this.mBillboardSet.injectBillboard(d, this.currentParticleSystem.hasTouchEvent());
            if (g.center.z < -1 * this.mHalfScreenHeight && g.width > 0 && (f.timeToLive = 0), f.isClickable && g.width > 0 && this.currentParticleSystem.hasTouchEvent()) {
                var h = (new Matrix4, new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
                if (null != this.currentParticleSystem && null != this.currentParticleSystem.getParentGameObject()) {
                    var i = this.currentParticleSystem.getParentGameObject().getTransform();
                    h = i._getInverseTransform()
                }
                for (var j = 0; c > j; j++) {
                    var k = this.mMotionEventList[j];
                    k.x, k.y
                }
            }
        }
        this.mBillboardSet.endBillboards();
        for (var l = 0; c > l; l++);
        this.mMotionEventList.length = 0
    }
}, BillboardParticleRenderer.prototype.getRenderOperation = function(a) {
    this.mBillboardSet.getRenderOperation(a)
}, BillboardParticleRenderer.prototype.OnTouchEvent = function(a, b, c, d) {
    if (2 == arguments.length) {
        var e = arguments[0],
            f = arguments[1];
        this.mMotionEventList.push(new MotionEvent(e, f))
    } else 4 == arguments.length && this.currentParticleSystem.hasTouchEvent() && this.mMotionEventList.push(new MotionEvent(a, b, c, d))
}, BillboardParticleRenderer.prototype.setCurrentParentGameObject = function(a) {
    a && this.mBillboardSet.setParentGameObject(a)
}, BillboardParticleRenderer.prototype._notifyCurrentCamera = function(a) {
    this.mBillboardSet._notifyCurrentCamera(a)
}, BillboardParticleRenderer.prototype._notifyParticleRotated = function() {
    this.mBillboardSet._notifyBillboardRotated()
}, BillboardParticleRenderer.prototype._notifyParticleResized = function() {
    this.mBillboardSet._notifyBillboardResized()
}, BillboardParticleRenderer.prototype._notifyParticleQuota = function(a) {
    this.mBillboardSet.setPoolSize(a)
}, BillboardParticleRenderer.prototype._notifyStacksAndSlices = function(a, b) {
    this.mBillboardSet.setTextureStacksAndSlices(a, b)
}, BillboardParticleRenderer.prototype._notifyDefaultDimensions = function(a, b) {
    this.mBillboardSet.setDefaultDimensions(a, b)
}, BillboardParticleRenderer.prototype.setRenderQueueGroup = function() {}, BillboardParticleRenderer.prototype.setKeepParticlesInLocalSpace = function(a) {
    this.mBillboardSet.setBillboardsInWorldSpace(!a)
}, BillboardParticleRenderer.prototype._getSortMode = function() {
    return this.mBillboardSet._getSortMode()
}, BillboardParticleRenderer.prototype.getBillboardSet = function() {
    return this.mBillboardSet
}, BillboardParticleRenderer.prototype._notifyUVSSet = function(a, b) {
    this.mBillboardSet.setTextureCoords(a, b)
}, BillboardParticleRenderer.prototype.getParticlesType = function() {
    var a = this.mBillboardSet.getBillboardType();
    switch (a) {
        case BBT_POINT:
            return PT_BBT_POINT;
        case BBT_NOCAMERA:
            return PT_BBT_NOCAMERA;
        case BBT_ORIENTED_COMMON:
            return PT_BBT_ORIENTED_COMMON;
        case BBT_ORIENTED_SELF:
            return PT_BBT_ORIENTED_SELF;
        case BBT_PERPENDICULAR_COMMON:
            return PT_BBT_PERPENDICULAR_COMMON;
        case BBT_PERPENDICULAR_SELF:
            return PT_BBT_PERPENDICULAR_SELF
    }
    return PT_BBT_POINT
}, BillboardParticleRenderer.prototype.setParticlesType = function(a) {
    var b = BBT_POINT;
    switch (a) {
        case PT_BBT_POINT:
            b = BBT_POINT;
            break;
        case PT_BBT_NOCAMERA:
            b = BBT_NOCAMERA;
            break;
        case PT_BBT_ORIENTED_COMMON:
            b = BBT_ORIENTED_COMMON;
            break;
        case PT_BBT_ORIENTED_SELF:
            b = BBT_ORIENTED_SELF;
            break;
        case PT_BBT_PERPENDICULAR_COMMON:
            b = BBT_PERPENDICULAR_COMMON;
            break;
        case PT_BBT_PERPENDICULAR_SELF:
            b = BBT_PERPENDICULAR_SELF
    }
    this.mBillboardSet.setBillboardType(b)
};
var BillboardParticleRendererFactory = function() {
    ParticleSystemRendererFactory.call(this)
};
extend(BillboardParticleRendererFactory, ParticleSystemRendererFactory), BillboardParticleRendererFactory.prototype.getType = function() {
    return rendererTypeName
}, BillboardParticleRendererFactory.prototype.createInstance = function(a, b) {
    return new BillboardParticleRenderer(a)
}, BillboardParticleRendererFactory.prototype.destroyInstance = function(a) {};
var ParticleControler = function(a, b, c, d, e, f, g) {
        function h(a, b) {
            return function() {
                b.apply(a, arguments)
            }
        }
        var i = this;
        i.screen = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
        }, i.object = a, i.domElement = void 0 !== b ? b : document, i.mouseDown = !1, i.moved = !1, i.startTime = 0, i.currentTime = 0, i.lagTime = 0, i.startPos = {
            x: 0,
            y: 0
        }, i.endPos = {
            x: 0,
            y: 0
        }, i.curPos = {
            x: 0,
            y: 0
        }, i.handleResize = function() {
            var a = (i.screen, 0);
            if (i.domElement == b) {
                a = 1;
                var c = this.domElement.getBoundingClientRect();
                i.screen.left = c.left, i.screen.top = c.top, i.screen.width = c.width, i.screen.height = c.height
            } else {
                a = 2;
                var c = this.domElement.getBoundingClientRect(),
                    d = this.domElement.ownerDocument.documentElement;
                i.screen.left = c.left + window.pageXOffset - d.clientLeft, i.screen.top = c.top + window.pageYOffset - d.clientTop, i.screen.width = c.width, i.screen.height = c.height
            }
        }, i.getMouseOnScreen = function(a, b) {
            return {
                x: (a - i.screen.left) / i.screen.width,
                y: (b - i.screen.top) / i.screen.height
            }
        }, i.touchStartHandler = function(a) {
            if (i.startTime = (new Date).getTime(), i.moved = !1, a.preventDefault(), a.stopPropagation(), a.touches.length > 0) {
                var b = a.touches[0];
                i.curPos = i.getMouseOnScreen(b.pageX, b.pageY), i.startPos = i.curPos, f && f(i.curPos)
            }
        }, i.touchMoveHandler = function(a) {
            if (i.moved = !0, a.preventDefault(), a.stopPropagation(), a.touches.length > 0) {
                var b = a.touches[0];
                i.curPos = i.getMouseOnScreen(b.pageX, b.pageY), i.endPos = i.curPos;
                var c = i.endPos.x - i.startPos.x,
                    e = i.endPos.y - i.startPos.y;
                d && d(i.curPos, c, e)
            }
        }, i.touchEndHandler = function(a) {
            if (i.currentTime = (new Date).getTime(), i.lagTime = i.currentTime - i.startTime, a.preventDefault(), a.stopPropagation(), a.changedTouches.length > 0) {
                var b = a.changedTouches[0];
                i.curPos = i.getMouseOnScreen(b.pageX, b.pageY), i.endPos = i.curPos;
                var f = i.endPos.x - i.startPos.x,
                    h = i.endPos.y - i.startPos.y;
                !i.moved || 0 == f && 0 == h ? i.lagTime < 300 ? c && c(i.curPos) : e && e(i.curPos) : d && (d(i.curPos, f, h), i.startPos = i.endPos), g && g(i.curPos, f, h), i.moved = !1
            }
        }, i.mouseDownHandler = function(a) {
            i.startTime = (new Date).getTime(), i.moved = !1, i.mouseDown = !0, a = a || window.event;
            var b = 0,
                c = 0;
            a.pageX || a.pageY ? (b = a.pageX, c = a.pageY) : (b = a.clientX + document.body.scrollLeft - document.body.clientLeft, c = a.clientY + document.body.scrollTop - document.body.clientTop), a.preventDefault(), a.stopPropagation();
            var d = i.getMouseOnScreen(b, c);
            i.startPos = {
                x: d.x,
                y: d.y
            }, f && f(d)
        }, i.mouseMoveHandler = function(a) {
            i.moved = !1, a = a || window.event;
            var b = 0,
                c = 0;
            if (a.pageX || a.pageY ? (b = a.pageX, c = a.pageY) : (b = a.clientX + document.body.scrollLeft - document.body.clientLeft, c = a.clientY + document.body.scrollTop - document.body.clientTop), a.preventDefault(), a.stopPropagation(), i.mouseDown) {
                i.curPos = i.getMouseOnScreen(b, c), i.endPos = {
                    x: i.curPos.x,
                    y: i.curPos.y
                };
                var e = i.endPos.x - i.startPos.x,
                    f = i.endPos.y - i.startPos.y;
                d && (Math.abs(e) > 0 || Math.abs(f) > 0) && (i.moved = !0, d(i.curPos, e, f))
            }
        }, i.mouseUpHandler = function(a) {
            i.mouseDown = !1, i.currentTime = (new Date).getTime(), i.lagTime = i.currentTime - i.startTime, a.preventDefault(), a.stopPropagation();
            var b = i.getMouseOnScreen(a.pageX, a.pageY);
            i.endPos = {
                x: b.x,
                y: b.y
            };
            var f = i.endPos.x - i.startPos.x,
                h = i.endPos.y - i.startPos.y;
            i.moved ? d && d(b, f, h) : i.lagTime < 300 ? c && c(b) : e && e(b), g && g(b, f, h), i.moved = !1
        }, document.addEventListener("mousedown", i.mouseDownHandler, !1), document.addEventListener("mouseup", i.mouseUpHandler, !1), document.addEventListener("mousemove", i.mouseMoveHandler, !1), document.addEventListener("touchstart", h(this, i.touchStartHandler), !1), document.addEventListener("touchend", h(this, i.touchEndHandler), !1), document.addEventListener("touchmove", h(this, i.touchMoveHandler), !1), i.handleResize()
    },
    PointEmitterFactory = function() {
        ParticleEmitterFactory.call(this)
    };
extend(PointEmitterFactory, ParticleEmitterFactory), PointEmitterFactory.prototype.getName = function() {
    return "Point"
}, PointEmitterFactory.prototype.createEmitter = function(a) {
    var b = new PointEmitter(a);
    return this.mEmitters.push(b), b
}, PointEmitterFactory.prototype.destroyEmitter = function(a) {
    a && (a = null)
};
var PointEmitter = function(a) {
    ParticleEmitter.call(this, a), this.mType = "Point", this.createParamDictionary("PointEmitter") && this.addBaseParameters()
};
extend(PointEmitter, ParticleEmitter), PointEmitter.prototype._initParticle = function(a) {
    this.initParticle(a), a.position = this.mPosition, this.genEmissionColour(a.colour), this.genEmissionDirection(a.direction), this.genEmissionVelocity(a.direction), a.timeToLive = this.genEmissionTTL(), a.totalTimeToLive = a.timeToLive
}, PointEmitter.prototype._getEmissionCount = function(a) {
    return this.genConstantEmissionCount(a)
};
var AreaEmitter = function(a) {
    ParticleEmitter.call(this, a), this.mSize = new Vector3, this.mXRange = new Vector3, this.mYRange = new Vector3, this.mZRange = new Vector3, this.mIsRangeFixed = !1, this.mXRangeFactor = .15625, this.mYRangeFactor = .10417, this.mZRangeFactor = .10417
};
extend(AreaEmitter, ParticleEmitter), AreaEmitter.prototype._getEmissionCount = function(a) {
    return this.genConstantEmissionCount(a)
}, AreaEmitter.prototype.setDirection = function(a) {
    this.mDirection = a, this.mDirection.normalise(), this.mUp = this.mDirection.perpendicular(), this.mUp.normalise(), this.genAreaAxes()
}, AreaEmitter.prototype.setSize = function(a, b, c) {
    if (1 == arguments.length) {
        var d = arguments[0];
        this.mSize.x = d.x, this.mSize.y = d.y, this.mSize.z = d.z
    } else 3 == arguments.length && (this.mSize.x = a, this.mSize.y = b, this.mSize.z = c);
    this.genAreaAxes()
}, AreaEmitter.prototype.setWidth = function(a) {
    this.mSize.x = a, this.genAreaAxes()
}, AreaEmitter.prototype.setHeight = function(a) {
    this.mSize.y = a, this.genAreaAxes()
}, AreaEmitter.prototype.setDepth = function(a) {
    this.mSize.z = a, this.genAreaAxes()
}, AreaEmitter.prototype.getDepth = function() {
    return this.mSize.z
}, AreaEmitter.prototype.getHeight = function() {
    return this.mSize.y
}, AreaEmitter.prototype.getWidth = function() {
    return this.mSize.x
}, AreaEmitter.prototype.genAreaAxes = function() {
    var a = this.mUp.cross(this.mDirection);
    this.mXRange = a.multiply(.5 * this.mSize.x), this.mYRange = this.mUp.multiply(.5 * this.mSize.y), this.mZRange = this.mDirection.multiply(.5 * this.mSize.z)
}, AreaEmitter.prototype.isRangeFixed = function() {
    return this.mIsRangeFixed
}, AreaEmitter.prototype.enableRangeFixed = function(a) {
    this.mIsRangeFixed = a
}, AreaEmitter.prototype.setRangeFactor = function(a) {
    this.mXRangeFactor = a, this.mYRangeFactor = a, this.mZRangeFactor = a
}, AreaEmitter.prototype.getRangeFactor = function() {
    return this.mXRangeFactor
}, AreaEmitter.prototype.setXRangeFactor = function(a) {
    this.mXRangeFactor = a
}, AreaEmitter.prototype.getXRangeFactor = function() {
    return this.mXRangeFactor
}, AreaEmitter.prototype.setYRangeFactor = function(a) {
    this.mYRangeFactor = a
}, AreaEmitter.prototype.getYRangeFactor = function() {
    return this.mYRangeFactor
}, AreaEmitter.prototype.setZRangeFactor = function(a) {
    this.mZRangeFactor = a
}, AreaEmitter.prototype.getZRangeFactor = function() {
    return this.mZRangeFactor
}, AreaEmitter.prototype.resize = function(a, b) {
    this._resize(a, b), this.mIsRangeFixed || (this.mSize.x = a * this.mXRangeFactor, this.mSize.y = b * this.mYRangeFactor, this.mSize.z = b * this.mZRangeFactor, this.genAreaAxes())
}, AreaEmitter.prototype.copyParametersTo = function(a) {
    this.constructor.superclass.copyParametersTo(a), this.mIsRangeFixed || (a.mSize.x = this.mSize.x, a.mSize.y = this.mSize.y, a.mSize.z = this.mSize.z, a.genAreaAxes())
}, AreaEmitter.prototype.initDefaults = function(a) {
    return this.mDirection = new Vector3(0, 0, 1), this.mUp = new Vector3(0, 1, 0), this.setSize(100, 100, 100), this.mType = a, this.mIsRangeFixed = !1, this.mXRangeFactor = .15625, this.mYRangeFactor = .10417, this.mZRangeFactor = .10417, !0
};
var BoxEmitter = function(a) {
    AreaEmitter.call(this, a), this.initDefaults("Box")
};
extend(BoxEmitter, AreaEmitter), BoxEmitter.prototype._initParticle = function(a) {
    var b, c, d;
    this.initParticle(a), b = this.mXRange.multiply(2 * Math.random() - 1), c = this.mYRange.multiply(2 * Math.random() - 1), d = this.mZRange.multiply(2 * Math.random() - 1), a.position = this.mPosition.add(b).add(c).add(d), this.genEmissionColour(a.colour), this.genEmissionDirection(a.direction), this.genEmissionVelocity(a.direction), a.timeToLive = this.genEmissionTTL(), a.totalTimeToLive = a.timeToLive
};
var BoxEmitterFactory = function() {
    ParticleEmitterFactory.call(this)
};
extend(BoxEmitterFactory, ParticleEmitterFactory), BoxEmitterFactory.prototype.getName = function() {
    return "Box"
}, BoxEmitterFactory.prototype.createEmitter = function(a) {
    var b = new BoxEmitter(a);
    return this.mEmitters.push(b), b
}, BoxEmitterFactory.prototype.destroyEmitter = function(a) {
    a && (a = null)
};
var LinearForceAffector = function(a) {
    ParticleAffector.call(this), this.mType = "LinearForce", this.mForceVector = new Vector3(0, -100, 0), this.mProductAjustFactor = 1, this.mForceApplication = FA_ADD
};
extend(LinearForceAffector, ParticleAffector), LinearForceAffector.prototype._affectParticles = function(a, b) {
    var c, d = a._getIterator(),
        e = new Vector3(0, 0, 0);
    this.mForceApplication == FA_ADD && (e = this.mForceVector.multiply(b));
    for (var f in d) {
        c = d[f];
        var g = (c.totalTimeToLive - c.timeToLive) / c.totalTimeToLive * 64;
        g = (6 - Math.log(g) / Math.log(2)) / 600, e = this.mForceVector.multiply(g), this.mForceApplication == FA_ADD ? c.direction = c.direction.add(e) : this.mForceApplication == FA_AVERAGE ? c.direction = c.direction.add(this.mForceVector).div(2) : this.mForceApplication == FA_PRODUCT && (c.direction = c.direction.multiply(this.mProductAjustFactor + g))
    }
}, LinearForceAffector.prototype.setForceVector = function(a) {
    this.mForceVector = a
}, LinearForceAffector.prototype.getForceVector = function() {
    return this.mForceVector
}, LinearForceAffector.prototype.setForceApplication = function(a) {
    this.mForceApplication = a
}, LinearForceAffector.prototype.getForceApplication = function() {
    return this.mForceApplication
}, LinearForceAffector.prototype.setProductAjustFactor = function(a) {
    this.mProductAjustFactor = a
}, LinearForceAffector.prototype.getProductAjustFactor = function() {
    return this.mProductAjustFactor
};
var FA_AVERAGE = 0,
    FA_ADD = 1,
    FA_PRODUCT = 2,
    LinearForceAffectorFactory = function() {
        ParticleAffectorFactory.call(this)
    };
extend(LinearForceAffectorFactory, ParticleAffectorFactory), LinearForceAffectorFactory.prototype.getName = function() {
    return "LinearForce"
}, LinearForceAffectorFactory.prototype.createAffector = function(a) {
    var b = new LinearForceAffector(a);
    return this.mAffectors.push(b), b
}, LinearForceAffectorFactory.prototype.destroyAffector = function(a) {
    a && (a = null)
};
var RotationAffector = function(a) {
    ParticleAffector.call(this), this.mRotationSpeedRangeStart = 0, this.mRotationSpeedRangeEnd = 0, this.mRotationRangeStart = 0, this.mRotationRangeEnd = 0, this.mType = "Rotator", this.mSyncWithDirection = !1, this.mIsDefaultRotateAxis = !0, this.mIsRandomRotateAxis = !1, this.mRotateAxis = new Vector3, this.mRotateAxis.x = 0, this.mRotateAxis.y = 0, this.mRotateAxis.z = 1
};
extend(RotationAffector, ParticleAffector), RotationAffector.prototype._initParticle = function(a) {
    a.mIsDefaultRotateAxis = this.mIsDefaultRotateAxis, this.mIsDefaultRotateAxis || (this.mIsRandomRotateAxis ? (a.mRotateAxis.x = Math.random(), a.mRotateAxis.y = Math.random(), a.mRotateAxis.z = Math.random()) : (a.mRotateAxis.x = this.mRotateAxis.x, a.mRotateAxis.y = this.mRotateAxis.y, a.mRotateAxis.z = this.mRotateAxis.z)), this.mSysncWithDirection ? a.setRotation(this.genAngleWithDirection(a.direction)) : (a.setRotation(Math.rangeRandom(this.mRotationRangeStart, this.mRotationRangeEnd)), a.rotationSpeed = Math.rangeRandom(this.mRotationSpeedRangeStart, this.mRotationSpeedRangeEnd))
}, RotationAffector.prototype._affectParticles = function(a, b) {
    var c, d, e = a._getIterator(),
        f = b;
    for (var g in e) c = e[g], this.mSyncWithDirection ? c.setRotation(this.genAngleWithDirection(c.direction)) : (d = c.rotation + f * c.rotationSpeed, c.setRotation(d))
}, RotationAffector.prototype.genAngleWithDirection = function(a) {
    var b, c = Math.RealEqual(a.x, 0),
        d = Math.RealEqual(a.y, 0);
    return c && d ? b = 0 : c ? a.y > 0 ? b = Math.radians(180) : a.y < 0 && (b = Math.radians(0)) : d ? a.x > 0 ? b = Math.radians(90) : a.x < 0 && (b = Math.radians(270)) : a.x > 0 && a.y > 0 ? b = Math.radians(270) - Math.atan(a.y / a.x) : a.x > 0 && a.y < 0 ? b = Math.radians(270) + Math.atan(Math.abs(a.y) / a.x) : a.x < 0 && a.y > 0 ? b = Math.radians(90) - Math.atan(a.y / Math.abs(a.x)) : a.x < 0 && a.y < 0 && (b = Math.radians(90) + Math.atan(Math.abs(a.y) / Math.abs(a.x))), b
}, RotationAffector.prototype.getRotationSpeedRangeStart = function() {
    return this.mRotationSpeedRangeStart
}, RotationAffector.prototype.getRotationSpeedRangeEnd = function() {
    return this.mRotationSpeedRangeEnd
}, RotationAffector.prototype.setRotationSpeedRangeStart = function(a) {
    this.mRotationSpeedRangeStart = Math.radians(a)
}, RotationAffector.prototype.setRotationSpeedRangeEnd = function(a) {
    this.mRotationSpeedRangeEnd = Math.radians(a)
}, RotationAffector.prototype.getRotationRangeStart = function() {
    return this.mRotationRangeStart
}, RotationAffector.prototype.getRotationRangeEnd = function() {
    return this.mRotationRangeEnd
}, RotationAffector.prototype.setRotationRangeStart = function(a) {
    this.mRotationRangeStart = Math.radians(a)
}, RotationAffector.prototype.setRotationRangeEnd = function(a) {
    this.mRotationRangeEnd = Math.radians(a)
}, RotationAffector.prototype.enableSyncWithDirection = function(a) {
    this.mSysncWithDirection = a
}, RotationAffector.prototype.isSyncWithDirection = function() {
    return this.mSysncWithDirection
};
var RotationAffectorFactory = function() {
    ParticleAffectorFactory.call(this)
};
extend(RotationAffectorFactory, ParticleAffectorFactory), RotationAffectorFactory.prototype.getName = function() {
    return "Rotator"
}, RotationAffectorFactory.prototype.createAffector = function(a) {
    var b = new RotationAffector(a);
    return this.mAffectors.push(b), b
}, RotationAffectorFactory.prototype.destroyAffector = function(a) {
    a && (a = null)
};
var ColourFaderAffector = function() {
    ParticleAffector.call(this), this.mType = "ColourFader", this.mRedAdj = 0, this.mGreenAdj = 0, this.mBlueAdj = 0, this.mAlphaAdj = 0
};
extend(ParticleAffector, ParticleAffector), ColourFaderAffector.prototype.applyAdjustWithClamp = function(a, b) {
    return a += b, 0 > a ? a = 0 : a > 1 && (a = 1), a
}, ColourFaderAffector.prototype._affectParticles = function(a, b) {
    var c, d, e, f, g, h = a._getIterator();
    d = this.mRedAdj * b, e = this.mGreenAdj * b, f = this.mBlueAdj * b, g = this.mAlphaAdj * b;
    for (var i in h) c = h[i], c.colour.r = this.applyAdjustWithClamp(c.colour.r, d), c.colour.g = this.applyAdjustWithClamp(c.colour.g, e), c.colour.b = this.applyAdjustWithClamp(c.colour.b, f), c.colour.a = this.applyAdjustWithClamp(c.colour.a, g)
}, ColourFaderAffector.prototype.setAdjust = function(a, b, c, d) {
    this.mRedAdj = a, this.mGreenAdj = b, this.mBlueAdj = c, this.mAlphaAdj = d
}, ColourFaderAffector.prototype.setRedAdjust = function(a) {
    this.mRedAdj = a
}, ColourFaderAffector.prototype.getRedAdjust = function() {
    return this.mRedAdj
}, ColourFaderAffector.prototype.setGreenAdjust = function(a) {
    this.mGreenAdj = a
}, ColourFaderAffector.prototype.getGreenAdjust = function() {
    return this.mGreenAdj
}, ColourFaderAffector.prototype.setBlueAdjust = function(a) {
    this.mBlueAdj = a
}, ColourFaderAffector.prototype.getBlueAdjust = function() {
    return this.mBlueAdj
}, ColourFaderAffector.prototype.setAlphaAdjust = function(a) {
    this.mAlphaAdj = a
}, ColourFaderAffector.prototype.getAlphaAdjust = function() {
    return this.mAlphaAdj
};
var ColourFaderAffectorFactory = function() {
    ParticleAffectorFactory.call(this)
};
extend(ColourFaderAffectorFactory, ParticleAffectorFactory), ColourFaderAffectorFactory.prototype.getName = function() {
    return "ColourFader"
}, ColourFaderAffectorFactory.prototype.createAffector = function(a) {
    var b = new ColourFaderAffector(a);
    return this.mAffectors.push(b), b
}, ColourFaderAffectorFactory.prototype.destroyAffector = function(a) {
    a && (a = null)
};
var ColourFaderAffector2 = function() {
    ParticleAffector.call(this), this.mType = "ColourFader2", this.mRedAdj1 = 0, this.mGreenAdj1 = 0, this.mBlueAdj1 = 0, this.mAlphaAdj1 = 0, this.mRedAdj2 = 0, this.mGreenAdj2 = 0, this.mBlueAdj2 = 0, this.mAlphaAdj2 = 0, this.StateChangeVal = 1
};
extend(ColourFaderAffector2, ParticleAffector), ColourFaderAffector2.prototype.applyAdjustWithClamp = function(a, b) {
    return a += b, 0 > a ? a = 0 : a > 1 && (a = 1), a
}, ColourFaderAffector2.prototype._affectParticles = function(a, b) {
    var c, d, e, f, g, h, i, j, k, l = a._getIterator();
    d = this.mRedAdj1 * b, e = this.mGreenAdj1 * b, f = this.mBlueAdj1 * b, g = this.mAlphaAdj1 * b, h = this.mRedAdj2 * b, i = this.mGreenAdj2 * b, j = this.mBlueAdj2 * b, k = this.mAlphaAdj2 * b;
    for (var m in l) c = l[m], c.timeToLive > this.StateChangeVal ? (c.colour.r = this.applyAdjustWithClamp(c.colour.r, d), c.colour.g = this.applyAdjustWithClamp(c.colour.g, e), c.colour.b = this.applyAdjustWithClamp(c.colour.b, f), c.colour.a = this.applyAdjustWithClamp(c.colour.a, g)) : (c.colour.r = this.applyAdjustWithClamp(c.colour.r, h), c.colour.g = this.applyAdjustWithClamp(c.colour.g, i), c.colour.b = this.applyAdjustWithClamp(c.colour.b, j), c.colour.a = this.applyAdjustWithClamp(c.colour.a, k))
}, ColourFaderAffector2.prototype.setAdjust1 = function(a, b, c, d) {
    this.mRedAdj1 = a, this.mGreenAdj1 = b, this.mBlueAdj1 = c, this.mAlphaAdj1 = d
}, ColourFaderAffector2.prototype.setRedAdjust1 = function(a) {
    this.mRedAdj1 = a
}, ColourFaderAffector2.prototype.getRedAdjust1 = function() {
    return this.mRedAdj1
}, ColourFaderAffector2.prototype.setGreenAdjust1 = function(a) {
    this.mGreenAdj1 = a
}, ColourFaderAffector2.prototype.getGreenAdjust1 = function() {
    return this.mGreenAdj1
}, ColourFaderAffector2.prototype.setBlueAdjust1 = function(a) {
    this.mBlueAdj1 = a
}, ColourFaderAffector2.prototype.getBlueAdjust1 = function() {
    return this.mBlueAdj1
}, ColourFaderAffector2.prototype.setAlphaAdjust1 = function(a) {
    this.mAlphaAdj1 = a
}, ColourFaderAffector2.prototype.getAlphaAdjust1 = function() {
    return this.mAlphaAdj1
}, ColourFaderAffector2.prototype.setAdjust1 = function(a, b, c, d) {
    this.mRedAdj2 = a, this.mGreenAdj2 = b, this.mBlueAdj2 = c, this.mAlphaAdj2 = d
}, ColourFaderAffector2.prototype.setRedAdjust2 = function(a) {
    this.mRedAdj2 = a
}, ColourFaderAffector2.prototype.getRedAdjust2 = function() {
    return this.mRedAdj2
}, ColourFaderAffector2.prototype.setGreenAdjust2 = function(a) {
    this.mGreenAdj2 = a
}, ColourFaderAffector2.prototype.getGreenAdjust2 = function() {
    return this.mGreenAdj2
}, ColourFaderAffector2.prototype.setBlueAdjust2 = function(a) {
    this.mBlueAdj2 = a
}, ColourFaderAffector2.prototype.getBlueAdjust2 = function() {
    return this.mBlueAdj2
}, ColourFaderAffector2.prototype.setAlphaAdjust2 = function(a) {
    this.mAlphaAdj2 = a
}, ColourFaderAffector2.prototype.getAlphaAdjust2 = function() {
    return this.mAlphaAdj2
};
var ColourFaderAffectorFactory2 = function() {
    ParticleAffectorFactory.call(this)
};
extend(ColourFaderAffectorFactory2, ParticleAffectorFactory), ColourFaderAffectorFactory2.prototype.getName = function() {
    return "ColourFader"
}, ColourFaderAffectorFactory2.prototype.createAffector = function(a) {
    var b = new ColourFaderAffector(a);
    return this.mAffectors.push(b), b
}, ColourFaderAffectorFactory2.prototype.destroyAffector = function(a) {
    a && (a = null)
};
var ColourInterpolatorAffector = function() {
    ParticleAffector.call(this), this.mColourAdj = [], this.mTimeAdj = [];
    for (var a = 0; MAX_STAGES > a; a++) this.mColourAdj[a] = new ColourValue(.5, .5, .5, 0), this.mTimeAdj[a] = 1;
    this.mType = "ColourInterpolator"
};
extend(ColourInterpolatorAffector, ParticleAffector), ColourInterpolatorAffector.prototype._affectParticles = function(a, b) {
    var c, d = a._getIterator();
    for (var e in d) {
        c = d[e];
        var f = c.totalTimeToLive,
            g = 1 - c.timeToLive / f;
        if (g <= this.mTimeAdj[0]) c.colour = this.mColourAdj[0];
        else if (g >= this.mTimeAdj[MAX_STAGES - 1]) c.colour = this.mColourAdj[MAX_STAGES - 1];
        else
            for (var h = 0; MAX_STAGES - 1 > h; h++)
                if (g >= this.mTimeAdj[h] && g < this.mTimeAdj[h + 1]) {
                    g -= this.mTimeAdj[h], g /= this.mTimeAdj[h + 1] - this.mTimeAdj[h], c.colour.r = this.mColourAdj[h + 1].r * g + this.mColourAdj[h].r * (1 - g), c.colour.g = this.mColourAdj[h + 1].g * g + this.mColourAdj[h].g * (1 - g), c.colour.b = this.mColourAdj[h + 1].b * g + this.mColourAdj[h].b * (1 - g), c.colour.a = this.mColourAdj[h + 1].a * g + this.mColourAdj[h].a * (1 - g);
                    break
                }
    }
}, ColourInterpolatorAffector.prototype.setColourAdjust = function(a, b) {
    this.mColourAdj[a] = b
}, ColourInterpolatorAffector.prototype.getColourAdjust = function(a) {
    return this.mColourAdj[a]
}, ColourInterpolatorAffector.prototype.setTimeAdjust = function(a, b) {
    this.mTimeAdj[a] = b
}, ColourInterpolatorAffector.prototype.getTimeAdjust = function(a) {
    return this.mTimeAdj[a]
};
var MAX_STAGES = 6,
    ColourInterpolatorAffectorFactory = function() {
        ParticleAffectorFactory.call(this)
    };
extend(ColourInterpolatorAffectorFactory, ParticleAffectorFactory), ColourInterpolatorAffectorFactory.prototype.getName = function() {
    return "ColourInterpolator"
}, ColourInterpolatorAffectorFactory.prototype.createAffector = function(a) {
    var b = new ColourInterpolatorAffector(a);
    return this.mAffectors.push(b), b
}, ColourInterpolatorAffectorFactory.prototype.destroyAffector = function(a) {
    a && (a = null)
};
var ScaleAffector = function() {
    ParticleAffector.call(this), this.mType = "Scaler", this.mScaleAdj = 0, this.mWidthScaleAdj = 0, this.mHeightScaleAdj = 0
};
extend(ScaleAffector, ParticleAffector), ScaleAffector.prototype._affectParticles = function(a, b) {
    var c, d, e, f = a._getIterator();
    d = this.mWidthScaleAdj * b, e = this.mHeightScaleAdj * b;
    var g, h;
    for (var i in f) c = f[i], 0 == c.hasOwnDimensions() ? (g = a.getDefaultWidth() + d, h = a.getDefaultHeight() + e) : (g = c.getOwnWidth() + d, h = c.getOwnHeight() + e), c.setDimensions(g, h)
}, ScaleAffector.prototype.setAdjust = function(a) {
    this.mScaleAdj = a, this.mWidthScaleAdj = this.mScaleAdj, this.mHeightScaleAdj = this.mScaleAdj
}, ScaleAffector.prototype.getAdjust = function() {
    return this.mScaleAdj
}, ScaleAffector.prototype.setWidthAdjust = function(a) {
    this.mWidthScaleAdj = a
}, ScaleAffector.prototype.getWidthAdjust = function() {
    return this.mWidthScaleAdj
}, ScaleAffector.prototype.setHeightAdjust = function(a) {
    this.mHeightScaleAdj = a
}, ScaleAffector.prototype.getHeightAdjust = function() {
    return this.mHeightScaleAdj
};
var ScaleAffectorFactory = function() {
    ParticleAffectorFactory.call(this)
};
extend(ScaleAffectorFactory, ParticleAffectorFactory), ScaleAffectorFactory.prototype.getName = function() {
    return "Scaler"
}, ScaleAffectorFactory.prototype.createAffector = function(a) {
    var b = new ScaleAffector(a);
    return this.mAffectors.push(b), b
}, ScaleAffectorFactory.prototype.destroyAffector = function(a) {
    a && (a = null)
};
var TextureAffector = function() {
    ParticleAffector.call(this), this.mType = "Texture", this.mMinTexcoordIndex = 0, this.mMaxTexcoordIndex = 0, this.mDeltaTime = .0417, this.mPastDeltaTime = 0, this.mFromTime = 0, this.mToTime = 1, this.mTextureAffectMode = ALL_TIME
};
extend(TextureAffector, ParticleAffector), TextureAffector.prototype._affectParticles = function(a, b) {
    if (!(ALL_TIME == this.mTextureAffectMode && (this.mPastDeltaTime += b, this.mPastDeltaTime < this.mDeltaTime))) {
        var c, d = a._getIterator();
        if (PART_TIME == this.mTextureAffectMode && this.mFromTime > this.mToTime) {
            var e = this.mToTime;
            this.mToTime = this.mFromTime, this.mFromTime = e
        }
        for (var f in d)
            if (c = d[f], PART_TIME == this.mTextureAffectMode) {
                if (this.mFromTime != this.mToTime) {
                    var g = (c.totalTimeToLive - c.timeToLive) / c.totalTimeToLive;
                    if (g >= this.mFromTime && g <= this.mToTime) {
                        var h = this.mMaxTexcoordIndex - this.mMinTexcoordIndex + 1,
                            i = (g - this.mFromTime) / (this.mToTime - this.mFromTime);
                        if (1 > i) {
                            var j = i * h % h;
                            c.mTexcoordIndex = j
                        }
                    }
                }
            } else c.mTexcoordIndex++, (c.mTexcoordIndex < this.mMinTexcoordIndex || c.mTexcoordIndex > this.mMaxTexcoordIndex) && (c.mTexcoordIndex = this.mMinTexcoordIndex);
        this.mPastDeltaTime = 0
    }
}, TextureAffector.prototype.setMinTexcoordIndex = function(a) {
    this.mMinTexcoordIndex = a
}, TextureAffector.prototype.getMinTexcoordIndex = function() {
    return this.mMinTexcoordIndex
}, TextureAffector.prototype.setMaxTexcoordIndex = function(a) {
    this.mMaxTexcoordIndex = a
}, TextureAffector.prototype.getMaxTexcoordIndex = function() {
    return this.mMaxTexcoordIndex
}, TextureAffector.prototype.setDeltaTime = function(a) {
    this.mDeltaTime = a
}, TextureAffector.prototype.getDeltaTime = function() {
    return this.mDeltaTime
}, TextureAffector.prototype.setTextureAffectMode = function(a) {
    this.mTextureAffectMode = a
}, TextureAffector.prototype.getTextureAffectMode = function() {
    return this.mTextureAffectMode
}, TextureAffector.prototype.setFromTime = function(a) {
    a >= 0 && 1 >= a && (this.mFromTime = a)
}, TextureAffector.prototype.getFromTime = function() {
    return this.mFromTime
}, TextureAffector.prototype.setToTime = function(a) {
    a >= 0 && 1 >= a && (this.mToTime = a)
}, TextureAffector.prototype.getToTime = function() {
    return this.mToTime
};
var ALL_TIME = 0,
    PART_TIME = 1,
    TextureAffectorFactory = function() {
        ParticleAffectorFactory.call(this)
    };
extend(TextureAffectorFactory, ParticleAffectorFactory), TextureAffectorFactory.prototype.getName = function() {
    return "Texture"
}, TextureAffectorFactory.prototype.createAffector = function(a) {
    var b = new TextureAffector(a);
    return this.mAffectors.push(b), b
}, TextureAffectorFactory.prototype.destroyAffector = function(a) {
    a && (a = null)
};
var TextureFrameAffector = function() {
    ParticleAffector.call(this), this.mFrameAdj = [], this.mTimeAdj = [];
    for (var a = 0; MAX_STAGES > a; a++) this.mFrameAdj[a] = 0, this.mTimeAdj[a] = 1;
    this.mType = "TextureFrameAffector"
};
extend(TextureFrameAffector, ParticleAffector), TextureFrameAffector.prototype._affectParticles = function(a, b) {
    var c, d = a._getIterator();
    for (var e in d) {
        c = d[e];
        var f = c.totalTimeToLive,
            g = 1 - c.timeToLive / f
    }
    if (g <= this.mTimeAdj[0]) c.mTexcoordIndex = this.mFrameAdj[0];
    else if (g >= this.mTimeAdj[MAX_STAGES - 1]) c.mTexcoordIndex = this.mFrameAdj[MAX_STAGES - 1];
    else
        for (var h = 0; MAX_STAGES - 1 > h; h++)
            if (g >= this.mTimeAdj[h] && g < this.mTimeAdj[h + 1]) {
                g -= this.mTimeAdj[h], g /= this.mTimeAdj[h + 1] - this.mTimeAdj[h], c.mTexcoordIndex = this.mFrameAdj[h];
                break
            }
}, TextureFrameAffector.prototype.setFrameAdjust = function(a, b) {
    this.mFrameAdj[a] = b
}, TextureFrameAffector.prototype.getFrameAdjust = function(a) {
    return this.mFrameAdj[a]
}, TextureFrameAffector.prototype.setTimeAdjust = function(a, b) {
    this.mTimeAdj[a] = b
}, TextureFrameAffector.prototype.getTimeAdjust = function(a) {
    return this.mTimeAdj[a]
}, MAX_STAGES = 6;
var TextureFrameAffectorFactory = function() {
    ParticleAffectorFactory.call(this)
};
extend(TextureFrameAffectorFactory, ParticleAffectorFactory), TextureFrameAffectorFactory.prototype.getName = function() {
    return "TextureFrame"
}, TextureFrameAffectorFactory.prototype.createAffector = function(a) {
    var b = new TextureFrameAffector(a);
    return this.mAffectors.push(b), b
}, TextureFrameAffectorFactory.prototype.destroyAffector = function(a) {
    a && (a = null)
};
var DirectionRandomiserAffector = function() {
    ParticleAffector.call(this), this.mType = "DirectionRandomiser", this.mRandomness = 1, this.mScope = 1, this.mKeepVelocity = !1
};
extend(DirectionRandomiserAffector, ParticleAffector), DirectionRandomiserAffector.prototype._affectParticles = function(a, b) {
    var c, d = a._getIterator(),
        e = 0;
    for (var f in d) c = d[f], this.mScope > Math.random() && (c.direction.isZeroLength() || (this.mKeepVelocity && (e = c.direction.length()), c.direction = c.direction.add(new Vector3(Math.rangeRandom(-this.mRandomness, this.mRandomness) * b, Math.rangeRandom(-this.mRandomness, this.mRandomness) * b, Math.rangeRandom(-this.mRandomness, this.mRandomness) * b)), this.mKeepVelocity && (c.direction = c.direction.multiply(e / c.direction.length()))))
}, DirectionRandomiserAffector.prototype.setRandomness = function(a) {
    this.mRandomness = a
}, DirectionRandomiserAffector.prototype.setScope = function(a) {
    this.mScope = a
}, DirectionRandomiserAffector.prototype.setKeepVelocity = function(a) {
    this.mKeepVelocity = a
}, DirectionRandomiserAffector.prototype.getRandomness = function() {
    return this.mKeepVelocity
}, DirectionRandomiserAffector.prototype.getScope = function() {
    return this.mScope
}, DirectionRandomiserAffector.prototype.getKeepVelocity = function() {
    return this.mKeepVelocity
};
var DirectionRandomiserAffectorFactory = function() {
    ParticleAffectorFactory.call(this)
};
extend(DirectionRandomiserAffectorFactory, ParticleAffectorFactory), DirectionRandomiserAffectorFactory.prototype.getName = function() {
    return "DirectionRandomiser"
}, DirectionRandomiserAffectorFactory.prototype.createAffector = function(a) {
    var b = new DirectionRandomiserAffector(a);
    return this.mAffectors.push(b), b
}, DirectionRandomiserAffectorFactory.prototype.destroyAffector = function(a) {
    a && (a = null)
};
var RandomCurveAffector = function(a) {
    ParticleAffector.call(this), this.mRoot = a, this.mType = "RandomCurve", this.mActiveMode = "xyz", this.mScaledX = 160, this.mScaledY = 240, this.mScaledZ = 100, this.mIsScaleFixed = !1, this.mScaleFactor = .5, this.mInterpolatorSet = new InterpolatorSet, this._initialInterpolatorSet()
};
extend(RandomCurveAffector, ParticleAffector), RandomCurveAffector.prototype._affectParticles = function(a, b) {
    var c, d = a._getIterator(),
        e = new Vector3(0, 0, 0);
    !this.mIsScaleFixed && a && (this.mScaledX = this.mRoot.mPhoneWidth * this.mScaleFactor, this.mScaledY = this.mRoot.mPhoneHeight * this.mScaleFactor);
    var f = this.mInterpolatorSet.mInterpolatorArray.length;
    for (var g in d) {
        c = d[g];
        var h, i, j, k = c.mRandomFlag;
        0 > k ? (h = .5, i = -1, j = -k) : (h = -.5, i = 1, j = k), h += j > c.totalTimeToLive ? c.totalTimeToLive / k : k / c.totalTimeToLive;
        var l, m, n, o = parseInt(j) % f,
            p = (c.totalTimeToLive - c.timeToLive) / c.totalTimeToLive;
        l = i > 0 ? p : 1 - p, m = o > f / 2 ? p : 1 - p, n = 1 - p;
        var q = parseInt((o - 1) % f);
        q = q > -1 ? q : -q;
        var r = this.mInterpolatorSet.getInterpolator(q).getInterpolation(l);
        r = .5 - r, e.x = (r + h) * this.mScaledX;
        var s = parseInt(o),
            t = this.mInterpolatorSet.getInterpolator(s).getInterpolation(m);
        t = .5 - t, e.y = (t + h) * this.mScaledY;
        var u = parseInt((o + 1) % f),
            v = this.mInterpolatorSet.getInterpolator(u).getInterpolation(n);
        v = .5 - v, e.z = (v + h) * this.mScaledZ, c.direction.x = e.x, c.direction.y = e.y, c.direction.z = e.z
    }
}, RandomCurveAffector.prototype.setScaledX = function(a) {
    this.mScaledX = a
}, RandomCurveAffector.prototype.getScaledX = function() {
    return this.mScaledX
}, RandomCurveAffector.prototype.setScaledY = function(a) {
    this.mScaledY = a
}, RandomCurveAffector.prototype.getScaledY = function() {
    return this.mScaledY
}, RandomCurveAffector.prototype.setScaledZ = function(a) {
    this.mScaledZ = a
}, RandomCurveAffector.prototype.getScaledZ = function() {
    return this.mScaledZ
}, RandomCurveAffector.prototype.getScaleFactor = function() {
    return this.mScaleFactor
}, RandomCurveAffector.prototype.setScaleFactor = function(a) {
    this.mScaleFactor = a
}, RandomCurveAffector.prototype.isScaleFixed = function() {
    return this.mIsScaleFixed
}, RandomCurveAffector.prototype.enableScaleFixed = function(a) {
    this.mIsScaleFixed = a
}, RandomCurveAffector.prototype.setActiveMode = function(a) {
    this.mActiveMode = a
}, RandomCurveAffector.prototype.getActiveMode = function() {
    return this.mActiveMode
}, RandomCurveAffector.prototype._initialInterpolatorSet = function() {
    this.mInterpolatorSet.addInterpolator(new AccelerateDecelerateInterpolator), this.mInterpolatorSet.addInterpolator(new AccelerateInterpolator), this.mInterpolatorSet.addInterpolator(new AnticipateInterpolator), this.mInterpolatorSet.addInterpolator(new AnticipateOvershootInterpolator), this.mInterpolatorSet.addInterpolator(new BounceInterpolator), this.mInterpolatorSet.addInterpolator(new CycleInterpolator(5)), this.mInterpolatorSet.addInterpolator(new DecelerateInterpolator), this.mInterpolatorSet.addInterpolator(new LinearInterpolator), this.mInterpolatorSet.addInterpolator(new OvershootInterpolator)
};
var RandomCurveAffectorFactory = function(a) {
    ParticleAffectorFactory.call(this), this.mRoot = a
};
extend(RandomCurveAffectorFactory, ParticleAffectorFactory), RandomCurveAffectorFactory.prototype.getName = function() {
    return "RandomCurve"
}, RandomCurveAffectorFactory.prototype.createAffector = function(a) {
    var b = new RandomCurveAffector(this.mRoot, a);
    return this.mAffectors.push(b), b
}, RandomCurveAffectorFactory.prototype.destroyAffector = function(a) {
    a && (a = null)
}, Bone = function(a, b, c, d) {
    GameObject.call(this, a, b, d), this.indexId = c, this.mGroupId = d, this.mFirstMat_inv_trap = null, this.mHasCalculated = !1
}, extend(Bone, GameObject), Skeleton = function(a, b) {
    this.mSkeletonName = a, this.mCurrentRenderPass = null, this.mBonesList = [], Resource.call(this, b), this.mGroupId = b
}, extend(Skeleton, Resource), Skeleton.prototype = {
    constructor: Skeleton,
    createBone: function(a, b, c) {
        var d = new Bone(this.mRoot, a, b, this.mGroupId);
        return null != d && c.addToSceneNodes(d) && this.mBonesList.push(d), d
    },
    getBoneByIndex: function(a) {
        for (var b in this.mBonesList) {
            var c = this.mBonesList[b];
            if (c.indexId == a) return c
        }
        return null
    },
    updateBoneMatrix: function(a) {
        if (a) {
            var b = a.getMeshFilter(),
                c = this.mRoot.getMesh(b.mesh);
            if (!c) return !1;
            var d = c.getNumSubMeshes();
            if (d >= 0)
                for (var e = 0; d > e; e++) {
                    var f = c.getSubMesh(e);
                    f.mAmBoneWorld = [], f.mAfBoneWorldIT = [];
                    for (var g in f.mBoneIdList) {
                        var h = f.mBoneIdList[g],
                            i = this.getBoneByIndex(h);
                        if (!i) return console.log("error"), !1;
                        var j = i.getTransform();
                        i.mHasCalculated || (i.mFirstMat_inv_tranp = j.getOriginWorldInvTpTransform(), i.mHasCalculated = !0);
                        var k = j._getFullTransform(),
                            l = i.mFirstMat_inv_tranp.multiply(k.transpose());
                        if (f.mAmBoneWorld.push(l), a.getRenderer().getMaterial().isSkinNormalCal()) {
                            var m = l.inverse().transpose().extract3x3Matrix();
                            f.mAfBoneWorldIT[g] = m
                        }
                    }
                }
        }
    },
    uploadBoneMatrix: function(a, b, c, d) {
        if (null == a || null == b) return !1;
        if (null == b) return !1;
        var e = b.getNumSubMeshes(),
            f = b.getSubMesh(c);
        if (0 >= e || null == f) return !1;
        var g = f.mBoneCount;
        f.mBoneIdList.length;
        return g > 0 && f.mAmBoneWorld && f.mAmBoneWorld.length > 0 && (a.getFragmentProgramParameters().setNamedConstant("boneCount", g), a.getFragmentProgramParameters().setNamedConstant("boneMatrixArray", f.mAmBoneWorld, "matrix4x4Array", f.mAmBoneWorld.length), f.mAfBoneWorldIT.length > 0 && a.getFragmentProgramParameters().setNamedConstant("boneMatrixArrayIT", f.mAfBoneWorldIT, "matrix3x3Array", f.mAfBoneWorldIT.length), this.mRoot.getRenderFunction().mActiveLinkProgram.updateUniforms()), !0
    },
    updateCurrentSubMeshBoneMatrixToGPU: function(a, b, c, d) {
        return null == b ? !1 : this.uploadBoneMatrix(a, b, c, d)
    },
    setCurrentRenderPass: function(a) {
        return null == a ? !1 : (this.mCurrentRenderPass = a, !0)
    }
}, SkeletonManager = function(a) {
    this.mRoot = a, this.mDefaultSkeletonList = [], this.mSkeletonList = []
}, SkeletonManager.prototype = {
    getSkeletonByName: function(a, b) {
        if (b)
            for (var c in this.mSkeletonList) {
                var d = this.mSkeletonList[c];
                if (d.mGroupId == a && d.mSkeletonName == b) return d
            } else
                for (var e in this.mDefaultSkeletonList) {
                    var f = this.mDefaultSkeletonList[e];
                    if (f.mGroupId == a) return f
                }
        return 0
    },
    createSkeleton: function(a, b) {
        if (-1 == a || b) {
            var c = new Skeleton(b, a);
            if (c) return c.mRoot = this.mRoot, this.mSkeletonList.push(c), c
        } else {
            var d = new Skeleton("defaultSkeleton_" + a, a);
            if (d) return this.mDefaultSkeletonList.push(d), d.mRoot = this.mRoot, d
        }
        return 0
    },
    releaseResourcesByGroupID: function(a) {
        for (var b in this.mDefaultSkeletonList) {
            var c = this.mDefaultSkeletonList[b];
            c.getGroupID() == a && this.mDefaultSkeletonList.splice(b, 1)
        }
        for (var d in this.mSkeletonList) {
            var e = this.mSkeletonList[d];
            e.getGroupID() == a && this.mSkeletonList.splice(d, 1)
        }
    },
    releaseAllResources: function() {
        this.mDefaultSkeletonList.clear(), this.mSkeletonList.clear()
    }
}, e3d.EditorState = {
    OFF: 0,
    ON: 1,
    EDIT: 2
};
var BoxEditor2d = function(a, b, c, d, e, f, g) {
    c = c || "", d = d || "", e = e || "", f = f || "", g = g || "", GameObject.call(this, a, b, g), this._width = 100, this._height = 100, this._scaleWidth = 1, this._scaleHeight = 1, this._minWith = 10, this._minHeight = 10, this._closeBtnSize = 0, this._editBtnSize = 0, this._rightTopBtnSize = 0, this._borderWidthRatio = .02, this._fixBorderWidth = 0, this._fixBtnRadius = 0, this._bBtnResizable = !0, this._bEditable = !0, this._bCloseable = !1, this._bMovable = !0, this._state = e3d.EditorState.OFF, this.LOCK_STATE = {}, this.LOCK_STATE.LOCK = 0, this.LOCK_STATE.UNLOCK = 1, this._lockState = this.LOCK_STATE.UNLOCK, this._isTouchDown = !1, this._touchDownPos = new Vector3(0, 0, 0), this._touchDownOffset = new Vector3(0, 0, 0), this._ratio = 0, this._initRadian = 0, this._initScaleWidth = 1, this._initScaleHeight = 1, this._initDerivedScaleWidth = 1, this._initDerivedScaleHeight = 1, this._anchorOffset = new Vector2(0, 0), this._closeBtnRect = new Mesh;
    var h = new eRectManipulator(a, this._closeBtnRect);
    this._closeBtnRect.mManipulator = h, h.name = b + "_closeBtnRect", h.mAnchor = CENTER, h.updateVertices(), a.mMeshMap[h.name] = this._closeBtnRect, this._editBtnRect = new Mesh;
    var h = new eRectManipulator(a, this._editBtnRect);
    this._editBtnRect.mManipulator = h, h.name = b + "_editBtnRect", h.mAnchor = CENTER, h.updateVertices(), a.mMeshMap[h.name] = this._editBtnRect, this._lockBtnRect = new Mesh;
    var h = new eRectManipulator(a, this._lockBtnRect);
    this._lockBtnRect.mManipulator = h, h.name = b + "_lockBtnRect", h.mAnchor = CENTER, h.updateVertices(), a.mMeshMap[h.name] = this._lockBtnRect, this._unlockBtnRect = new Mesh;
    var h = new eRectManipulator(a, this._unlockBtnRect);
    this._unlockBtnRect.mManipulator = h, h.name = b + "_unlockBtnRect", h.mAnchor = CENTER, h.updateVertices(), a.mMeshMap[h.name] = this._unlockBtnRect, this._leftBorderRect = new Mesh;
    var h = new eRectManipulator(a, this._leftBorderRect);
    this._leftBorderRect.mManipulator = h, h.name = b + "_leftBorderRect", h.mAnchor = CENTER, h.updateVertices(), a.mMeshMap[h.name] = this._leftBorderRect, this._rightBorderRect = new Mesh;
    var h = new eRectManipulator(a, this._rightBorderRect);
    this._rightBorderRect.mManipulator = h, h.name = b + "_rightBorderRect", h.mAnchor = CENTER, h.updateVertices(), a.mMeshMap[h.name] = this._rightBorderRect, this._topBorderRect = new Mesh;
    var h = new eRectManipulator(a, this._topBorderRect);
    this._topBorderRect.mManipulator = h, h.name = b + "_topBorderRect", h.mAnchor = CENTER, h.updateVertices(), a.mMeshMap[h.name] = this._topBorderRect, this._bottomBorderRect = new Mesh;
    var h = new eRectManipulator(a, this._bottomBorderRect);
    this._bottomBorderRect.mManipulator = h, h.name = b + "_bottomBorderRect", h.mAnchor = CENTER, h.updateVertices(), a.mMeshMap[h.name] = this._topBorderRect, this.setTag(BoxEditor2d.TAG), this._contentContainer = new GameObject(a, b + "_contentContainer", this.getGroupID()), this._content = null, this._closeBtn = new GameObject(a, b + "_closeBtn", this.getGroupID()), this._closeBtn.setTag(BoxEditor2d.TAG), this._bCloseable || this._closeBtn.setVisible(!1), this._editBtn = new GameObject(a, b + "_editBtn", this.getGroupID()), this._editBtn.setTag(BoxEditor2d.TAG), this._leftBottomGo = new GameObject(a, b + "_leftBottomGo", this.getGroupID()), this._lockBtnGo = new GameObject(a, b + "_lockBtnGo", this.getGroupID()), this._lockBtnGo.setTag(BoxEditor2d.TAG), this._unlockBtnGo = new GameObject(a, b + "_unlockBtnGo", this.getGroupID()), this._unlockBtnGo.setTag(BoxEditor2d.TAG), this._leftBorder = new GameObject(a, b + "_leftBorder", this.getGroupID()), this._rightBorder = new GameObject(a, b + "_rightBorder", this.getGroupID()), this._topBorder = new GameObject(a, b + "_topBorder", this.getGroupID()), this._bottomBorder = new GameObject(a, b + "_bottomBorder", this.getGroupID()), this._closeBtn.MeshFilter.mesh = b + "_closeBtnRect", this._editBtn.MeshFilter.mesh = b + "_editBtnRect", this._lockBtnGo.MeshFilter.mesh = b + "_lockBtnRect", this._unlockBtnGo.MeshFilter.mesh = b + "_unlockBtnRect", this._leftBorder.MeshFilter.mesh = b + "_leftBorderRect", this._rightBorder.MeshFilter.mesh = b + "_rightBorderRect", this._topBorder.MeshFilter.mesh = b + "_topBorderRect", this._bottomBorder.MeshFilter.mesh = b + "_bottomBorderRect";
    var i = new MaterialAutoBuildParameters;
    i.type = "surface", "" != c ? (i.color = "", i.colorMap = c) : (i.color = "0.2 0.2 0.2 1.0", i.colorMap = ""), i.depth_check = "false", i.depth_write = "false", this._closeBtnMat = this.mRoot.getMaterialManager().buildMaterial(b + "_closeBtnMat", g, i, ""), this._closeBtnMat.load(), i.type = "surface", "" != d ? (i.color = "", i.colorMap = d) : (i.color = "1.0 0.0 0.0 1.0", i.colorMap = ""), i.depth_check = "false", i.depth_write = "false", this._editBtnMat = this.mRoot.getMaterialManager().buildMaterial(b + "_editBtnMat", g, i, ""), this._editBtnMat.load(), i.type = "surface", "" != e ? (i.color = "", i.colorMap = e) : (i.color = "1.0 1.0 0.0 1.0", i.colorMap = ""), i.depth_check = "false", i.depth_write = "false", this._lockBtnMat = this.mRoot.getMaterialManager().buildMaterial(b + "_lockBtnMat", g, i, ""), this._editBtnMat.load(), i.type = "surface", "" != f ? (i.color = "", i.colorMap = f) : (i.color = "1.0 1.0 0.5 1.0", i.colorMap = ""), i.depth_check = "false", i.depth_write = "false", this._unlockBtnMat = this.mRoot.getMaterialManager().buildMaterial(b + "_unlockBtnMat", g, i, ""), this._editBtnMat.load(), i.type = "surface", i.color = "1.0 1.0 1.0 1.0", i.colorMap = "", i.depth_check = "false", i.depth_write = "false", this._leftBorderMat = this.mRoot.getMaterialManager().buildMaterial(b + "_leftBorderMat", g, i, ""), this._leftBorderMat.load(), this._rightBorderMat = this.mRoot.getMaterialManager().buildMaterial(b + "_rightBorderMat", g, i, ""), this._rightBorderMat.load(), this._topBorderMat = this.mRoot.getMaterialManager().buildMaterial(b + "_topBorderMat", g, i, ""), this._topBorderMat.load(), this._bottomBorderMat = this.mRoot.getMaterialManager().buildMaterial(b + "_bottomBorderMat", g, i, ""), this._bottomBorderMat.load(), this._closeBtn.Renderer.material = this._closeBtnMat, this._editBtn.Renderer.material = this._editBtnMat, this._lockBtnGo.Renderer.material = this._lockBtnMat, this._unlockBtnGo.Renderer.material = this._unlockBtnMat, this._leftBorder.Renderer.material = this._leftBorderMat, this._rightBorder.Renderer.material = this._rightBorderMat, this._topBorder.Renderer.material = this._topBorderMat, this._bottomBorder.Renderer.material = this._bottomBorderMat, this.addGameObject(this._contentContainer), this.addGameObject(this._leftBorder), this.addGameObject(this._rightBorder), this.addGameObject(this._topBorder), this.addGameObject(this._bottomBorder), this.addGameObject(this._closeBtn), this.addGameObject(this._editBtn), this.addGameObject(this._leftBottomGo), this.addGameObject(this._lockBtnGo), this.addGameObject(this._unlockBtnGo), this._update(), this._showEditor(!1), this.fixBtnSize(.1 * this.mRoot.getScreenWidth())
};
extend(BoxEditor2d, GameObject), BoxEditor2d.TAG = 1, BoxEditor2d.prototype._update = function(a) {
    null == a && (a = !1);
    var b = this.getTransform()._getDerivedScale(),
        c = this._width * this._scaleWidth,
        d = this._height * this._scaleHeight;
    if (this._closeBtn.getTransform().setPosition(.5 * -c, .5 * -d, 0), this._editBtn.getTransform().setPosition(.5 * c, .5 * d, 0), this._leftBottomGo.getTransform().setPosition(.5 * -c, .5 * d, 0), this._lockBtnGo.getTransform().setPosition(.5 * c, .5 * -d, 0), this._unlockBtnGo.getTransform().setPosition(.5 * c, .5 * -d, 0), this._leftBorder.getTransform().setPosition(.5 * -c, 0, 0), this._rightBorder.getTransform().setPosition(.5 * c, 0, 0), this._topBorder.getTransform().setPosition(0, .5 * -d, 0), this._bottomBorder.getTransform().setPosition(0, .5 * d, 0), this._bBtnResizable) {
        var e = c * this._borderWidthRatio / b.x,
            f = c * this._borderWidthRatio / b.y;
        this._leftBorderRect.resize(e, d + f), this._rightBorderRect.resize(e, d + f), this._topBorderRect.resize(c + e, f), this._bottomBorderRect.resize(c + e, f);
        var g = .1 * Math.sqrt(c * c + d * d);
        this._closeBtnSize = g, this._editBtnSize = g, this._rightTopBtnSize = g, this._closeBtnRect.resize(this._closeBtnSize / b.x, this._closeBtnSize / b.y), this._editBtnRect.resize(this._editBtnSize / b.x, this._editBtnSize / b.y), this._lockBtnRect.resize(this._rightTopBtnSize / b.x, this._rightTopBtnSize / b.y), this._unlockBtnRect.resize(this._rightTopBtnSize / b.x, this._rightTopBtnSize / b.y)
    } else {
        var h = d + this._fixBorderWidth;
        this._leftBorderRect.resize(this._fixBorderWidth, h), this._rightBorderRect.resize(this._fixBorderWidth, h), h = c + this._fixBorderWidth, this._topBorderRect.resize(h, this._fixBorderWidth), this._bottomBorderRect.resize(h, this._fixBorderWidth)
    }
    a && !this._bBtnResizable && (this._closeBtnSize = this._fixBtnRadius, this._editBtnSize = this._fixBtnRadius, this._rightTopBtnSize = this._fixBtnRadius, this._closeBtnRect.resize(this._closeBtnSize / b.x, this._closeBtnSize / b.y), this._editBtnRect.resize(this._editBtnSize / b.x, this._editBtnSize / b.y), this._lockBtnRect.resize(this._rightTopBtnSize / b.x, this._rightTopBtnSize / b.y), this._unlockBtnRect.resize(this._rightTopBtnSize / b.x, this._rightTopBtnSize / b.y))
}, BoxEditor2d.prototype._setScale = function(a, b) {
    a > 0 && b > 0 && (this._scaleWidth = a, this._scaleHeight = b, this._contentContainer.getTransform().setScale(this._scaleWidth, this._scaleHeight, 1))
}, BoxEditor2d.prototype.attachToGameObject = function(a) {
    if (null != this._content && this.detachGameObject(), null == this._content) {
        var b = a.getParent();
        if (b) {
            var c = a.getMeshFilter();
            if (c) {
                var d = c.getMesh();
                if (d) {
                    var e = a.getParentSceneManager();
                    if (e) {
                        this._assignParentSceneMgr(e), this._content = a, b.removeGameObject(this._content), b.addGameObject(this), this._contentContainer.addGameObject(this._content);
                        var f = this._content.getTransform(),
                            g = f.getScale();
                        this._initScaleWidth = g.x, this._initScaleHeight = g.y, this._initDerivedScaleWidth = f._getDerivedScale().x, this._initDerivedScaleHeight = f._getDerivedScale().y, this._setScale(g.x, g.y), f.setScale(1, 1, 1);
                        var h = f.getPosition(),
                            i = d.getAnchor();
                        this._anchorOffset = new Vector2(i.x - .5, i.y - .5);
                        var j = f.getOrientation().multiply(new Vector3(-d.getWidth() * this._scaleWidth * this._anchorOffset.x, -d.getHeight() * this._scaleHeight * this._anchorOffset.y, 0));
                        this.getTransform().setPosition(h.add(j)), f.setPosition(d.getWidth() * this._anchorOffset.x, d.getHeight() * this._anchorOffset.y, 0), this.getTransform().setOrientation(f.getOrientation()), f.resetOrientation(), this.setSize(d.getWidth(), d.getHeight()), this._content.isGestureAllowed(EVENT_DRAG) ? this._setLockState(this.LOCK_STATE.UNLOCK) : this._setLockState(this.LOCK_STATE.LOCK), this._update(!0)
                    }
                }
            }
        }
    }
}, BoxEditor2d.prototype.getAttachedGameObject = function() {
    return this._content
}, BoxEditor2d.prototype.detachGameObject = function() {
    if (this._content) {
        var a = this._content.getMeshFilter().getMesh(),
            b = this._content.getTransform(),
            c = this.getTransform().getOrientation().multiply(new Vector3(a.getWidth() * this._scaleWidth * this._anchorOffset.x, a.getHeight() * this._scaleHeight * this._anchorOffset.y, 0));
        b.setPosition(this.getTransform().getPosition().add(c)), b.setScale(this._contentContainer.getTransform().getScale()), b.setOrientation(this.getTransform().getOrientation());
        var d = this.getParent();
        d.removeGameObject(this), this._contentContainer.removeGameObject(this._content), d.addGameObject(this._content), this._assignParentSceneMgr(null), this._content = null
    }
}, BoxEditor2d.prototype._assignParentSceneMgr = function(a) {
    this.setParentSceneManager(a), this._contentContainer.setParentSceneManager(a), this._leftBorder.setParentSceneManager(a), this._rightBorder.setParentSceneManager(a), this._topBorder.setParentSceneManager(a), this._bottomBorder.setParentSceneManager(a), this._closeBtn.setParentSceneManager(a), this._editBtn.setParentSceneManager(a), this._leftBottomGo.setParentSceneManager(a), this._lockBtnGo.setParentSceneManager(a), this._unlockBtnGo.setParentSceneManager(a)
}, BoxEditor2d.prototype._isTouchCloseBox = function(a, b) {
    if (!this._bCloseable) return !1;
    var c = this._closeBtn.getTransform(),
        d = c._getDerivedPosition(),
        e = Math.sqrt(Math.sqr(a - d.x) + Math.sqr(b - d.y));
    return e < this._closeBtnSize / 2 ? !0 : !1
}, BoxEditor2d.prototype._isTouchEditBox = function(a, b) {
    var c = this._editBtn.getTransform(),
        d = c._getDerivedPosition(),
        e = Math.sqrt(Math.sqr(a - d.x) + Math.sqr(b - d.y));
    return e < this._editBtnSize / 2 ? !0 : !1
}, BoxEditor2d.prototype._isTouchRightTopBox = function(a, b) {
    var c = this._unlockBtnGo.getTransform(),
        d = c._getDerivedPosition(),
        e = Math.sqrt(Math.sqr(a - d.x) + Math.sqr(b - d.y));
    return e < this._rightTopBtnSize / 2 ? !0 : !1
}, BoxEditor2d.prototype._isTouchWholeBox = function(a, b) {
    this._closeBtn.getTransform()._updateFromParent(), this._leftBottomGo.getTransform()._updateFromParent();
    var c = this._closeBtn.getTransform()._getDerivedPosition(),
        d = this._leftBottomGo.getTransform()._getDerivedPosition(),
        e = this._editBtn.getTransform()._getDerivedPosition(),
        f = this._unlockBtnGo.getTransform()._getDerivedPosition(),
        g = new Vector3(a, b, 0),
        h = c.sub(d),
        i = g.sub(d),
        j = h.cross(i);
    return j.z < 0 ? !1 : (h = d.sub(e), i = g.sub(e), j = h.cross(i), j.z < 0 ? !1 : (h = e.sub(f), i = g.sub(f), j = h.cross(i), j.z < 0 ? !1 : (h = f.sub(c), i = g.sub(c), j = h.cross(i), j.z < 0 ? !1 : !0)))
}, BoxEditor2d.prototype._setLockState = function(a) {
    switch (this._lockState = a, a) {
        case this.LOCK_STATE.LOCK:
            this._lockBtnGo.setVisible(!0), this._unlockBtnGo.setVisible(!1), this._editBtn.setVisible(!1), this._closeBtn.setVisible(!1), this._content.isGestureAllowed(EVENT_DRAG) && this._content.disableDragGesture();
            break;
        case this.LOCK_STATE.UNLOCK:
            this._lockBtnGo.setVisible(!1), this._unlockBtnGo.setVisible(!0), this._editBtn.setVisible(!0), this._bCloseable && this._closeBtn.setVisible(!0), this._content.isGestureAllowed(EVENT_DRAG) || this._content.enableDefaultAutoDrag()
    }
}, BoxEditor2d.prototype._lockBtnPressed = function() {
    switch (this._lockState) {
        case this.LOCK_STATE.LOCK:
            this._setLockState(this.LOCK_STATE.UNLOCK);
            break;
        case this.LOCK_STATE.UNLOCK:
            this._setLockState(this.LOCK_STATE.LOCK)
    }
}, BoxEditor2d.prototype._showEditor = function(a) {
    if (this._leftBorder.setVisible(a), this._rightBorder.setVisible(a), this._topBorder.setVisible(a), this._bottomBorder.setVisible(a), a) switch (this._lockState) {
        case this.LOCK_STATE.LOCK:
            this._lockBtnGo.setVisible(!0), this._unlockBtnGo.setVisible(!1), this._editBtn.setVisible(!1), this._closeBtn.setVisible(!1);
            break;
        case this.LOCK_STATE.UNLOCK:
            this._lockBtnGo.setVisible(!1), this._unlockBtnGo.setVisible(!0), this._editBtn.setVisible(!0), this._bCloseable && this._closeBtn.setVisible(!0)
    } else this._lockBtnGo.setVisible(!1), this._unlockBtnGo.setVisible(!1), this._editBtn.setVisible(!1), this._closeBtn.setVisible(!1)
}, BoxEditor2d.prototype.fixBtnSize = function(a) {
    this._bBtnResizable = !1, this._fixBtnRadius = a, this._fixBorderWidth = .05 * a
}, BoxEditor2d.prototype.setSize = function(a, b) {
    a < this._minWith || b < this._minHeight || (this._width = a, this._height = b)
}, BoxEditor2d.prototype.isInternalComponent = function(a) {
    return a == this._contentContainer || a == this._closeBtn || a == this._editBtn || a == this._leftBottomGo || a == this._lockBtnGo || a == this._unlockBtnGo || a == this._leftBorder || a == this._rightBorder || a == this._topBorder || a == this._bottomBorder ? !0 : !1
}, BoxEditor2d.prototype.OnTouchEvent = function(a, b, c) {
    if (this._bEditable) {
        if (a == e3d.TOUCH_DOWN) {
            if (this._state == e3d.EditorState.ON && this._isTouchCloseBox(b, c)) {
                var d = this._content,
                    e = d.getGroupID();
                return this.detachGameObject(), void this.mRoot.releaseResourceByGroupId(e)
            }
            if (this._state == e3d.EditorState.ON && this._isTouchRightTopBox(b, c)) return void this._lockBtnPressed();
            var f = this._isTouchWholeBox(b, c),
                g = this._isTouchEditBox(b, c);
            f || g ? (this._state == e3d.EditorState.OFF && (this._state = e3d.EditorState.ON, this._showEditor(!0)), g && this._lockState == this.LOCK_STATE.UNLOCK && (this._state = e3d.EditorState.EDIT, this._ratio = this._height / this._width, this._initRadian = Math.atan(this._ratio * this._initScaleHeight / this._initScaleWidth))) : this._state != e3d.EditorState.OFF && (this._state = e3d.EditorState.OFF, this._showEditor(!1))
        }
        if (this._state == e3d.EditorState.EDIT)
            if (a == e3d.TOUCH_UP) this._state = e3d.EditorState.ON;
            else if (a == e3d.TOUCH_MOVE) {
            var h = this.getTransform()._getDerivedPosition().distance(new Vector3(b, c, 0)),
                i = this._ratio * this._initScaleHeight / this._initScaleWidth,
                j = 2 * h / Math.sqrt(1 + i * i);
            this._setScale(j / this._width, j * i / this._height), this._update();
            var k;
            k = (c >= this.getTransform()._getDerivedPosition().y ? 1 : -1) * Math.acos((b - this.getTransform()._getDerivedPosition().x) / h), this.getTransform().resetOrientation();
            var l = this.getParent().getTransform()._getDerivedOrientation().getRoll().mRad;
            this.getTransform().roll(k - this._initRadian - l, TS_LOCAL)
        }
    }
    if (this._state != e3d.EditorState.EDIT && this._bMovable && this._lockState == this.LOCK_STATE.UNLOCK)
        if (a == e3d.TOUCH_DOWN) this._isTouchDown || this._isTouchWholeBox(b, c) && (this._isTouchDown = !0, this._touchDownPos = new Vector3(b, c, 0), this._touchDownOffset = this.getTransform()._getDerivedPosition().sub(this._touchDownPos));
        else if (a == e3d.TOUCH_UP) this._isTouchDown && (this._isTouchDown = !1);
    else if (a == e3d.TOUCH_MOVE && this._isTouchDown) {
        var m = this.getParent();
        m ? this.getTransform()._setDerivedPosition(new Vector3(b, c, 0).add(this._touchDownOffset)) : this.getTransform().setPosition(new Vector3(b, c, 0).add(this._touchDownOffset))
    }
};
var module;
! function(a, b, c) {
    function d(a, c, d) {
        var e = b.createElement("div"),
            f = b.createElement("div");
        return d === !0 && (e.style.cssText = "position:absolute;z-index:9999", f.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px"), f.className = "iScrollIndicator", "h" == a ? (d === !0 && (e.style.cssText += ";height:7px;left:2px;right:2px;bottom:0", f.style.height = "100%"), e.className = "iScrollHorizontalScrollbar") : (d === !0 && (e.style.cssText += ";width:7px;bottom:2px;top:2px;right:1px", f.style.width = "100%"), e.className = "iScrollVerticalScrollbar"), e.style.cssText += ";overflow:hidden", c || (e.style.pointerEvents = "none"), e.appendChild(f), e
    }

    function e(c, d) {
        this.wrapper = "string" == typeof d.el ? b.querySelector(d.el) : d.el,
            this.wrapperStyle = this.wrapper.style, this.indicator = this.wrapper.children[0], this.indicatorStyle = this.indicator.style, this.scroller = c, this.options = {
                listenX: !0,
                listenY: !0,
                interactive: !1,
                resize: !0,
                defaultScrollbars: !1,
                shrink: !1,
                fade: !1,
                speedRatioX: 0,
                speedRatioY: 0
            };
        for (var e in d) this.options[e] = d[e];
        this.sizeRatioX = 1, this.sizeRatioY = 1, this.maxPosX = 0, this.maxPosY = 0, this.options.interactive && (this.options.disableTouch || (g.addEvent(this.indicator, "touchstart", this), g.addEvent(a, "touchend", this)), this.options.disablePointer || (g.addEvent(this.indicator, g.prefixPointerEvent("pointerdown"), this), g.addEvent(a, g.prefixPointerEvent("pointerup"), this)), this.options.disableMouse || (g.addEvent(this.indicator, "mousedown", this), g.addEvent(a, "mouseup", this))), this.options.fade && (this.wrapperStyle[g.style.transform] = this.scroller.translateZ, this.wrapperStyle[g.style.transitionDuration] = g.isBadAndroid ? "0.001s" : "0ms", this.wrapperStyle.opacity = "0")
    }
    var f = a.requestAnimationFrame || a.webkitRequestAnimationFrame || a.mozRequestAnimationFrame || a.oRequestAnimationFrame || a.msRequestAnimationFrame || function(b) {
            a.setTimeout(b, 1e3 / 60)
        },
        g = function() {
            function d(a) {
                return g === !1 ? !1 : "" === g ? a : g + a.charAt(0).toUpperCase() + a.substr(1)
            }
            var e = {},
                f = b.createElement("div").style,
                g = function() {
                    for (var a, b = ["t", "webkitT", "MozT", "msT", "OT"], c = 0, d = b.length; d > c; c++)
                        if (a = b[c] + "ransform", a in f) return b[c].substr(0, b[c].length - 1);
                    return !1
                }();
            e.getTime = Date.now || function() {
                return (new Date).getTime()
            }, e.extend = function(a, b) {
                for (var c in b) a[c] = b[c]
            }, e.addEvent = function(a, b, c, d) {
                a.addEventListener(b, c, !!d)
            }, e.removeEvent = function(a, b, c, d) {
                a.removeEventListener(b, c, !!d)
            }, e.prefixPointerEvent = function(b) {
                return a.MSPointerEvent ? "MSPointer" + b.charAt(9).toUpperCase() + b.substr(10) : b
            }, e.momentum = function(a, b, d, e, f, g) {
                var h, i, j = a - b,
                    k = c.abs(j) / d;
                return g = void 0 === g ? 6e-4 : g, h = a + k * k / (2 * g) * (0 > j ? -1 : 1), i = k / g, e > h ? (h = f ? e - f / 2.5 * (k / 8) : e, j = c.abs(h - a), i = j / k) : h > 0 && (h = f ? f / 2.5 * (k / 8) : 0, j = c.abs(a) + h, i = j / k), {
                    destination: c.round(h),
                    duration: i
                }
            };
            var h = d("transform");
            return e.extend(e, {
                hasTransform: h !== !1,
                hasPerspective: d("perspective") in f,
                hasTouch: "ontouchstart" in a,
                hasPointer: a.PointerEvent || a.MSPointerEvent,
                hasTransition: d("transition") in f
            }), e.isBadAndroid = /Android /.test(a.navigator.appVersion) && !/Chrome\/\d/.test(a.navigator.appVersion), e.extend(e.style = {}, {
                transform: h,
                transitionTimingFunction: d("transitionTimingFunction"),
                transitionDuration: d("transitionDuration"),
                transitionDelay: d("transitionDelay"),
                transformOrigin: d("transformOrigin")
            }), e.hasClass = function(a, b) {
                var c = new RegExp("(^|\\s)" + b + "(\\s|$)");
                return c.test(a.className)
            }, e.addClass = function(a, b) {
                if (!e.hasClass(a, b)) {
                    var c = a.className.split(" ");
                    c.push(b), a.className = c.join(" ")
                }
            }, e.removeClass = function(a, b) {
                if (e.hasClass(a, b)) {
                    var c = new RegExp("(^|\\s)" + b + "(\\s|$)", "g");
                    a.className = a.className.replace(c, " ")
                }
            }, e.offset = function(a) {
                for (var b = -a.offsetLeft, c = -a.offsetTop; a = a.offsetParent;) b -= a.offsetLeft, c -= a.offsetTop;
                return {
                    left: b,
                    top: c
                }
            }, e.preventDefaultException = function(a, b) {
                for (var c in b)
                    if (b[c].test(a[c])) return !0;
                return !1
            }, e.extend(e.eventType = {}, {
                touchstart: 1,
                touchmove: 1,
                touchend: 1,
                mousedown: 2,
                mousemove: 2,
                mouseup: 2,
                pointerdown: 3,
                pointermove: 3,
                pointerup: 3,
                MSPointerDown: 3,
                MSPointerMove: 3,
                MSPointerUp: 3
            }), e.extend(e.ease = {}, {
                quadratic: {
                    style: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
                    fn: function(a) {
                        return a * (2 - a)
                    }
                },
                circular: {
                    style: "cubic-bezier(0.1, 0.57, 0.1, 1)",
                    fn: function(a) {
                        return c.sqrt(1 - --a * a)
                    }
                },
                back: {
                    style: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
                    fn: function(a) {
                        var b = 4;
                        return (a -= 1) * a * ((b + 1) * a + b) + 1
                    }
                },
                bounce: {
                    style: "",
                    fn: function(a) {
                        return (a /= 1) < 1 / 2.75 ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
                    }
                },
                elastic: {
                    style: "",
                    fn: function(a) {
                        var b = .22,
                            d = .4;
                        return 0 === a ? 0 : 1 == a ? 1 : d * c.pow(2, -10 * a) * c.sin((a - b / 4) * c.TWO_PI / b) + 1
                    }
                }
            }), e.tap = function(a, c) {
                var d = b.createEvent("Event");
                d.initEvent(c, !0, !0), d.pageX = a.pageX, d.pageY = a.pageY, a.target.dispatchEvent(d)
            }, e.click = function(a) {
                var c, d = a.target;
                /(SELECT|INPUT|TEXTAREA)/i.test(d.tagName) || (c = b.createEvent("MouseEvents"), c.initMouseEvent("click", !0, !0, a.view, 1, d.screenX, d.screenY, d.clientX, d.clientY, a.ctrlKey, a.altKey, a.shiftKey, a.metaKey, 0, null), c._constructed = !0, d.dispatchEvent(c))
            }, e
        }(),
        h = function(a, c) {
            this.wrapper = "string" == typeof a ? b.querySelector(a) : a, this.scroller = this.wrapper.children[0], this.scrollerStyle = this.scroller.style, this.options = {
                resizeScrollbars: !0,
                mouseWheelSpeed: 20,
                snapThreshold: .334,
                startX: 0,
                startY: 0,
                scrollY: !0,
                directionLockThreshold: 5,
                momentum: !0,
                bounce: !0,
                bounceTime: 600,
                bounceEasing: "",
                preventDefault: !0,
                preventDefaultException: {
                    tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/
                },
                HWCompositing: !0,
                useTransition: !0,
                useTransform: !0
            };
            for (var d in c) this.options[d] = c[d];
            this.translateZ = this.options.HWCompositing && g.hasPerspective ? " translateZ(0)" : "", this.options.useTransition = g.hasTransition && this.options.useTransition, this.options.useTransform = g.hasTransform && this.options.useTransform, this.options.eventPassthrough = this.options.eventPassthrough === !0 ? "vertical" : this.options.eventPassthrough, this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault, this.options.scrollY = "vertical" == this.options.eventPassthrough ? !1 : this.options.scrollY, this.options.scrollX = "horizontal" == this.options.eventPassthrough ? !1 : this.options.scrollX, this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough, this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold, this.options.bounceEasing = "string" == typeof this.options.bounceEasing ? g.ease[this.options.bounceEasing] || g.ease.circular : this.options.bounceEasing, this.options.resizePolling = void 0 === this.options.resizePolling ? 60 : this.options.resizePolling, this.options.tap === !0 && (this.options.tap = "tap"), "scale" == this.options.shrinkScrollbars && (this.options.useTransition = !1), this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1, this.x = 0, this.y = 0, this.directionX = 0, this.directionY = 0, this._events = {}, this._init(), this.refresh(), this.scrollTo(this.options.startX, this.options.startY), this.enable()
        };
    h.prototype = {
        version: "5.1.3",
        _init: function() {
            this._initEvents(), (this.options.scrollbars || this.options.indicators) && this._initIndicators(), this.options.mouseWheel && this._initWheel(), this.options.snap && this._initSnap(), this.options.keyBindings && this._initKeys()
        },
        destroy: function() {
            this._initEvents(!0), this._execEvent("destroy")
        },
        _transitionEnd: function(a) {
            a.target == this.scroller && this.isInTransition && (this._transitionTime(), this.resetPosition(this.options.bounceTime) || (this.isInTransition = !1, this._execEvent("scrollEnd")))
        },
        _start: function(a) {
            if ((1 == g.eventType[a.type] || 0 === a.button) && this.enabled && (!this.initiated || g.eventType[a.type] === this.initiated)) {
                !this.options.preventDefault || g.isBadAndroid || g.preventDefaultException(a.target, this.options.preventDefaultException) || a.preventDefault();
                var b, d = a.touches ? a.touches[0] : a;
                this.initiated = g.eventType[a.type], this.moved = !1, this.distX = 0, this.distY = 0, this.directionX = 0, this.directionY = 0, this.directionLocked = 0, this._transitionTime(), this.startTime = g.getTime(), this.options.useTransition && this.isInTransition ? (this.isInTransition = !1, b = this.getComputedPosition(), this._translate(c.round(b.x), c.round(b.y)), this._execEvent("scrollEnd")) : !this.options.useTransition && this.isAnimating && (this.isAnimating = !1, this._execEvent("scrollEnd")), this.startX = this.x, this.startY = this.y, this.absStartX = this.x, this.absStartY = this.y, this.pointX = d.pageX, this.pointY = d.pageY, this._execEvent("beforeScrollStart")
            }
        },
        _move: function(a) {
            if (this.enabled && g.eventType[a.type] === this.initiated) {
                this.options.preventDefault && a.preventDefault();
                var b, d, e, f, h = a.touches ? a.touches[0] : a,
                    i = h.pageX - this.pointX,
                    j = h.pageY - this.pointY,
                    k = g.getTime();
                if (this.pointX = h.pageX, this.pointY = h.pageY, this.distX += i, this.distY += j, e = c.abs(this.distX), f = c.abs(this.distY), !(k - this.endTime > 300 && 10 > e && 10 > f)) {
                    if (this.directionLocked || this.options.freeScroll || (e > f + this.options.directionLockThreshold ? this.directionLocked = "h" : f >= e + this.options.directionLockThreshold ? this.directionLocked = "v" : this.directionLocked = "n"), "h" == this.directionLocked) {
                        if ("vertical" == this.options.eventPassthrough) a.preventDefault();
                        else if ("horizontal" == this.options.eventPassthrough) return void(this.initiated = !1);
                        j = 0
                    } else if ("v" == this.directionLocked) {
                        if ("horizontal" == this.options.eventPassthrough) a.preventDefault();
                        else if ("vertical" == this.options.eventPassthrough) return void(this.initiated = !1);
                        i = 0
                    }
                    i = this.hasHorizontalScroll ? i : 0, j = this.hasVerticalScroll ? j : 0, b = this.x + i, d = this.y + j, (b > 0 || b < this.maxScrollX) && (b = this.options.bounce ? this.x + i / 3 : b > 0 ? 0 : this.maxScrollX), (d > 0 || d < this.maxScrollY) && (d = this.options.bounce ? this.y + j / 3 : d > 0 ? 0 : this.maxScrollY), this.directionX = i > 0 ? -1 : 0 > i ? 1 : 0, this.directionY = j > 0 ? -1 : 0 > j ? 1 : 0, this.moved || this._execEvent("scrollStart"), this.moved = !0, this._translate(b, d), k - this.startTime > 300 && (this.startTime = k, this.startX = this.x, this.startY = this.y)
                }
            }
        },
        _end: function(a) {
            if (this.enabled && g.eventType[a.type] === this.initiated) {
                this.options.preventDefault && !g.preventDefaultException(a.target, this.options.preventDefaultException) && a.preventDefault();
                var b, d, e = (a.changedTouches ? a.changedTouches[0] : a, g.getTime() - this.startTime),
                    f = c.round(this.x),
                    h = c.round(this.y),
                    i = c.abs(f - this.startX),
                    j = c.abs(h - this.startY),
                    k = 0,
                    l = "";
                if (this.isInTransition = 0, this.initiated = 0, this.endTime = g.getTime(), !this.resetPosition(this.options.bounceTime)) {
                    if (this.scrollTo(f, h), !this.moved) return this.options.tap && g.tap(a, this.options.tap), this.options.click && g.click(a), void this._execEvent("scrollCancel");
                    if (this._events.flick && 200 > e && 100 > i && 100 > j) return void this._execEvent("flick");
                    if (this.options.momentum && 300 > e && (b = this.hasHorizontalScroll ? g.momentum(this.x, this.startX, e, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : {
                            destination: f,
                            duration: 0
                        }, d = this.hasVerticalScroll ? g.momentum(this.y, this.startY, e, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : {
                            destination: h,
                            duration: 0
                        }, f = b.destination, h = d.destination, k = c.max(b.duration, d.duration), this.isInTransition = 1), this.options.snap) {
                        var m = this._nearestSnap(f, h);
                        this.currentPage = m, k = this.options.snapSpeed || c.max(c.max(c.min(c.abs(f - m.x), 1e3), c.min(c.abs(h - m.y), 1e3)), 300), f = m.x, h = m.y, this.directionX = 0, this.directionY = 0, l = this.options.bounceEasing
                    }
                    return f != this.x || h != this.y ? ((f > 0 || f < this.maxScrollX || h > 0 || h < this.maxScrollY) && (l = g.ease.quadratic), void this.scrollTo(f, h, k, l)) : void this._execEvent("scrollEnd")
                }
            }
        },
        _resize: function() {
            var a = this;
            clearTimeout(this.resizeTimeout), this.resizeTimeout = setTimeout(function() {
                a.refresh()
            }, this.options.resizePolling)
        },
        resetPosition: function(a) {
            var b = this.x,
                c = this.y;
            return a = a || 0, !this.hasHorizontalScroll || this.x > 0 ? b = 0 : this.x < this.maxScrollX && (b = this.maxScrollX), !this.hasVerticalScroll || this.y > 0 ? c = 0 : this.y < this.maxScrollY && (c = this.maxScrollY), b == this.x && c == this.y ? !1 : (this.scrollTo(b, c, a, this.options.bounceEasing), !0)
        },
        disable: function() {
            this.enabled = !1
        },
        enable: function() {
            this.enabled = !0
        },
        refresh: function() {
            this.wrapper.offsetHeight;
            this.wrapperWidth = this.wrapper.clientWidth, this.wrapperHeight = this.wrapper.clientHeight, this.scrollerWidth = this.scroller.offsetWidth, this.scrollerHeight = this.scroller.offsetHeight, this.maxScrollX = this.wrapperWidth - this.scrollerWidth, this.maxScrollY = this.wrapperHeight - this.scrollerHeight, this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0, this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0, this.hasHorizontalScroll || (this.maxScrollX = 0, this.scrollerWidth = this.wrapperWidth), this.hasVerticalScroll || (this.maxScrollY = 0, this.scrollerHeight = this.wrapperHeight), this.endTime = 0, this.directionX = 0, this.directionY = 0, this.wrapperOffset = g.offset(this.wrapper), this._execEvent("refresh"), this.resetPosition()
        },
        on: function(a, b) {
            this._events[a] || (this._events[a] = []), this._events[a].push(b)
        },
        off: function(a, b) {
            if (this._events[a]) {
                var c = this._events[a].indexOf(b);
                c > -1 && this._events[a].splice(c, 1)
            }
        },
        _execEvent: function(a) {
            if (this._events[a]) {
                var b = 0,
                    c = this._events[a].length;
                if (c)
                    for (; c > b; b++) this._events[a][b].apply(this, [].slice.call(arguments, 1))
            }
        },
        scrollBy: function(a, b, c, d) {
            a = this.x + a, b = this.y + b, c = c || 0, this.scrollTo(a, b, c, d)
        },
        scrollTo: function(a, b, c, d) {
            d = d || g.ease.circular, this.isInTransition = this.options.useTransition && c > 0, !c || this.options.useTransition && d.style ? (this._transitionTimingFunction(d.style), this._transitionTime(c), this._translate(a, b)) : this._animate(a, b, c, d.fn)
        },
        scrollToElement: function(a, b, d, e, f) {
            if (a = a.nodeType ? a : this.scroller.querySelector(a)) {
                var h = g.offset(a);
                h.left -= this.wrapperOffset.left, h.top -= this.wrapperOffset.top, d === !0 && (d = c.round(a.offsetWidth / 2 - this.wrapper.offsetWidth / 2)), e === !0 && (e = c.round(a.offsetHeight / 2 - this.wrapper.offsetHeight / 2)), h.left -= d || 0, h.top -= e || 0, h.left = h.left > 0 ? 0 : h.left < this.maxScrollX ? this.maxScrollX : h.left, h.top = h.top > 0 ? 0 : h.top < this.maxScrollY ? this.maxScrollY : h.top, b = void 0 === b || null === b || "auto" === b ? c.max(c.abs(this.x - h.left), c.abs(this.y - h.top)) : b, this.scrollTo(h.left, h.top, b, f)
            }
        },
        _transitionTime: function(a) {
            if (a = a || 0, this.scrollerStyle[g.style.transitionDuration] = a + "ms", !a && g.isBadAndroid && (this.scrollerStyle[g.style.transitionDuration] = "0.001s"), this.indicators)
                for (var b = this.indicators.length; b--;) this.indicators[b].transitionTime(a)
        },
        _transitionTimingFunction: function(a) {
            if (this.scrollerStyle[g.style.transitionTimingFunction] = a, this.indicators)
                for (var b = this.indicators.length; b--;) this.indicators[b].transitionTimingFunction(a)
        },
        _translate: function(a, b) {
            if (this.options.useTransform ? this.scrollerStyle[g.style.transform] = "translate(" + a + "px," + b + "px)" + this.translateZ : (a = c.round(a), b = c.round(b), this.scrollerStyle.left = a + "px", this.scrollerStyle.top = b + "px"), this.x = a, this.y = b, this.indicators)
                for (var d = this.indicators.length; d--;) this.indicators[d].updatePosition()
        },
        _initEvents: function(b) {
            var c = b ? g.removeEvent : g.addEvent,
                d = this.options.bindToWrapper ? this.wrapper : a;
            c(a, "orientationchange", this), c(a, "resize", this), this.options.click && c(this.wrapper, "click", this, !0), this.options.disableMouse || (c(this.wrapper, "mousedown", this), c(d, "mousemove", this), c(d, "mousecancel", this), c(d, "mouseup", this)), g.hasPointer && !this.options.disablePointer && (c(this.wrapper, g.prefixPointerEvent("pointerdown"), this), c(d, g.prefixPointerEvent("pointermove"), this), c(d, g.prefixPointerEvent("pointercancel"), this), c(d, g.prefixPointerEvent("pointerup"), this)), g.hasTouch && !this.options.disableTouch && (c(this.wrapper, "touchstart", this), c(d, "touchmove", this), c(d, "touchcancel", this), c(d, "touchend", this)), c(this.scroller, "transitionend", this), c(this.scroller, "webkitTransitionEnd", this), c(this.scroller, "oTransitionEnd", this), c(this.scroller, "MSTransitionEnd", this)
        },
        getComputedPosition: function() {
            var b, c, d = a.getComputedStyle(this.scroller, null);
            return this.options.useTransform ? (d = d[g.style.transform].split(")")[0].split(", "), b = +(d[12] || d[4]), c = +(d[13] || d[5])) : (b = +d.left.replace(/[^-\d.]/g, ""), c = +d.top.replace(/[^-\d.]/g, "")), {
                x: b,
                y: c
            }
        },
        _initIndicators: function() {
            function a(a) {
                for (var b = h.indicators.length; b--;) a.call(h.indicators[b])
            }
            var b, c = this.options.interactiveScrollbars,
                f = "string" != typeof this.options.scrollbars,
                g = [],
                h = this;
            this.indicators = [], this.options.scrollbars && (this.options.scrollY && (b = {
                el: d("v", c, this.options.scrollbars),
                interactive: c,
                defaultScrollbars: !0,
                customStyle: f,
                resize: this.options.resizeScrollbars,
                shrink: this.options.shrinkScrollbars,
                fade: this.options.fadeScrollbars,
                listenX: !1
            }, this.wrapper.appendChild(b.el), g.push(b)), this.options.scrollX && (b = {
                el: d("h", c, this.options.scrollbars),
                interactive: c,
                defaultScrollbars: !0,
                customStyle: f,
                resize: this.options.resizeScrollbars,
                shrink: this.options.shrinkScrollbars,
                fade: this.options.fadeScrollbars,
                listenY: !1
            }, this.wrapper.appendChild(b.el), g.push(b))), this.options.indicators && (g = g.concat(this.options.indicators));
            for (var i = g.length; i--;) this.indicators.push(new e(this, g[i]));
            this.options.fadeScrollbars && (this.on("scrollEnd", function() {
                a(function() {
                    this.fade()
                })
            }), this.on("scrollCancel", function() {
                a(function() {
                    this.fade()
                })
            }), this.on("scrollStart", function() {
                a(function() {
                    this.fade(1)
                })
            }), this.on("beforeScrollStart", function() {
                a(function() {
                    this.fade(1, !0)
                })
            })), this.on("refresh", function() {
                a(function() {
                    this.refresh()
                })
            }), this.on("destroy", function() {
                a(function() {
                    this.destroy()
                }), delete this.indicators
            })
        },
        _initWheel: function() {
            g.addEvent(this.wrapper, "wheel", this), g.addEvent(this.wrapper, "mousewheel", this), g.addEvent(this.wrapper, "DOMMouseScroll", this), this.on("destroy", function() {
                g.removeEvent(this.wrapper, "wheel", this), g.removeEvent(this.wrapper, "mousewheel", this), g.removeEvent(this.wrapper, "DOMMouseScroll", this)
            })
        },
        _wheel: function(a) {
            if (this.enabled) {
                a.preventDefault(), a.stopPropagation();
                var b, d, e, f, g = this;
                if (void 0 === this.wheelTimeout && g._execEvent("scrollStart"), clearTimeout(this.wheelTimeout), this.wheelTimeout = setTimeout(function() {
                        g._execEvent("scrollEnd"), g.wheelTimeout = void 0
                    }, 400), "deltaX" in a) 1 === a.deltaMode ? (b = -a.deltaX * this.options.mouseWheelSpeed, d = -a.deltaY * this.options.mouseWheelSpeed) : (b = -a.deltaX, d = -a.deltaY);
                else if ("wheelDeltaX" in a) b = a.wheelDeltaX / 120 * this.options.mouseWheelSpeed, d = a.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
                else if ("wheelDelta" in a) b = d = a.wheelDelta / 120 * this.options.mouseWheelSpeed;
                else {
                    if (!("detail" in a)) return;
                    b = d = -a.detail / 3 * this.options.mouseWheelSpeed
                }
                if (b *= this.options.invertWheelDirection, d *= this.options.invertWheelDirection, this.hasVerticalScroll || (b = d, d = 0), this.options.snap) return e = this.currentPage.pageX, f = this.currentPage.pageY, b > 0 ? e-- : 0 > b && e++, d > 0 ? f-- : 0 > d && f++, void this.goToPage(e, f);
                e = this.x + c.round(this.hasHorizontalScroll ? b : 0), f = this.y + c.round(this.hasVerticalScroll ? d : 0), e > 0 ? e = 0 : e < this.maxScrollX && (e = this.maxScrollX), f > 0 ? f = 0 : f < this.maxScrollY && (f = this.maxScrollY), this.scrollTo(e, f, 0)
            }
        },
        _initSnap: function() {
            this.currentPage = {}, "string" == typeof this.options.snap && (this.options.snap = this.scroller.querySelectorAll(this.options.snap)), this.on("refresh", function() {
                var a, b, d, e, f, g, h = 0,
                    i = 0,
                    j = 0,
                    k = this.options.snapStepX || this.wrapperWidth,
                    l = this.options.snapStepY || this.wrapperHeight;
                if (this.pages = [], this.wrapperWidth && this.wrapperHeight && this.scrollerWidth && this.scrollerHeight) {
                    if (this.options.snap === !0)
                        for (d = c.round(k / 2), e = c.round(l / 2); j > -this.scrollerWidth;) {
                            for (this.pages[h] = [], a = 0, f = 0; f > -this.scrollerHeight;) this.pages[h][a] = {
                                x: c.max(j, this.maxScrollX),
                                y: c.max(f, this.maxScrollY),
                                width: k,
                                height: l,
                                cx: j - d,
                                cy: f - e
                            }, f -= l, a++;
                            j -= k, h++
                        } else
                            for (g = this.options.snap, a = g.length, b = -1; a > h; h++)(0 === h || g[h].offsetLeft <= g[h - 1].offsetLeft) && (i = 0, b++), this.pages[i] || (this.pages[i] = []), j = c.max(-g[h].offsetLeft, this.maxScrollX), f = c.max(-g[h].offsetTop, this.maxScrollY), d = j - c.round(g[h].offsetWidth / 2), e = f - c.round(g[h].offsetHeight / 2), this.pages[i][b] = {
                                x: j,
                                y: f,
                                width: g[h].offsetWidth,
                                height: g[h].offsetHeight,
                                cx: d,
                                cy: e
                            }, j > this.maxScrollX && i++;
                    this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0), this.options.snapThreshold % 1 === 0 ? (this.snapThresholdX = this.options.snapThreshold, this.snapThresholdY = this.options.snapThreshold) : (this.snapThresholdX = c.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold), this.snapThresholdY = c.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold))
                }
            }), this.on("flick", function() {
                var a = this.options.snapSpeed || c.max(c.max(c.min(c.abs(this.x - this.startX), 1e3), c.min(c.abs(this.y - this.startY), 1e3)), 300);
                this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, a)
            })
        },
        _nearestSnap: function(a, b) {
            if (!this.pages.length) return {
                x: 0,
                y: 0,
                pageX: 0,
                pageY: 0
            };
            var d = 0,
                e = this.pages.length,
                f = 0;
            if (c.abs(a - this.absStartX) < this.snapThresholdX && c.abs(b - this.absStartY) < this.snapThresholdY) return this.currentPage;
            for (a > 0 ? a = 0 : a < this.maxScrollX && (a = this.maxScrollX), b > 0 ? b = 0 : b < this.maxScrollY && (b = this.maxScrollY); e > d; d++)
                if (a >= this.pages[d][0].cx) {
                    a = this.pages[d][0].x;
                    break
                }
            for (e = this.pages[d].length; e > f; f++)
                if (b >= this.pages[0][f].cy) {
                    b = this.pages[0][f].y;
                    break
                }
            return d == this.currentPage.pageX && (d += this.directionX, 0 > d ? d = 0 : d >= this.pages.length && (d = this.pages.length - 1), a = this.pages[d][0].x), f == this.currentPage.pageY && (f += this.directionY, 0 > f ? f = 0 : f >= this.pages[0].length && (f = this.pages[0].length - 1), b = this.pages[0][f].y), {
                x: a,
                y: b,
                pageX: d,
                pageY: f
            }
        },
        goToPage: function(a, b, d, e) {
            e = e || this.options.bounceEasing, a >= this.pages.length ? a = this.pages.length - 1 : 0 > a && (a = 0), b >= this.pages[a].length ? b = this.pages[a].length - 1 : 0 > b && (b = 0);
            var f = this.pages[a][b].x,
                g = this.pages[a][b].y;
            d = void 0 === d ? this.options.snapSpeed || c.max(c.max(c.min(c.abs(f - this.x), 1e3), c.min(c.abs(g - this.y), 1e3)), 300) : d, this.currentPage = {
                x: f,
                y: g,
                pageX: a,
                pageY: b
            }, this.scrollTo(f, g, d, e)
        },
        next: function(a, b) {
            var c = this.currentPage.pageX,
                d = this.currentPage.pageY;
            c++, c >= this.pages.length && this.hasVerticalScroll && (c = 0, d++), this.goToPage(c, d, a, b)
        },
        prev: function(a, b) {
            var c = this.currentPage.pageX,
                d = this.currentPage.pageY;
            c--, 0 > c && this.hasVerticalScroll && (c = 0, d--), this.goToPage(c, d, a, b)
        },
        _initKeys: function(b) {
            var c, d = {
                pageUp: 33,
                pageDown: 34,
                end: 35,
                home: 36,
                left: 37,
                up: 38,
                right: 39,
                down: 40
            };
            if ("object" == typeof this.options.keyBindings)
                for (c in this.options.keyBindings) "string" == typeof this.options.keyBindings[c] && (this.options.keyBindings[c] = this.options.keyBindings[c].toUpperCase().charCodeAt(0));
            else this.options.keyBindings = {};
            for (c in d) this.options.keyBindings[c] = this.options.keyBindings[c] || d[c];
            g.addEvent(a, "keydown", this), this.on("destroy", function() {
                g.removeEvent(a, "keydown", this)
            })
        },
        _key: function(a) {
            if (this.enabled) {
                var b, d = this.options.snap,
                    e = d ? this.currentPage.pageX : this.x,
                    f = d ? this.currentPage.pageY : this.y,
                    h = g.getTime(),
                    i = this.keyTime || 0,
                    j = .25;
                switch (this.options.useTransition && this.isInTransition && (b = this.getComputedPosition(), this._translate(c.round(b.x), c.round(b.y)), this.isInTransition = !1), this.keyAcceleration = 200 > h - i ? c.min(this.keyAcceleration + j, 50) : 0, a.keyCode) {
                    case this.options.keyBindings.pageUp:
                        this.hasHorizontalScroll && !this.hasVerticalScroll ? e += d ? 1 : this.wrapperWidth : f += d ? 1 : this.wrapperHeight;
                        break;
                    case this.options.keyBindings.pageDown:
                        this.hasHorizontalScroll && !this.hasVerticalScroll ? e -= d ? 1 : this.wrapperWidth : f -= d ? 1 : this.wrapperHeight;
                        break;
                    case this.options.keyBindings.end:
                        e = d ? this.pages.length - 1 : this.maxScrollX, f = d ? this.pages[0].length - 1 : this.maxScrollY;
                        break;
                    case this.options.keyBindings.home:
                        e = 0, f = 0;
                        break;
                    case this.options.keyBindings.left:
                        e += d ? -1 : 5 + this.keyAcceleration >> 0;
                        break;
                    case this.options.keyBindings.up:
                        f += d ? 1 : 5 + this.keyAcceleration >> 0;
                        break;
                    case this.options.keyBindings.right:
                        e -= d ? -1 : 5 + this.keyAcceleration >> 0;
                        break;
                    case this.options.keyBindings.down:
                        f -= d ? 1 : 5 + this.keyAcceleration >> 0;
                        break;
                    default:
                        return
                }
                if (d) return void this.goToPage(e, f);
                e > 0 ? (e = 0, this.keyAcceleration = 0) : e < this.maxScrollX && (e = this.maxScrollX, this.keyAcceleration = 0), f > 0 ? (f = 0, this.keyAcceleration = 0) : f < this.maxScrollY && (f = this.maxScrollY, this.keyAcceleration = 0), this.scrollTo(e, f, 0), this.keyTime = h
            }
        },
        _animate: function(a, b, c, d) {
            function e() {
                var m, n, o, p = g.getTime();
                return p >= l ? (h.isAnimating = !1, h._translate(a, b), void(h.resetPosition(h.options.bounceTime) || h._execEvent("scrollEnd"))) : (p = (p - k) / c, o = d(p), m = (a - i) * o + i, n = (b - j) * o + j, h._translate(m, n), void(h.isAnimating && f(e)))
            }
            var h = this,
                i = this.x,
                j = this.y,
                k = g.getTime(),
                l = k + c;
            this.isAnimating = !0, e()
        },
        handleEvent: function(a) {
            switch (a.type) {
                case "touchstart":
                case "pointerdown":
                case "MSPointerDown":
                case "mousedown":
                    this._start(a);
                    break;
                case "touchmove":
                case "pointermove":
                case "MSPointerMove":
                case "mousemove":
                    this._move(a);
                    break;
                case "touchend":
                case "pointerup":
                case "MSPointerUp":
                case "mouseup":
                case "touchcancel":
                case "pointercancel":
                case "MSPointerCancel":
                case "mousecancel":
                    this._end(a);
                    break;
                case "orientationchange":
                case "resize":
                    this._resize();
                    break;
                case "transitionend":
                case "webkitTransitionEnd":
                case "oTransitionEnd":
                case "MSTransitionEnd":
                    this._transitionEnd(a);
                    break;
                case "wheel":
                case "DOMMouseScroll":
                case "mousewheel":
                    this._wheel(a);
                    break;
                case "keydown":
                    this._key(a);
                    break;
                case "click":
                    a._constructed || (a.preventDefault(), a.stopPropagation())
            }
        }
    }, e.prototype = {
        handleEvent: function(a) {
            switch (a.type) {
                case "touchstart":
                case "pointerdown":
                case "MSPointerDown":
                case "mousedown":
                    this._start(a);
                    break;
                case "touchmove":
                case "pointermove":
                case "MSPointerMove":
                case "mousemove":
                    this._move(a);
                    break;
                case "touchend":
                case "pointerup":
                case "MSPointerUp":
                case "mouseup":
                case "touchcancel":
                case "pointercancel":
                case "MSPointerCancel":
                case "mousecancel":
                    this._end(a)
            }
        },
        destroy: function() {
            this.options.interactive && (g.removeEvent(this.indicator, "touchstart", this), g.removeEvent(this.indicator, g.prefixPointerEvent("pointerdown"), this), g.removeEvent(this.indicator, "mousedown", this), g.removeEvent(a, "touchmove", this), g.removeEvent(a, g.prefixPointerEvent("pointermove"), this), g.removeEvent(a, "mousemove", this), g.removeEvent(a, "touchend", this), g.removeEvent(a, g.prefixPointerEvent("pointerup"), this), g.removeEvent(a, "mouseup", this)), this.options.defaultScrollbars && this.wrapper.parentNode.removeChild(this.wrapper)
        },
        _start: function(b) {
            var c = b.touches ? b.touches[0] : b;
            b.preventDefault(), b.stopPropagation(), this.transitionTime(), this.initiated = !0, this.moved = !1, this.lastPointX = c.pageX, this.lastPointY = c.pageY, this.startTime = g.getTime(), this.options.disableTouch || g.addEvent(a, "touchmove", this), this.options.disablePointer || g.addEvent(a, g.prefixPointerEvent("pointermove"), this), this.options.disableMouse || g.addEvent(a, "mousemove", this), this.scroller._execEvent("beforeScrollStart")
        },
        _move: function(a) {
            var b, c, d, e, f = a.touches ? a.touches[0] : a;
            g.getTime();
            this.moved || this.scroller._execEvent("scrollStart"), this.moved = !0, b = f.pageX - this.lastPointX, this.lastPointX = f.pageX, c = f.pageY - this.lastPointY, this.lastPointY = f.pageY, d = this.x + b, e = this.y + c, this._pos(d, e), a.preventDefault(), a.stopPropagation()
        },
        _end: function(b) {
            if (this.initiated) {
                if (this.initiated = !1, b.preventDefault(), b.stopPropagation(), g.removeEvent(a, "touchmove", this), g.removeEvent(a, g.prefixPointerEvent("pointermove"), this), g.removeEvent(a, "mousemove", this), this.scroller.options.snap) {
                    var d = this.scroller._nearestSnap(this.scroller.x, this.scroller.y),
                        e = this.options.snapSpeed || c.max(c.max(c.min(c.abs(this.scroller.x - d.x), 1e3), c.min(c.abs(this.scroller.y - d.y), 1e3)), 300);
                    (this.scroller.x != d.x || this.scroller.y != d.y) && (this.scroller.directionX = 0, this.scroller.directionY = 0, this.scroller.currentPage = d, this.scroller.scrollTo(d.x, d.y, e, this.scroller.options.bounceEasing))
                }
                this.moved && this.scroller._execEvent("scrollEnd")
            }
        },
        transitionTime: function(a) {
            a = a || 0, this.indicatorStyle[g.style.transitionDuration] = a + "ms", !a && g.isBadAndroid && (this.indicatorStyle[g.style.transitionDuration] = "0.001s")
        },
        transitionTimingFunction: function(a) {
            this.indicatorStyle[g.style.transitionTimingFunction] = a
        },
        refresh: function() {
            this.transitionTime(), this.options.listenX && !this.options.listenY ? this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? "block" : "none" : this.options.listenY && !this.options.listenX ? this.indicatorStyle.display = this.scroller.hasVerticalScroll ? "block" : "none" : this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? "block" : "none", this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll ? (g.addClass(this.wrapper, "iScrollBothScrollbars"), g.removeClass(this.wrapper, "iScrollLoneScrollbar"), this.options.defaultScrollbars && this.options.customStyle && (this.options.listenX ? this.wrapper.style.right = "8px" : this.wrapper.style.bottom = "8px")) : (g.removeClass(this.wrapper, "iScrollBothScrollbars"), g.addClass(this.wrapper, "iScrollLoneScrollbar"), this.options.defaultScrollbars && this.options.customStyle && (this.options.listenX ? this.wrapper.style.right = "2px" : this.wrapper.style.bottom = "2px"));
            this.wrapper.offsetHeight;
            this.options.listenX && (this.wrapperWidth = this.wrapper.clientWidth, this.options.resize ? (this.indicatorWidth = c.max(c.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8), this.indicatorStyle.width = this.indicatorWidth + "px") : this.indicatorWidth = this.indicator.clientWidth, this.maxPosX = this.wrapperWidth - this.indicatorWidth, "clip" == this.options.shrink ? (this.minBoundaryX = -this.indicatorWidth + 8, this.maxBoundaryX = this.wrapperWidth - 8) : (this.minBoundaryX = 0, this.maxBoundaryX = this.maxPosX), this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX), this.options.listenY && (this.wrapperHeight = this.wrapper.clientHeight, this.options.resize ? (this.indicatorHeight = c.max(c.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8), this.indicatorStyle.height = this.indicatorHeight + "px") : this.indicatorHeight = this.indicator.clientHeight, this.maxPosY = this.wrapperHeight - this.indicatorHeight, "clip" == this.options.shrink ? (this.minBoundaryY = -this.indicatorHeight + 8, this.maxBoundaryY = this.wrapperHeight - 8) : (this.minBoundaryY = 0, this.maxBoundaryY = this.maxPosY), this.maxPosY = this.wrapperHeight - this.indicatorHeight, this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY), this.updatePosition()
        },
        updatePosition: function() {
            var a = this.options.listenX && c.round(this.sizeRatioX * this.scroller.x) || 0,
                b = this.options.listenY && c.round(this.sizeRatioY * this.scroller.y) || 0;
            this.options.ignoreBoundaries || (a < this.minBoundaryX ? ("scale" == this.options.shrink && (this.width = c.max(this.indicatorWidth + a, 8), this.indicatorStyle.width = this.width + "px"), a = this.minBoundaryX) : a > this.maxBoundaryX ? "scale" == this.options.shrink ? (this.width = c.max(this.indicatorWidth - (a - this.maxPosX), 8), this.indicatorStyle.width = this.width + "px", a = this.maxPosX + this.indicatorWidth - this.width) : a = this.maxBoundaryX : "scale" == this.options.shrink && this.width != this.indicatorWidth && (this.width = this.indicatorWidth, this.indicatorStyle.width = this.width + "px"), b < this.minBoundaryY ? ("scale" == this.options.shrink && (this.height = c.max(this.indicatorHeight + 3 * b, 8), this.indicatorStyle.height = this.height + "px"), b = this.minBoundaryY) : b > this.maxBoundaryY ? "scale" == this.options.shrink ? (this.height = c.max(this.indicatorHeight - 3 * (b - this.maxPosY), 8), this.indicatorStyle.height = this.height + "px", b = this.maxPosY + this.indicatorHeight - this.height) : b = this.maxBoundaryY : "scale" == this.options.shrink && this.height != this.indicatorHeight && (this.height = this.indicatorHeight, this.indicatorStyle.height = this.height + "px")), this.x = a, this.y = b, this.scroller.options.useTransform ? this.indicatorStyle[g.style.transform] = "translate(" + a + "px," + b + "px)" + this.scroller.translateZ : (this.indicatorStyle.left = a + "px", this.indicatorStyle.top = b + "px")
        },
        _pos: function(a, b) {
            0 > a ? a = 0 : a > this.maxPosX && (a = this.maxPosX), 0 > b ? b = 0 : b > this.maxPosY && (b = this.maxPosY), a = this.options.listenX ? c.round(a / this.sizeRatioX) : this.scroller.x, b = this.options.listenY ? c.round(b / this.sizeRatioY) : this.scroller.y, this.scroller.scrollTo(a, b)
        },
        fade: function(a, b) {
            if (!b || this.visible) {
                clearTimeout(this.fadeTimeout), this.fadeTimeout = null;
                var c = a ? 250 : 500,
                    d = a ? 0 : 300;
                a = a ? "1" : "0", this.wrapperStyle[g.style.transitionDuration] = c + "ms", this.fadeTimeout = setTimeout(function(a) {
                    this.wrapperStyle.opacity = a, this.visible = +a
                }.bind(this, a), d)
            }
        }
    }, h.utils = g, "undefined" != typeof module && module.exports ? module.exports = h : a.IScroll = h
}(window, document, Math);
var IScroll, Log = {};
Log.logCat = null;
var LogBoard = function() {
    var a = document.createElement("div");
    a.id = "wrapper", a.style.position = "absolute", a.style.left = 0, a.style.top = 0, a.style.height = "100%", a.style.width = "100%", a.style.zIndex = 900, a.style.color = "red", a.style.textAlign = "left", a.style.overflow = "hidden";
    var b = document.createElement("div");
    b.style.position = "absolute", b.style.right = 10, b.style.bottom = "50%", b.style.width = "35px", b.style.height = "25px", b.style.zIndex = 901, b.style.fontSize = "20px", b.style.textAlign = "center", b.style.fontWeight = "bold", b.style.color = "green", b.style.textAlign = "center", b.style.overflow = "hidden", b.innerHTML = "Log", b.onclick = function() {
        a.style.display = "none" == a.style.display ? "block" : "none"
    };
    var c = document.createElement("ul");
    a.appendChild(c), document.body.appendChild(a), document.body.appendChild(b), this.myScroll = new IScroll("#wrapper", {
        mouseWheel: !0,
        click: !0
    }), document.addEventListener("touchmove", function(a) {
        a.preventDefault()
    }, !1), this.append = function(a) {
        var b = document.createElement("li");
        b.innerHTML = a, c.appendChild(b), this.myScroll.refresh()
    }, this.on = function() {
        a.style.display = "block", b.style.display = "block"
    }, this.off = function() {
        a.style.display = "none", b.style.display = "none"
    }
};
Log.append = function(a) {}, Log.error = function(a) {
    Log.logCat && (Log.logCat.append("<span style='color:red'>" + a + "</span>"), Log.logCat.myScroll.refresh())
}, Log.info = function(a) {
    Log.logCat && (Log.logCat.append("<span style='color:blue'>" + a + "</span>"), Log.logCat.myScroll.refresh())
}, Log.on = function() {
    Log.logCat || (Log.logCat = new LogBoard), Log.logCat.on()
}, Log.off = function() {
    Log.logCat && Log.logCat.off()
};
var ImgLoadLog = {
    TotalNum: 0,
    loaded: 0
};
Log.LoadImg = function() {
    ImgLoadLog.TotalNum++
}, Log.LoadedImg = function() {
    ImgLoadLog.loaded++
};